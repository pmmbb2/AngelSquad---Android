<!DOCTYPE html>
<!--
    Licensed to the Apache Software Foundation (ASF) under one
    or more contributor license agreements.  See the NOTICE file
    distributed with this work for additional information
    regarding copyright ownership.  The ASF licenses this file
    to you under the Apache License, Version 2.0 (the
    "License"); you may not use this file except in compliance
    with the License.  You may obtain a copy of the License at

    http://www.apache.org/licenses/LICENSE-2.0

    Unless required by applicable law or agreed to in writing,
    software distributed under the License is distributed on an
    "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
     KIND, either express or implied.  See the License for the
    specific language governing permissions and limitations
    under the License.
-->
<html>
    <head>
        <!--
        Customize this policy to fit your own app's needs. For more guidance, see:
            https://github.com/apache/cordova-plugin-whitelist/blob/master/README.md#content-security-policy
        Some notes:
            * gap: is required only on iOS (when using UIWebView) and is needed for JS->native communication
            * https://ssl.gstatic.com is required only on Android and is needed for TalkBack to function properly
            * Disables use of inline scripts in order to mitigate risk of XSS vulnerabilities. To change this:
                * Enable inline JS: add 'unsafe-inline' to default-src
        -->
       <!-- <meta http-equiv="Content-Security-Policy" content="default-src 'self' data: gap: https://ssl.gstatic.com 'unsafe-eval'; style-src 'self' 'unsafe-inline'; media-src *; img-src 'self' data: content:;">-->
		<meta http-equiv="Content-Security-Policy" script-src='unsafe-inline';>
		
		<meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, target-densitydpi=medium-dpi, user-scalable=0" />		
		
        <link rel="stylesheet" type="text/css" href="css/app.css" />
    <link rel="stylesheet" type="text/css" href="css/index.css" />
    <link rel="stylesheet" type="text/css" href="css/UI-PARTS/ui-spritesheet.css" />
    <link rel="stylesheet" type="text/css" href="css/UI-animation.css" />
	
	<style>
    	* { padding: 0; margin: 0; touch-action: none }
    	
		/* above ground, aboveGround & sky */
		
		body{			
			/*background: url(game_assets/images/CLOUDS-BG-1-360x700.png) top center #09f;*/
			
			background: #09f;
		}
		
		
		#UI{
			z-index: 30;
			position: absolute;
			top: 0;
			cursor: none !important;
			/*background-color: rgba(0,254,0,0.2);
			border: solid red 1px;*/
			/*left: 0;
			width: 360;
			height: 732;
			background-color: rgba(0,254,0,0.2);
			display: none;*/
		}
		/*
		#menu{
		  position: fixed;
		  z-index: 1000
		}
		*/
		#canvas_main,
		#canvas_background,
		a#startGameBtn,
		/* DEV ONLY */
		a#testBtn,
		a#createStagesListBtn,
		a#pathBtn,
		a#reloadBtn,
		#log,
		#spawnCarButton,
		#spawnBallButton,
		#spawnPowerSwitchButton,
		#textArea
		/* DEV ONLY END */
		{
		  position: absolute;  
		}	
		
		#canvas_main{
		  z-index: 2;
		  top: 0px; 
		  border:solid red 1px;
		}
		
		#textArea{
		  z-index: 1000000000;
		  top: 0px; 
		  left:0;
		  width: 300px;
		  height: 300px;
		  background: white;
		  color:black;
		  display: none
		}
		
		#canvas_background{
		  z-index: 1;
		  top: 0px;  
		  border:solid blue 1px;
		}
		
		#ground{
			background-color: initial
		}
		
		/*
			APP UI 
			startGameBtn		
		*/
		a#startGameBtn,
		a#testBtn,
		a#createStagesListBtn,
		a#pathBtn,
		a#reloadBtn
		/*a#log*/{
			z-index: 11;/* ABOVE ground, aboveGround, sky, & UI */
			right:0;
			bottom: 0px;
			display: block;
			width: 50px;
			height: 20px; 
			padding: 1em;			
			font-size: 2em;
			color: #09f;
			border: 1px solid #09f
		}
		
		#spawnCarButton,
		#spawnBallButton,
		#spawnPowerSwitchButton{
			z-index: 11;
			left: 0%;
			bottom: 0px;
			display: block;
			width: 50px;
			height: 20px; 
			padding: 0.5em;			
			font-size: 2em;
			color: #f90;
			border: 1px solid #f90
		}
		
		a#spawnCarButton{
			margin-bottom: 80px
		}
		
		a#spawnPowerSwitchButton{
			margin-bottom: 160px
		}
		
		a#testBtn,
		a#createStagesListBtn{
			margin-bottom: 150px
		}
		
		a#testBtn,
		a#pathBtn{display: none}
		
		a#pathBtn,
		a#reloadBtn{
			margin-bottom: 75px
		}
		
		#log{
			z-index: 1000;
			top:0px;
			left: 0px;
			width: 100%;
			height: 100px;			
			background-color: rgba(254,254,254,0.5);
			color: #000;
			display: none;/**/
		}
		
		/*
			SHAKE CANVAS HORIZONTALLY -- begin
		*/
		.shakingH {
		  animation: shakingH 0.82s cubic-bezier(.36,.07,.19,.97) both;
		  transform: translate3d(0, 0, 0);
		  backface-visibility: hidden;
		  perspective: 1000px;
		}

		@keyframes shakingH {
		  10%, 90% {
			transform: translate3d(-1px, 0, 0);
		  }
		  
		  20%, 80% {
			transform: translate3d(2px, 0, 0);
		  }

		  30%, 50%, 70% {
			transform: translate3d(-4px, 0, 0);
		  }

		  40%, 60% {
			transform: translate3d(4px, 0, 0);
		  }
		}
		/*
			SHAKE CANVAS HORIZONTALLY -- end
		*/
		
		
		/*
			ZOOM IN OUT SHAKE
				USED AS VISUAL FEEDBACK 
				AFTER INCREASING A CHARACTER ATTRIBUTE -- begin
		*/
		
		.zoomInOutShake {
		  animation: zoomInOutShake 0.82s cubic-bezier(.36,.07,.19,.97) both;
      border-color: transparent;
		}
		@keyframes zoomInOutShake {
		  10% {
			transform: translate3d(0, -1px, 0)  scale(10);
		  }		  
		  20%, 80% {
			transform: translate3d(0, 2px, 0);
		  }
		  30%, 50%, 70% {
			transform: translate3d(0, -4px, 0);
		  }
		  40%, 60% {
			 transform: translate3d(0, 0, 0);      
		  }      
      100% {			
        border-right-color: #000
		  }
		}

		
		/*
			ZOOM IN OUT SHAKE -- end
		*/
		
		/*
			GLOW -- begin
		*/
		.glow {
		  animation: glow 0.50s linear both;
		  /*transform: translate3d(0, 0, 0);
		  backface-visibility: hidden;
		  perspective: 1000px;*/
		  background-color: transparent
		}

		@keyframes glow {
		  33% {
			background-color: gold
		  }
		  66% {
			background-color: #ffff00
		  }
		}
		/*
		  GLOW HORIZONTALLY -- end
		*/
		
		/*
			LOADING
		*/

		div#loadingStatusContainer{
			position: fixed;
			z-index: 1000000;
			top: 0px;
			left: 0px;
			width: 100%;
			height: 100%;
			/*background-color: #fff;      */
		}


		div#loadingStatus, .event.listening {			
			color: #09f;
			text-align: center;
			font-size: 3em;
			width: 4em;			
		
			top: unset;
			bottom: 0;
			position: absolute;
			background-color: rgba(255,255,255,1);
			left: 50%;
			margin-left: -2em;			
			border-radius: 0.50em;
			height: auto;
			line-height: 1;
		}

		div#modal.howTo.fullScreenPage .message{
			background-image: url(howToPlay.png) !important;
			background-position: center 10%;
			background-size: 257px 500px;
			background-repeat: no-repeat;
			height: 480px;    
			width: 260px;
			display: block;
		}


		
    </style>
	



    <title>Angel Squad - Beta 1</title>
</head>

<body>
    
	

<div class="container">
	<div id="menuBackground" class="sliding-background"></div>
</div>	
	
    <div id='loadingStatusContainer'>
		<div id='loadingStatus'>Loading</div>
	</div>
	<div id="homeScreen" class='page'>

		<div id="homeAngel" class="angel archer"></div>
	
		<ul>		 
		  <li><a href="#" class="btnShowHowTo">?</a></li>
		  <li>Angel Squad</li>
		  <li><a href="#stageSelection" class='navigation'>play</a></li>
		</ul>		
	</div>	
		
	<div id="characterSelection" class='page'>
		<div id="charSelectPaging">
				<a href="#" class="scrollTo left">&#8678</a>				
				<a href="#" class="scrollTo right">&#8680;</a>
				<!--
				<a href="#charLi0" class="scrollTo left">&#8678</a>
				<a href="#charLi3" class="scrollTo right">&#8680;</a>-->
		</div>			
		<div id="characterSelectionHeader" class="header">
			Select Angel			
		</div>
		
			<!-- CHARS LIST GENERATED HERE : generateCharacterSelectUI() -->
		
		<div id="characterSelectionFooter" class="footer">
			<ul>
			  <li><a href="#homeScreen" class='navigation goldenBtn stopMusic'>Home</a></li>
			  <li><a href="#stageSelection" class='navigation goldenBtn stopMusic'>Mission Select</a></li>
			  <li><a href="#" class='newGame goldenBtn stopMusic'>Campaign Select</a></li>			  
			</ul>
		</div>
	</div>
	
	<div id="campaignSelection" class='page'>
		<div id="campaignSelectionHeader" class="header">
			Select Campaign
		</div>
		<div id="campaignSelectionList">
			<ul></ul>
		</div>
		<div id="campaignSelectionFooter" class="footer">								
			<ul>
			  <li><a href="#homeScreen" class='navigation goldenBtn'>Home</a></li>
			  <li><a href="#stageSelection" class='navigation goldenBtn'>Mission Select</a></li>
			  <li><a href="#" class='changeCharacter goldenBtn'>Change Angel</a></li>			  
			</ul>	
		</div>		
	</div>
		
	<div id="stageSelection" class='page'>
		<div id="stageSelectionHeader" class="header">
			 Select Mission
			 <div class="scoreLbl">Score</div>
			<div id="totalScore">0</div>
		</div>
		<div id="stageSelectionFooter" class="footer">					
			<ul>
			  <li><a href="#homeScreen" class='navigation goldenBtn'>Home</a></li>
			  <li><a href="#" class='newGame goldenBtn'>Campaign Select</a></li>
			  <li><a href="#" class='changeCharacter goldenBtn'>Change Angel</a></li>			  
			</ul>	
		</div>		
	</div>
	
	<div id="characterDetails" class='page'>
		<div class="header">
		<img src="./game_assets/images/ANGEL-ARCHER-G-ARROW2.png" class="charImg">
			<span class="angelName screenTitle"></span>						
			<div class="profileGold">
				<span class="sprite ui-stage-gold-coin"></span>
				<span class="gold"></span>
			</div>
			<div class="description"></div>
		</div>
		<div class="footer">		
			<!--<div class="mission"><a href='#stageDetails' class="navigation goldenBtn">mission</a></div>			
			<div class="shop"><a href='#inventory' class="shopBtn navigation goldenBtn">equip</a></div>
			<ul>
			  <li><a href="#homeScreen" class='navigation goldenBtn'>Home</a></li>		 
			</ul>-->	
			<div class="mission"><a href='#stageDetails' class="navigation goldenBtn">mission</a></div>			
			<div class="shop"><a href='#inventory' class="shopBtn navigation goldenBtn">equip</a></div>
		</div>
	</div>
	
	<div id="inventory" class='page'>
		<div class="header">
		<img src="./game_assets/images/ANGEL-ARCHER-G-ARROW2.png" class="charImg">
			<span class="screenTitle">Equipment</span>								
			<div class="profileGold">
				<span class="sprite ui-stage-gold-coin"></span>
				<span class="gold"></span>
			</div>
			<div class="description"></div>
		</div>
		<div id="inventorySlotsHeader">equip</div>	
		<div class="footer">		
			<!--<div class="mission"><a href='#stageDetails' class="navigation goldenBtn">mission</a></div>			
			<div class="character"><a href='#characterDetails' class="navigation goldenBtn">angel</a></div>
			<ul>
			  <li><a href="#homeScreen" class='navigation goldenBtn'>Home</a></li>		 
			</ul>-->
			<div class="mission"><a href='#stageDetails' class="navigation goldenBtn">mission</a></div>			
			<div class="character"><a href='#characterDetails' class="navigation goldenBtn">angel</a></div>			
		</div>
	</div>		
	
	<div id="stagePayToContinue" class='page'>
		<div class="screenTitle">No more lives!</div>
		
		<div class="sprite ui-stage-wings-halo-360x75"></div>
		
		<!--<div class="character"><a href='#characterDetails' class="navigation goldenBtn">angel</a></div>			
		<div class="shop"><a href='#inventory' class="shopBtn navigation goldenBtn">equip</a></div>-->
		
		<div class="profileGold">	
			<span class='sprite ui-stage-gold-coin'></span>
			<span class='gold'></span>
		</div>
		
		<div class="stageDetailsControls">
			<a href='#' class='pay_to_continue'>
				<span class='sprite ui-stage-gold-coin'></span>
				<span class='amount'>1000</span>
				<span class='continue'>continue</span>
			</a>
			<a href='#' class='end_game sprite ui-stage-close-btn-47x47'><!--do not use gold to continue--></a>
		</div>		
	</div>
		
	<div id="stageDetails" class='sprite page sprite ui-stage-BG-360x700'>
		<div class="screenTitle">Mission</div>		
		<div class="sprite ui-stage-wings-halo-360x75"></div>		
		<div class="sprite UI-stage-3-stars-360x160"></div>		
		<div class="status">goal</div>		
		<ul class="objectivesList"></ul>		
		<div class="character"><a href='#characterDetails' class="navigation goldenBtn">angel</a></div>			
		<div class="shop"><a href='#inventory' class="shopBtn navigation goldenBtn">equip</a></div>		
		<div class='score-gold'>
			<span class='scoreLbl'>score</span>
			<span class='score'></span>			
			<span class='sprite ui-stage-gold-coin'></span>
			<span class='gold'></span>
		</div>		
		<div class="stageDetailsControls">
			<a href='#' class='stage_play sprite ui-stage-buttons-play'><!--play--></a>
			<a href='#stageSelection' class='navigation sprite ui-stage-close-btn-47x47'><!--stage select--></a>
		</div>		
	</div>
	
	
	<div id="modal">
		<div class="sprite ui-stage-wings-halo-360x75"></div>
		<div class='message'></div>
	</div>
	
	<div id="miniModal">
		<div class='message'></div>
	</div>
	
	<div id="miniModalCasualties">
		<div class='message'></div>
	</div>
		
	<div id="endStage" class='page sprite ui-stage-BG-360x700'>		
		<div class="star sprite hidden"></div>	
		<div class="screenTitle"></div>				
		<div class="sprite ui-stage-wings-halo-360x75"></div>
		<div id="starsHolder" class="sprite UI-stage-3-stars-360x160"></div>
		<div class="status"></div>		
		<ul class="objectivesList"></ul>
		<div class='score-gold'>
			<span class='scoreLbl'>score</span>
			<span class='score'></span>			
			<span class='sprite ui-stage-gold-coin'></span>
			<span class='gold'></span>
		</div>
		<div class='stageDetailsControls'>			
			<a href='#stageSelection' class='navigation sprite ui-stage-close-btn-47x47'><!--stage select--></a>
			<a href='#' class='stage_replay sprite ui-stage-buttons-replay'><!--replay--></a>
			<a href='#' class='stage_replay sprite ui-stage-buttons-retry'><!--retry--></a>
			<a href='#' class='stage_next sprite ui-stage-buttons-next'><!--next--></a>
		</div>
	</div>	
	
	<div id="pauseScreen" class='page'>		
		<div class="screenTitle">PAUSED</div>
		<ul>			  
		  <li><a href='#stageSelection' class='navigation quit'>quit</a></li>	 
		  <li><a href='#' class='pauseBtn'>resume</a></li>
		</ul>
	</div>
	
	<a id='pauseBtn' class='pauseBtn' href='#'>pause</a>
	<div id="UI_wrapper">	
		
		<div id='score'></div>		
		<div id='timer'></div>
		
		<div id='bricks'></div>
		<div id='combos'></div>		
		<div id='targets'></div>
		<div id='escortees'></div>
				
		<div id='livesStock'></div>	
		<div id="casualtiesContainer">
			<span id="casualtiesCount"></span>
			<span id="casualtiesMax"></span>
		</div>			
		<div class='gold'></div>
		
	</div>
	
	
	<!--<canvas id="electricArc" width="360" height="700" style="z-index: 20; position: absolute; left: 588px; top: 0px;"></canvas>-->
	<canvas id="electricArc" width="360" height="700"></canvas>
	
	<canvas id='UI' width="360" height="700"></canvas>
	
	<div id="app" class="app">			
		<div id="deviceready" class="blink">
			<p class="event listening">Loading</p>
			<p class="event received">Device is Ready</p>
		</div>
	</div>  
	

<!--
	<a href='#' id='startGameBtn'>Play</a>       
	<a href='#' id='testBtn'>Test</a>       
	<a href='#' id='reloadBtn'>Reload</a>       
	<a href='#' id='pathBtn'>Paths</a>       
	
	<a href='#' id='spawnCarButton'>+car</a>   
	<a href='#' id='spawnBallButton'>+ball</a>   
	<a href='#' id='spawnPowerSwitchButton'>+switch</a>
	<br />
	Log: <pre id="log" style="border: 1px solid #ccc;"></pre>
	
	<textarea id='textArea'></textarea>
-->	
<div id="log" style="border: 1px solid #ccc;position:fixed;top:0px;left:50%;z-index:98999999999999;width:100%;height:2em;"></div>

<!-- <script charset="utf-8" type="text/javascript" src="cordova.js"></script> -->
<script charset="utf-8" type="text/javascript" src="js/howler.core.js"></script>

<script type="text/javascript" src="js/dexie.min.js"></script>
<!-- <script type="text/javascript" src="js/dexie.min.js.map"></script>
<script type="text/javascript" src="js/dexie.d.ts"></script> -->
<script charset="utf-8" type="text/javascript" src="js/index.js"></script> 

<!-- USED FOR CREATING DEXIE BLOB ONLY, NOT FOR FINAL RELEASE-->
<script charset="utf-8" type="text/javascript" src="js/download.min.js"></script> 

<script charset="utf-8" type="text/javascript">

window.redirectIfBrowserWOServer = function(){

    fetch('./www/js/index.js')
    .then((e)=>{
        //console.log(e)
        if(e.ok === true){
            let U = e.url.split('/')
            U.pop()
            U.pop()
            return U.join('/')
        }
        else{
            return undefined
        }
    })
    .then((u)=>{
        if(typeof u !== 'undefined'){
            document.location.href = u 
        }                             
    })

}
/*
document.addEventListener("DOMContentLoaded",function(){
	try{
		app.initialize()
	}
	catch{
		redirectIfBrowserWOServer()	
	}
})
*/

app.initialize()

const MBG = document.querySelector('#menuBackground')

/*
	items[]:
		ALL ITEMS THE PLAYER CAN PURCHASE IN THE SHOP (#inventory)
*/
window.items = [
 {
    name: 'bow-arrow-powerup',
    lbl: 'wooden arrow',
    category: 'bow', // selector category
    entityName : 'bow-arrow-powerup.ent', // powerup entity 
    duration: 300,// how long the weapon remains equipped 
    cost: 500,
    description: 'shoot arrows at moderate speed'
 },
 {
    name: 'boxing-gloves-powerup',
    lbl: 'rookie gloves',
    category: 'gloves',
    entityName : 'boxing-gloves-powerup.ent', 
    duration: 300,
    cost: 200,
    description: 'punch out ennemies'
 },
 {
    name: 'sword-shield-powerup',
    lbl: 'trainee sword & shield',
    category: 'swordAndShield',
    entityName : 'sword-shield-powerup.ent', 
    duration: 300,
    cost: 300,
    description:'inflict ennemies moderate damage'
 } 
 ,
 {
    name: 'angel-portal-powerup',
    lbl: 'angel portal',
    category: 'portal',
    entityName : 'angel-portal-powerup.ent', 
    duration: 300,
    cost: 300,
    description: 'summon cherubs to help you'
 } 
]


/*
	selectedWeapons[]:
		WEAPONS THAT THE PLAYER CAN SELECT FROM INVENTORY
		DURING THE STAGE - INGAME
*/
window.selectedWeapons = [
  /*{
    category: 'bow', // selector category
    entityName : 'bow-arrow-powerup.ent', // powerup entity   
    duration: 300,// how long the weapon remains equipped when triggered in milliseconds
    count: 2 // how many instances usable during the stage
 },
 {
    category: 'gloves',
    entityName : 'boxing-gloves-powerup.ent',    
    duration: 300,
    count: 2
 },
 {
    category: 'swordAndShield',
    entityName : 'sword-shield-powerup.ent',    
    duration: 300,
   	count: 2
 },
 {
    category: 'portal',
    entityName : 'angel-portal-powerup.ent',    
    duration: 300,
   	count: 2
 }   */
]




window.lastClickedAttrBtn = null



/*
	GLOBAL COLORS FOR COLORED BRICKS
*/
var colors = 
  [
	'#000', '#444', '#222', 
	'#fff', '#999',
	'#00f', '#05f', '#09f', '#f0f', 
	'#fcf', '#808', '#f7f', 
	'#f00', '#f70', '#f90', '#fcc', 
	'#f40', '#ff0',
	'#090', '#0f0' 
  ]

/*
	DEXIE INDEXED DB
	DECLARE INIT

var Dexie = window.Dexie,
    async = Dexie.async,
    spawn = Dexie.spawn,
    db = new Dexie('ASDB')


	LOAD Dexie INDEXED DB 'ASDB'


	db.version(1).stores({
		profile: '++id,name,creationDate', // player name  
		  character: '++id,profileId,name', // 
			weapons: '++id,profileId,entityName', // boxing-gloves.ent  
		  campaigns: '++id,profileId,name',// name : name.cmp
			 stages: '++id,[name+campaignId]' // name : name.stg
	});
*/

/*
	DEXIE INDEXED DB
	
*/
var Dexie = window.Dexie,
	  async = Dexie.async,
	  spawn = Dexie.spawn,
	  db = new Dexie('ASDB')




/*
	profile{}
	
	contains all attributes, and collections from profile
	is used to init paddle on stage load (see loadStageFromstages())
	and as a reference, e.g. profile.character.strength
	profile{
		character:{
			strength:N,
			resistance:N,
			energy:N,
			charisma:N,
			lives:N
		}
	}
 */
 var 
 
 profile = {
	 character:{
		strength:0,
		resistance:0,
		energy:0,
		charisma:0
	},
	gold:0	
 },
 /*
	characterAttributes[]
		USED TO 
		- GENERATE CHARACTER ATTRIBUTES UI
		- PAY GOLD TO ENHANCE THEM
	
	SOME OR ALL OF THESE ATTRIBUTES CAN BE COPIED TO DB.characterAttributes
	WHICH WILL THEN BE LOADED TO GENERATE CHARACTER ATTRIBUTES UI
	cost, and max CAN EVOLVE ALONG THE PROGRESSION IN THE GAME:
	THE MORE AN ATTRIBUTE IS INCREASED THE MORE ITS cost INCREASES
	max COULD BE INCREASED BY PAYING OR BY BUYING SPECIFIC ITEMS
 */
 characterAttributes = [
 [
		/* G. Arrow */
	{
		id: 'strength',
		lbl: 'strength',
		cost: 200,		
		max: 10,
		description: 'add damage to close range weapons'
	},
	{
		id: 'resistance',
		lbl: 'resistance',
		cost: 200,		
		max: 10,
		description: 'reduce damage inflicted by ennemies'
	},
	{
		id: 'charisma',
		lbl: 'charisma',
		cost: 1000,		
		max: 10,
		description: 'angel portals attract more cherubs'
	},
	{
		id: 'energy',
		lbl: 'energy',
		cost: 100,		
		max: 100,
		description: 'maximum level of energy'
	},
	{
		id: 'lives',
		lbl: 'lives',
		cost: 200,		
		max: 5,
		description: 'no more lives, game over'
	}
],
/*  Gabrielle   */
[
	{
		id: 'strength',
		lbl: 'strength',
		cost: 400,		
		max: 10,
		description: 'add damage to close range weapons'
	},		
	{
		id: 'resistance',
		lbl: 'resistance',
		cost: 400,		
		max: 10,
		description: 'reduce damage inflicted by ennemies'
	},
	{
		id: 'charisma',
		lbl: 'charisma',
		cost: 200,		
		max: 10,
		description: 'angel portals attract more cherubs'
	},
	{
		id: 'energy',
		lbl: 'energy',
		cost: 50,		
		max: 50,
		description: 'maximum level of energy'
	},
	{
		id: 'lives',
		lbl: 'lives',
		cost: 100,		
		max: 10,
		description: 'no more lives, game over'
	}
],
	/*  M. Angelo */
[
	{
		id: 'strength',
		lbl: 'strength',
		cost: 100,		
		max: 10,
		description: 'add damage to close range weapons'
	},
	{
		id: 'resistance',
		lbl: 'resistance',
		cost: 100,		
		max: 10,
		description: 'reduce damage inflicted by ennemies'
	},
	{
		id: 'charisma',
		lbl: 'charisma',
		cost: 1000,		
		max: 10,
		description: 'angel portals attract more cherubs'
	},
	{
		id: 'energy',
		lbl: 'energy',
		cost: 100,		
		max: 100,
		description: 'maximum level of energy'
	},
	{
		id: 'lives',
		lbl: 'lives',
		cost: 200,		
		max: 5,
		description: 'no more lives, game over'
	}
],
/*  Cupid  */
[
	{
		id: 'strength',
		lbl: 'strength',
		cost: 1000,		
		max: 10,
		description: 'add damage to close range weapons'
	},
	{
		id: 'resistance',
		lbl: 'resistance',
		cost: 1000,		
		max: 10,
		description: 'reduce damage inflicted by ennemies'
	},
	{
		id: 'charisma',
		lbl: 'charisma',
		cost: 100,		
		max: 10,
		description: 'angel portals attract more cherubs'
	},
	{
		id: 'energy',
		lbl: 'energy',
		cost: 100,		
		max: 50,
		description: 'maximum level of energy'
	},
	{
		id: 'lives',
		lbl: 'lives',
		cost: 200,		
		max: 10,
		description: 'no more lives, game over'
	}
]],

characters = [
	{
		id:0,
		name:'G. Arrow',
		description:'Elite Archer - ranged fighter',
		strength: 2,
		resistance: 1,
		charisma: 2,
		energy: 50,
		lives: 3,
		imgSrc: "./game_assets/images/ANGEL-ARCHER-G-ARROW2.png"
	},
	{
		id:1,
		name:'Gabrielle',
		description:'Archangel - leads angels',
		strength:0,
		resistance:0,
		charisma:5,
		energy: 50,
		lives: 3,
		imgSrc: "./game_assets/images/ANGEL-GABRIELLE.png"		
	},
	{
		id:2,
		name:'M. Angelo',
		description:'Boxer - packs a punch',
		strength:5,
		resistance:3,
		charisma:0,
		energy: 100,
		lives: 3,
		imgSrc: "./game_assets/images/ANGEL-BOXER-M-ANGELO2.png"
	},
	{
		id:3,
		name:'Cupid',
		description:'Love Angel - loved by all',
		strength:1,
		resistance:1,
		charisma: 5,
		energy: 0,
		lives: 3,
		imgSrc: "./game_assets/images/ANGEL-CUPID-LEFT.png"
	}
]
,

charactersActionsSprites = [[],[],[],[]],
/* 
	charactersActionsSprites[N], N  = character.charId
	flying, boxing, shooting, pushing, swordShield
	actionName : spriteName
	0 : G. Arrow
	1 : Gabrielle
	2 : M. Angelo
	3 : Cupid 
*/
charactersActionsSprites = [
	{
		// GOLDEN ARROW
		'flying': 'angel-G-ARROW-fly.sprt', // sprite name with .sprt
		'boxing': 'angel-G-arrow-boxing.sprt', 
		'shooting': 'angel-archer-bow-arrow.sprt',
		'pushing': 'angel-archer-push-portal.sprt', 
		'swordShield': 'angel-g-arrow-sword-shield.sprt' 
	},
	{
		// Gabrielle
		'flying': 'angel-GABRIELLE-fly.sprt', // sprite name with .sprt
		'boxing': 'angel-GABRIELLE-boxing.sprt', 
		'shooting': 'angel-GABRIELLE-bow-arrow.sprt',
		'pushing': 'angel-GABRIELLE-push-portal.sprt', 
		'swordShield': 'angel-GABRIELLE-sword-shield.sprt' 
	},
	{
		// Miguel Angelo
		'flying': 'angel-M.angelo-fly.sprt', // sprite name with .sprt
		'boxing': 'angel-M.angelo-boxing.sprt', 
		'shooting': 'angel-M.angelo-archer.sprt',
		'pushing': 'angel-M.angelo-push-portal.sprt', 
		'swordShield': 'angel-M.angelo-sword-shield.sprt' 
	},
	{
		// Cupid
		'flying': 'angel-flying.sprt', // sprite name with .sprt
		'boxing': 'angel-boxing.sprt', 
		'shooting': 'angel-archer.sprt',
		'pushing': 'angel-flying.sprt', 
		'swordShield': 'angel-sword-shield.sprt' 
	}
]
,
promises = [], // for storing pending queries, used by assets loading
stageLoadPromise = '',
paused = false,
campaign = 'demo-campaign.cmp.json', // STORES THE CAMPAIGN CURRENTLY PLAYED - default value is the default campaign
stagesList = [],// list of stages names loaded from a campaign.cmp.json
 /*
	SOUNDS
 */
 sounds,
 soundsPlaying = [],
 /*
	CANVAS
 */ 
 canvases = 
	[		
		// DEDICATED TO DISPLAYING ENTITIES ON THE STAGE
		{ 'name':'groundScrolling', 'zIndex': 0, 'x':0, 'y': 0, 'width':360, 'height':700},
		{ 'name':'ground', 'zIndex': 1, 'x':1, 'y': 0, 'width':360, 'height':700},
		{ 'name':'aboveGroundScrolling', 'zIndex': 2, 'x':0, 'y': 0, 'width':360, 'height':700},		
		{ 'name':'aboveGround', 'zIndex': 3, 'x':0, 'y': 0, 'width':360, 'height':700},
		{ 'name':'midAir', 'zIndex': 4, 'x':0, 'y': 0, 'width':360, 'height':700},
		{ 'name':'skyScrolling', 'zIndex': 5, 'x':0, 'y': 0, 'width':360, 'height':700},		
		{ 'name':'sky', 'zIndex': 6, 'x':0, 'y': 0, 'width':360, 'height':700},
		{ 'name':'teleport', 'zIndex': 7, 'x':0, 'y': 0, 'width':360, 'height':700},
		// DEDICATED TO THE COMBO SYSTEM
		{ 'name':'energyPoints', 'zIndex': 8, 'x':0, 'y': 0, 'width':360, 'height':700},	
		{ 'name':'comboStar', 'zIndex': 9, 'x':0, 'y': 0, 'width':360, 'height':700},		
		{ 'name':'combo', 'zIndex': 10, 'x':0, 'y': 0, 'width':360, 'height':700}		
	], // USED BY entities editor & stages editor
 /* 
	SCROLLING:	
*/
/*
	collection of screens that will scroll one after another, then 
	go back to their default position when their y is > deviceHeight(700)
*/

scrollingScreens = [],
screensToScroll = [], // number of screens to scroll before stopping the scrolling
screensScrollSpeed = [], //scrolling y Vector
/*stageScrolling = [],   

	SCROLLING:
	scrollingScreens[] is is declared in stage.json
	it will be used to populate stageScrolling[]
*/
/*scrollingScreens = [	   
	{	
		'spriteName': 'grass_river.BG.sprt',
		'drawOnCanvas': 'groundScrolling',
		'loop': -1
	},
	{	
		'spriteName': 'grass_river.BG.sprt',
		'drawOnCanvas': 'groundScrolling',
		'loop': -1	
	},
	{	
		'spriteName': 'bridge.bg.sprt',
		'drawOnCanvas': 'groundScrolling',
		'loop': -1		
	}/
	{	
		'spriteName': 'forest2.sprt',
		'drawOnCanvas': 'groundScrolling',
		'loop': -1
	}
]*/
stageScrolling = [[],[],[]],

 // STAGE VARS
 ctxs = [],
 balls = [],// contains balls' sprite objects
 ball = {},
 ball_idx = 0,

 sprites = [],// contains any sprite object except balls
 sprite,
 
 paddle = {},
 
 paddleHeight = 50,
 paddleWidth = 50,
 paddleX,
 paddleY,
 
 gold = 0, 
 score = 0, 
 lives = 3,
 spawnBallInvincibilityTime = 1000,
 paddleInvincibilityTime = 1000,
 comboInterval = 5,// 10th of seconds
 combosObjects = [], // STORES COMBO OBJECTS -- parsed to display combos 
 // STAGE OBJECTIVES
 /*
	WHEN AN OBJECTIVE IS COMPLETED IT IS : 
	COPIED TO stageAchievements
	REMOVED FROM objectives
 */
 objectives = [],// COLLECTION POPULATED BY stage.json THAT WILL OBJECTIVE ITEMS
 stageAchievements = [], // COLLECTION OF OBJECTIVES THAT HAVE BEEN COMPLETED
 spritesEliminated = [], // COLLETION OF SPRITES THAT LOST ALL THEIR ENERGY
 escorteesSaved = [],
 timer = -1,// timer IS SET BY timer FROM stage.json : timer = timer, -1 = no timer | N sets timer to N (10ths of seconds)
 
 rightPressed = false,
 leftPressed = false,
 playOnce = false,
 displayAngel = false,
 
 maxCasualties = '',
 
 /*
	ACTIONS:
	can be executed by entities 
	on themselves 
	or on other entities
	params always contain attributes:		
		- SelfIdx, i.e. the entity index within array sprites[]
		- other attributes defined in the states editor of stages editor | entities editor
	the function can return any data 
 */
 actions = [
	
	/* ENTITY (sprite) REMOVES ITSELF FROM STAGE */	
	{"name":"removeSelf",
	 "Function": function(params){	
	 
		 if (typeof params.collection !== 'undefined' ){
			var collection = params.collection
			collection.splice( params.SelfIdx, 1)
			 //////alert('THAT IS THE ONE '+1123)	
		 } 
		 else{
			sprites.splice( params.SelfIdx, 1)
			 //////alert('THAT IS THE ONE '+1127)				
		 }
		 
		 return 'ENTITY IS REMOVED FROM STAGE'
	}},
	
	{"name":"lastState",
	 "Function": function(params){	
		let currentStateIndex = parseInt(params.This.currentStateIndex)
		
		if (currentStateIndex > 0){
			currentStateIndex --	
		}
		
		let This = params.This
		This.currentStateIndex = currentStateIndex
		
		//alert(This.currentStateIndex) 
		 
		 return 'ENTITY s LAST STATE'
	}},
	
	
	
	
	
	 /* ENTITY (sprite) SPAWNS AN ENTITY IN THE STAGE */	
	{"name":"spawn",
	 "Function": function( params ){
		 
		 var idx = params.SelfIdx		
		 var collection = (typeof params.collection !== 'undefined')?params.collection:sprites
		 	 
		 var Self = collection[idx]
		  
		 // SPAWN AT SPAWNER's COORDINATES
		 var Location = {
			 x:parseInt(Self.x),
			 y:parseInt(Self.y),	
		 }
		 
		 spawnEntityFromJson( params.name, Location )
		 
		 
		 console.log(params)
		 console.log(Location)
		 
		 return 'ENTITY ADDED TO STAGE'
	 }}
 ],
 /*
	GAME ANIMATION SPEED
 */
 stageNthFrame = 0,// current frame, aka how many frames passed since the beginning of the stage
 /* 
	LIMIT THE GAME LOOP SPEED (fpsLimit) -- begin 
	fpsLimit = frame per second limit
	should not be higher that the device screen refresh rate
	ex: 60hz on desktop monitor
		120hz on oneplus 8 pro
 */
 updateId,
 previousDelta = 0,
 fpsLimit = 60,
 
 /* LIMIT THE GAME LOOP SPEED (fpsLimit) -- end*/
 /*
	WHEN TO SPAWN ENTITIES
 */
 timeUnit = 0, // incremented every N milliseconds, entity cannons spawn entities at speific timeUnit values 
 lastTime = 0,
 lastTimeArrow = 0,
 currentTimeArrow = 0, 
 
 // BRICKWALL VARS
 /*
	TOP LEFT POSITION OF THE BRICKWALL ON THE CANVAS
 */
 
 brickwall = {},// STAGE OBJECT
 brickOffsetTop = 100, 
 brickOffsetLeft = 0,
 
 bricks = [],
 brickRowCount = 10,// how many bricks in one row - horizontally
 brickColumnCount = 10,// how many bricks in one column - vertically
 brickWidth = 22.5,//9
 brickHeight = 20,//9 -> 9*9
 
 brickPadding = 0,// PADDING BETWEEN BRICKS

 bricksFillStyle = "rgba(0,80,254,0.2)",//transparent
 brickWallSkin = 'img',// brickwall brickes are tiled with spritesheet (image) | colored with 1 color (color)
 bricksTotal = 0, // how many bricks in the stage's brickwall
 
 // BRICKS FADING AWAY VARS
 brickObjects = [],
  
 tileWidth = 22.5,
 tileHeight = 20,
 mapRows = 10,
 mapColumns = 10,
 sourceWidth = 225,
 sourceHeight = 200, 
 
 // MUST BE SET JUST BEFORE THE LEVEL STARTS
 tiles = new Array(mapColumns * mapRows),

 
 /*
	if brickWallSkin = 'img', wallBrickMap entries match the spritesheet tiles indexes
	if brickWallSkin = 'color', wallBrickMap entries match the colors array indexes - NOT IMPLEMENTED YET
	-1 : no tile/color, it corresponds to an empty space(no brick)
 */
 wallBrickMap = [/*
			0,1,2,3,4,5,6,7,8,9,
			10,11,12,13,14,15,16,17,18,19,
			20,21,0,23,24,25,26,27,0,29,
			30,31,32,33,34,35,36,37,38,39,
			40,41,42,43,-1,-1,46,47,48,49,
			50,51,52,53,-1,-1,56,57,58,59,
			60,61,62,63,64,65,66,67,68,69,
			70,71,72,73,74,75,76,77,78,79,
			80,81,0,83,84,85,86,87,88,89,
			90,91,92,93,94,95,0,97,98,99*/],
  // HOW MANY TIMES EACH BRICK MUST BE HIT TO DISAPPEAR	
  /*
	0 : disappears immediately after one collision
    'I' : undestructible
  */
  wallBrickMapEnergy = [/*
					1,1,1,1,1,1,1,1,1,1,
					"I",1,1,1,1,1,1,1,1,
					"I",1,1,1,1,1,1,1,1,"I",
					"I",1,1,1,1,1,1,1,1,"I",
					"I",1,1,1,0,0,1,1,1,"I",
					"I",1,1,1,0,0,1,1,1,"I",
					"I",1,1,1,1,1,1,1,1,"I",
					"I",1,1,1,1,1,1,1,1,"I",
					"I",1,1,1,1,1,1,1,1,"I",
					"I","I","I","I","I","I","I","I","I","I"					
					*/],
wallBrickMapEnergyInitial = [], // USED TO STORE INITIAL EACH BRICK ENERGY LEVEL AT THE BEGINNING OF A STAGE					
			
bricksTotal = 0, // how many bricks in the stage

// The main game loop
lastTime,

img,
cracks,
wallbrick_img,
background_img,

spriteFrames = [],// GLOBAL COLLECTION OF spriteFrames
entities = [],

energyObjects = [], // DISPLAY sprites energy points gained or lost 

spawnBalls = ['ball.entity'], // when this entity dies a lives--, spawnAball()
			 

brickwalls = [],// GLOBAL COLLECTION OF brickwalls
path = [],// GLOBAL COLLECTION OF paths
stages = [],
stage = {},
stageEnded = false

/*
	ELECTRIC ARCS -- begin
*/
// Getting the canvas and its context
	var can = document.getElementById('electricArc');
	if(can == null){
		//alert('Could not find canvas.');
	}
	
	var ctx = can.getContext('2d');
	
	// Some variables for the animation
	var animationId;
	var animated = false;
	var rotation = 0;
	var effectsPerTouch = 3;
	var touches = [];
	var maxLength = Math.sqrt(can.width*can.width + can.height*can.height);
	var lastFrame;
	var rotationSpeed = Math.PI / 2; // 90 degrees per second
	
	// Since the colors will always be the same, let's just set them once for all
	// We don't need to reset them at each frame.
	
	// Setting electricity color
	ctx.lineWidth = 3;
	ctx.strokeStyle = '#ffff00';//'#bbc2ff'; blue
	ctx.shadowColor = '#ffffff';//'#ffffff';
	ctx.shadowBlur = 10;
	
	// Background color
	ctx.fillStyle = '';//rgba(1,1,1,0.2)
/*
	ELECTRIC ARCS -- end
*/

/*
	END OF STAGE STARS
*/
window.sClasses = 
 [
  {
    'sClass': 's1',
    'location': 'starx1',
    'sprite': 'UI-stage-left-star'
	},
  {
    'sClass': 's2',
    'location': 'starx2',
    'sprite': 'UI-stage-middle-star'
	},
  {
    'sClass': 's3',
    'location': 'starx3',
    'sprite': 'UI-stage-right-star'
	}
],
starsIdx = 0,
sClass = {},
totalStars = 0


function app_wrapper(){

	//
	// MISC UTILITY FUNCTIONS -- begin
	//
	
	
	//
	//	getRandomArbitrary(min, max)
	//	PARAMS:
	//		min (required)		
	//		max (required)		
	//
	 function getRandomArbitrary(min, max) {
		return Math.random() * (max - min) + min;
	}

	//
	//	getRandomInt(max)
	//	PARAMS:
	//		max (required)		
	//
	function getRandomInt(max) {
	  return Math.floor(Math.random() * Math.floor(max));
	}
	
	
	window.randomizeHomeScreenAngel = function(){
		let el = document.querySelector('#homeAngel')
		el.classList.remove('archer','archangel','boxer')
		let rnd = getRandomInt(3)
		let chr = ['archer','archangel','boxer']
		el.classList.add(chr[rnd])
		//alert(rnd)
	}

	
	

	//
	//
	//   PATHS -BEGIN
	//
	//		
	function createPaths(){
	 
		//
		//    CREATION OF PATHS
		//    can be created programmatically OR hard-coded:
		//    e.g.: path[0] = [ [-225,0], [-224,0], [-223,0],... ]    
		//
		// PATH CREATED PROGRAMMATICALLY
		path[0] = []// always declare 1 path before using it
		path[0]['name'] = 'abs-left-right'
				
		var idx = 0,// the indice of currently iterated path
			px = canvas.width*-1,
			py = 0 	

		while ( px < canvas.width ){
			path[0][idx] = [px,py]
			idx++
			px += 10
		}
		
		
		// 2ND PATH CREATED PROGRAMMATICALLY
		path[1] = []// always declare 1 path before using it
		path[1]['name'] = 'abs-left-right-bis'
				
		var idx = 0,// the indice of currently iterated path
			px = 0,
			py = canvas.height*-1 	

		while ( py < canvas.width ){
			path[1][idx] = [px,py]
			idx++
			py += 10
		}
		
		
		// PATH HARD-CODED
		path[2] = []
				
		path[2].push(
				[1,0],
				[0,1],
				[0,1],
				[1,-1],
				[1,-1],
				[1,0],
				[0,1],
				[0,1],
				[1,-1],
				[1,-1],
				[-1,0],
				[0,1],
				[0,1],
				[-1,-1],
				[-1,-1],
				[-1,0],
				[0,1],
				[0,1],
				[-1,-1],
				[-1,-1]
			  )
		path[2].push({name:'rel-square-mountains'})
		
		path[3] = []		
		
		path[3] = [[14,43],[14,43],[15,44],[15,44],[16,46],[16,46],[18,48],[18,48],[19,50],[19,50],[20,51],[20,51],[22,54],[22,54],[23,55],[23,55],[25,57],[25,57],[26,58],[26,58],[28,59],[28,59],[29,61],[29,61],[30,62],[30,62],[32,63],[32,63],[33,64],[33,64],[35,66],[35,66],[37,67],[37,67],[39,67],[39,67],[41,69],[41,69],[44,71],[44,71],[47,72],[47,72],[50,73],[50,73],[53,74],[53,74],[56,75],[56,75],[59,75],[59,75],[63,75],[63,75],[66,75],[66,75],[73,75],[73,75],[77,75],[77,75],[80,75],[80,75],[83,75],[83,75],[85,75],[85,75],[86,74],[86,74],[88,73],[88,73],[88,72],[88,72],[88,72],[88,72],[88,71],[88,71],[88,70],[88,70],[88,67],[88,67],[88,66],[88,66],[88,66],[88,66],[87,64],[87,64],[86,63],[86,63],[84,62],[84,62],[83,61],[83,61],[82,61],[82,61],[81,61],[81,61],[80,61],[80,61],[78,61],[78,61],[76,61],[76,61],[75,61],[75,61],[73,61],[73,61],[72,61],[72,61],[71,61],[71,61],[70,62],[70,62],[69,62],[69,62],[68,63],[68,63],[68,64],[68,64],[67,65],[67,65],[65,67],[65,67],[65,68],[65,68],[65,71],[65,71],[64,71],[64,71],[64,74],[64,74],[64,75],[64,75],[64,77],[64,77],[64,80],[64,80],[65,82],[65,82],[67,84],[67,84],[69,87],[69,87],[72,91],[72,91],[74,91],[74,91],[78,94],[78,94],[84,98],[84,98],[88,100],[88,100],[94,101],[94,101],[100,103],[100,103],[106,103],[106,103],[112,104],[112,104],[120,104],[120,104],[128,104],[128,104],[140,103],[140,103],[154,103],[154,103],[161,101],[161,101],[170,99],[170,99],[175,99],[175,99],[176,99],[176,99],[179,98],[179,98],[180,98],[180,98]]
		path[3]['name'] = 'abs-longest-sofar'	
	}	
	//
	//
	//   PATHS -END
	//
	//

	
	//
	// MISC UTILITY FUNCTIONS -- end
	//
	
	
	function screenSize(){
		var innerWidth = window.innerWidth,//424px
			innerHeight = window.innerHeight,//731px
			clientWidth = window.clientWidth,// undefined
			clientHeight = window.clientHeight,// undefined
			outerWidth = window.outerWidth,// same as inner width
			outerHeight = window.outerHeight// same as inner height
			
		var str = 'innerWidth:'+innerWidth
				 +'\r\n innerHeight:'+innerHeight
				 +'\r\n outerWidth:'+outerWidth
				 +'\r\n outerHeight:'+outerHeight				 
			
		//////////////alert(str)
	}
	
 	/*
		SHAKE CANVAS horizontally
		PARAMS: 
				canvasId -- required
		adds the css class .shake to canvas#anvasId
		.shake removed in main()		
	*/	
	function shakeCanvas(canvasId){
	  document.getElementById(canvasId).classList = 'shakingH'
	  document.getElementById(canvasId).setAttribute('shakingH',timeUnit)
	  //////////////alert(document.getElementById(canvasId).getAttribute('shakingH'))
	  //////////////alert(canvasId)
	}

	
		function centerStageCanvases(){
			for (var n = 0; n < canvases.length; n++){
				var canvasID = canvases[n].name
				/*document.getElementById(canvasID).style.left = 
				parseInt( document.getElementById('UI').style.left)
				+'px'*/


			document.getElementById(canvasID).style.left = 
			  parseInt(window.innerWidth/2)
			- parseInt(document.getElementById(canvasID).width/2)+ 'px'
			}
		}
	 
	  window.initGlobals2 = function(){
		  window.totalPromises = 0
		  window.solvedPromises = 0			  
		  
		/* 
			INJECT STAGES CANVASES TO DOM -- WILL BE CHANGED
			IT 'D BETTER BE USED BEFORE EACH STAGE
			INJECT ALL CANVASES THEN REMOVE THE ONE(S) THAT 
			ARE NOT INCLUDED IN SCROLLINGS AND OR ENTITIES' drawOnCanvas
			EXCEPT 'combo' and 'comboStar'
		*/	
		injectCanvasesToDOM()
		
		/* 
			POPULATE selectedWeapons[]
			AT LEAST ONE 
			IN CASE THE PLAYER DOES NOT USE INVENTORY NOR ANGEL UI
		*/		
		//selectedWeaponsPopulate()
		
		
		// CENTER CANVASES RELATIVELY TO window
		centerStageCanvases()
		
		// POSITION PLAYER UI CANVAS
		document.getElementById('UI').style.top = 0;
		document.getElementById('UI').style.left = parseInt(window.innerWidth/2)+'px';
		document.getElementById('UI').style.marginLeft = -1 * parseInt(document.getElementById('UI').width/2)+'px';
		
		// LOAD CRACKS -- will be changed
		cracks = new Image();
		cracks.onload = function(){				
		}
		cracks.src = './game_assets/images/cracks.png';
		
		/*
			RESET COLLECTION CONTAINERS
		*/		
		promises = []
		sprites = []
		entities = []
		brickwalls = []
		path = []
		stages = []
		sounds = []

	// LOAD GAME ASSETS --begin
	load( campaign ,function(response){			
		var jsonObj = JSON.parse(response)			
				JSON.stringify(jsonObj) 
	/*
	  sounds = jsonObj.sounds
	  entities = jsonObj.entities
	  brickwalls = jsonObj.brickwalls
	  stages = jsonObj.stages
	  paths = jsonObj.paths   
	*/
	  // LOAD SPRITES
	  spriteFrames = []  
	  let alreadyLoaded = []
	  
		Array.prototype.some.call( jsonObj.sprites, function(sprite, idx){
			   // LOAD SPRITE			   
			   var fileName = jsonObj.sprites[idx]+'.json'
			   
			   if( alreadyLoaded.includes(fileName) === true ){
					return 
			   }			   
			   alreadyLoaded.push(fileName)
			   load(jsonObj.sprites[idx]+'.json',function(response){			
					var jsonItem = JSON.parse(response)					
					createSpriteFromJson( jsonItem )
			   })
		})
  
	  // LOAD ENTITIES
	  entities = []
	  //alreadyLoaded = []
		Array.prototype.some.call( jsonObj.entities, function(entity, idx){
			
		  var fileName = jsonObj.entities[idx]+'.json'			
		   if( alreadyLoaded.includes(fileName) === true ){
				return 
		   }	   
		  alreadyLoaded.push(fileName)			
		   // LOAD ENTITY
				load(fileName, function(response){			
					var jsonItem = JSON.parse(response)			
					createEntityFromJson( jsonItem )
				})
		})
		   
		  // LOAD PATHS
		  path = []
		  loadPathsFromJson( jsonObj.paths ) 

		  // LOAD BRICKWALLS 
		  brickwalls = []
		  loadBrickWallsFromJson( jsonObj.brickwalls )
		  
		  // LOAD STAGES 
		  stages = []
		  
		  /*loadStagesFromJson( jsonObj.stages )*/

			/*
			REGISTER SOUNDS:
				SO FAR ONLY BGM
			*/
			//registerSounds( jsonObj.sounds )
			
			/*
				SOUNDS SPRITES FOR LATER
			*/
			/*sounds = new Howl({
			  src: ['ArrowSwoosh.mp3'],
			  sprite: {
				arrowSwoosh: [0, 1000]
			  }
			})	
			sounds.once('load', function(){
			  sounds.play('arrowSwoosh');
			});
			
			*/
		
		/*
			REGISTER SOUNDS -- begin
		*/
			/*sounds = []
			sounds[0] = new Howl({
			  src: ['angelShoutPunch.mp3']
			})
			
			sounds[1] = new Howl({
			  src: ['ArrowSwoosh.mp3']
			})
			
			sounds[2] = new Howl({
			  src: ['bounce1.mp3']
			})
			
			sounds[3] = new Howl({
			  src: ['bounce2.mp3']
			})
			
			sounds[4] = new Howl({
			  src: ['tik.mp3']
			})
			
			// PUNCH 		
			sounds[5] = new Howl({
			  src: ['punchAMinor.mp3']
			})
			
			// PUNCH 2		
			sounds[6] = new Howl({
			  src: ['cartoonPunchWhack.mp3']
			})
			
			// GOT A STAR		
			sounds[7] = new Howl({
			  src: ['gotStar.mp3']
			})
			
			// OUCH KID		
			sounds[8] = new Howl({
			  src: ['kid_ouch.mp3']
			})
			
			// TELEPORTATION
			sounds[9] = new Howl({
			  src: ['angel-choirs2s.mp3']
			})
			
			// REGISTER MENU MUSIC
			//var src = 'bgm_11_heavenly-music-loop.mp3'
			//registerSound(src)
		/*
			REGISTER SOUNDS -- end
		*/	
	   
	    
		
		/*
			WAIT FOR ALL ASSETS TO FINISH LOADING
		*/		
		Promise.all(promises).then( function( values ) {
			 ////console.clear()
			  console.log(values);
			  console.log('spriteFrames:'+spriteFrames.length)	   
			  console.log('entities:'+entities.length)
			  console.log('brickwalls:'+brickwalls.length)
			  console.log('stages:'+stages.length) 
			  console.log('sounds:'+sounds.length) 
			  console.log('paths:'+path.length) 
			  console.log('all assets loaded!')
			  
			// HIDE START SCREEN
			 document.querySelector('#app').setAttribute('style', 'display:none;');   
			
			
			
			// DISPLAY HOME SCREEN PAGE ONLY
			selectPage('homeScreen')
			
			/*
				IF THERE IS A PROFILE
					LOAD THE PROFILE
						GO TO STAGE SELECT
				ELSE
					CHARACTER SELECT
							CREATE PROFILE
						CAMPAIGN SELECT
							UPDATE PROFILE
						GO TO STAGE SELECT
			*/
			db.character.count()
			.then( (countChar)=>{
			  
			  	if( countChar > 0 ){
				/*
					CHARACTER EXISTS
						LOAD CHARACTER
							GO TO STAGE SELECTION
				*/				
					//selectPage('stageSelection')
					
				}else{
				/* 
					NO CHARACTER EXISTS
						 SELECT CHARACTER						
							GO TO STAGE SELECT
				*/
				
					generateCharacterSelectUI()
					
					document.location.href = '#charLi0'// fix for scroll in character selection screen
					
					selectPage('characterSelection')
					console.log('THERE IS NO CHARACTER !')
					// DISPLAY HOME SCREEN CHARACTER SELECTION PAGE				
				
				}
			  
			})

			  /*
				CREATE LIST OF STAGE SELECTION BUTTONS -- begin
				DISPLAY HOME SCREEN PAGE
			  */
			  //stagesList = jsonObj.stages	
			  
			  /*
			  // SORT stages TO GET THEM ALWAYS IN THE SAME ORDER
			  stagesList = jsonObj.stages.sort((a, b) => (a.name < b.name) ? 1 : -1)
			  console.log(JSON.stringify(stagesList))			  
			  //createStageList2(stagesList)			  
			  createStageList3(stagesList)
			  *///console.clear()
			  console.log(stagesList)
			  stagesList = jsonObj.stages.sort((a, b) => (a.name < b.name) ? 1 : -1)
			  
			  console.log(stagesList)
			  createStageList4()
			  
			  initSounds(jsonObj.sounds)
			
		}); // Promise.all(promises).then(function(values) {
		
	})
	// LOAD GAME ASSETS --end
		
	
		
		/*	
			INIT GAMEKEYS
		
			INGAME KEYS:
			
				SPACE - pause
				
				F - use first slot item
				G - use second slot item
				H - use third slot item
				
				UP, RIGHT, DOWN, LEFT - move
		
		*/
		
		/*
			IF THE DETECTED PLATFORM IS A BROWSER
			WE  SUPPOSE IT IS ON A DESKTOP
			THEN WE CAPTURE THE KEY STROKES
		*/
		if( window.platform == 'browser' ){
		
			/*
				SPACE, F, G, H
			*/		
			keyPressEventsInit(); // INIT KEYPRESS EVENTS (PC)	 
			
			/*
				UP, RIGHT, DOWN, LEFT
			*/
			keyDownEventsInit();  // INIT KEYDOWN EVENTS (PC)
		}
		
		
	 }// end initGlobals2()


function initCharacterSelect(){
	// HIDE START SCREEN
	document.querySelector('#app').setAttribute('style', 'display:none;');   
		
		
	// DISPLAY HOME SCREEN PAGE ONLY
	selectPage('homeScreen')
	
	/*
		IF THERE IS A PROFILE
			LOAD THE PROFILE
				GO TO STAGE SELECT
		ELSE
			CHARACTER SELECT
					CREATE PROFILE
				CAMPAIGN SELECT
					UPDATE PROFILE
				GO TO STAGE SELECT
	*/
	db.character.count()
	.then( (countChar)=>{
	  
		if( countChar > 0 ){
		/*
			CHARACTER EXISTS
				LOAD CHARACTER
					GO TO STAGE SELECTION
		*/				
			//selectPage('stageSelection')
			
		}else{
		/* 
			NO CHARACTER EXISTS
				 SELECT CHARACTER						
					GO TO STAGE SELECT
		*/
			// CREATE CHARACTER SELECT MENU
			generateCharacterSelectUI()
				
				document.location.href = '#charLi0'// fix for scroll in character selection screen
			
			// DISPLAY HOME SCREEN CHARACTER SELECTION PAGE
			selectPage('characterSelection')
			console.log('THERE IS NO CHARACTER !')
		}
	  
	})
}

function initStageMenuCreation(){
	/*
		CREATE LIST OF STAGE SELECTION BUTTONS -- begin
		DISPLAY HOME SCREEN PAGE
	*/		
	
	
	  ////console.clear()
	  //console.log('stagesList: '+stagesList)
	  //stagesList = jsonObj.stages.sort((a, b) => (a.name < b.name) ? 1 : -1)
	  
	  //console.log(stagesList)
	
	/*
	  // SORT stages TO GET THEM ALWAYS IN THE SAME ORDER
	  var stagesList2 = stagesList.sort((a, b) => (a.name < b.name) ? 1 : -1)
		  stagesList = stagesList2
     */
	  // GENERATE STAGES SELECTION MENU
	  createStageList4()
	/*
		CREATE LIST OF STAGE SELECTION BUTTONS -- end				
	*/	
}


function registerSoundFx(){
	/*
		REGISTER SOUNDS -- begin
	*/
		soundsToLoad = [
			'angelShoutPunch.mp3',
			'ArrowSwoosh.mp3',
			'bounce1.mp3',
			'bounce2.mp3',
			'tik.mp3',
			'punchAMinor.mp3',
			'cartoonPunchWhack.mp3',
			'gotStar.mp3',
			'kid_ouch.mp3',
			'angel-choirs2s.mp3',
			'male-thank-you-very-much-1.mp3',
			'male-thank-you-very-much-2.mp3',
			'female-thank-you-very-much-1.mp3',
			'female-thank-you-very-much-2.mp3'
		]
					
		soundsToLoad.some( function(sound, idx){
			sounds[idx] = new Howl({
			  src: [sound],
			  volume: 0.5,
			  onplay: function() {
				// SOUND IS REGISTERED A PLAYING
				// IT IS NOT AVAILABLE TO BE PLAYED AGAIN 
				soundsPlaying.push(sound)
			  },
			  onend: function() {
				//console.log('Finished!');
				// SOUND IS REMOVED FROM THE SOUNDS BEING PLAYED
				// IT IS NOW AVAILABLE TO BE PLAYED AGAIN
				removeItemOnce(soundsPlaying, sound)
			  }
			  
			})					
		})
				
		// REGISTER MENU MUSIC
		//var src = 'bgm_11_heavenly-music-loop.mp3'
		//registerSound(src)
	/*
		REGISTER SOUNDS -- end
	*/

}


function removeItemOnce(arr, value) {
  var index = arr.indexOf(value);
  if (index > -1) {
    arr.splice(index, 1);
	//////alert('THAT IS THE ONE '+1887)	
  }
  return arr;
}

function createPathFromJson(jsonObj){

	//var jsonObj = JSON.parse(json)			
	/*
		RECREATE the json object:
			- path_name needs to become name for use of func 'search'
			- jsonObj.path_coords is saved width "" around, get rid of that
	*/
	var unstrigifiedJsonObj = {
		name: jsonObj.path_name,
		path_coords: JSON.parse(jsonObj.path_coords),
		pathMode: jsonObj.pathMode
		
	}
				
	path[path.length] = unstrigifiedJsonObj
}

function createBrickWallFromJson(jsonObj){
	/*
		RECREATE the json object:
			- path_name needs to become name for use of func 'search'
			- jsonObj.wallBrickMap is saved width "" around, get rid of that
	*/
	var unstrigifiedJsonObj = {
		name: jsonObj.brickwall_name,
		wallBrickMap: JSON.parse(jsonObj.wallBrickMap),				
		wallBrickMapEnergy: JSON.parse(jsonObj.wallBrickMapEnergy),
		brickWidth: jsonObj.brickWidth,
		brickHeight: jsonObj.brickHeight,
		brickRowCount: jsonObj.brickRowCount,
		brickColumnCount: jsonObj.brickColumnCount,
		brickPadding: jsonObj.brickPadding,
		bricksFillStyle: jsonObj.bricksFillStyle,
		brickWallSkin: jsonObj.brickWallSkin,
		bricksEqualTiles: jsonObj.bricksEqualTiles,
		brickWallImage: jsonObj.brickWallImage,
		tileWidth: jsonObj.tileWidth,
		tileHeight: jsonObj.tileHeight,
		mapRows: jsonObj.mapRows,
		mapColumns: jsonObj.mapColumns,
		sourceWidth: jsonObj.sourceWidth,
		sourceHeight: jsonObj.sourceHeight
	}	
	brickwalls[brickwalls.length] = unstrigifiedJsonObj
}


function createSoundFromJson(jsonObj){
	//var sound0 = "game_assets/sounds/"+jsonObj+".mp3"			
	var sound0 = "game_assets/sounds/"+jsonObj.name+".mp3"			
	registerSound(sound0)
}

function populateAssetsTable(cExpF){
 /*
	 var campaign = 'shortCmp.cmp.json'
	 var campaign = 'myFirstCampaign.cmp.json'
 */
 var logStr = ''// log will display all imports
 var ext = '.json'
 var fileName = cExpF + ext
 var collections = ['stages','sprites','brickwalls','entities','paths','sounds']
  
 load( fileName, function(response){			
           
    var jsonObjParsed = JSON.parse(response)            

    // TRUNCATE TABLE 'assets'
    db.assets.clear()
		
	var t = 0;
    var parameters = []
	jsonObjParsed.some(function(obj, idx){
	    //if( obj.collection == 'sounds' ){ext = '.mp3'}    
         var params = 
            {
                name: obj.name,// e.g.: 'stage5.stg'
                object: obj.object, // e.g.:{name:'xxx',...}
                description: obj.description,// e.g: 'Save the granny from the monsters!'
                collection: obj.collection, // e.g: 'stages'
                campaignName: campaign// campaignName.cmp.json
            }

        parameters.push(params)
        var log = '['+obj.collection+']: '+obj.name+' | '+obj.description +' \r\n'
            logStr += log
               			
		/* POPULATE COLLECTIONS ARRAYS -- begin	*/
			var jsonItem = obj.object
			addItemToCollectionFromJsonItem(obj.collection, jsonItem)
		/* POPULATE COLLECTIONS ARRAYS -- end */
       
    }) // collections.some(function(selectedCollection)
	
	/*
		DEXIE: start transactions
	*/
	spawn(function* (){
		
		yield db.assets.bulkAdd(parameters)
		.then(function(lastKey){						
			console.log(lastKey+' imported assets')               
			if(lastKey >= jsonObjParsed.length){
				console.log('All assets imported!')
				
				//preloadAllImages()
				
				initCharacterSelect()
				initStageMenuCreation()
			}
		})// then

	})// spawn
	/*
		DEXIE: end transactions
	*/ 
	
    console.log(logStr)

 })// load
 
}// populateAssetsTable()




window.refreshLayout = function(){
	/* 
			INJECT STAGES CANVASES TO DOM -- WILL BE CHANGED
			IT 'D BETTER BE USED BEFORE EACH STAGE
			INJECT ALL CANVASES THEN REMOVE THE ONE(S) THAT 
			ARE NOT INCLUDED IN SCROLLINGS AND OR ENTITIES' drawOnCanvas
			EXCEPT 'combo' and 'comboStar'
		*/	
	injectCanvasesToDOM()
	// CENTER CANVASES RELATIVELY TO window
		centerStageCanvases()
		
		// POSITION PLAYER UI CANVAS
		document.getElementById('UI').style.top = 0;
		document.getElementById('UI').style.left = parseInt(window.innerWidth/2)+'px';
		document.getElementById('UI').style.marginLeft = -1 * parseInt(document.getElementById('UI').width/2)+'px';
		
		//alert('window resised !')
		
}

window.addEventListener('resize',refreshLayout)

window.initGlobals3 = function(){
	
		  window.totalPromises = 0
		  window.solvedPromises = 0			  
		  window.uiBtnsClickable = true

		  randomizeHomeScreenAngel()
		 
		/* 
			INJECT STAGES CANVASES TO DOM -- WILL BE CHANGED
			IT 'D BETTER BE USED BEFORE EACH STAGE
			INJECT ALL CANVASES THEN REMOVE THE ONE(S) THAT 
			ARE NOT INCLUDED IN SCROLLINGS AND OR ENTITIES' drawOnCanvas
			EXCEPT 'combo' and 'comboStar'
		*/	
		injectCanvasesToDOM()
		
		/* 
			POPULATE selectedWeapons[]
			AT LEAST ONE 
			IN CASE THE PLAYER DOES NOT USE INVENTORY NOR ANGEL UI
		*/		
		selectedWeaponsPopulate('hide')
		//generateWeaponsSelectUI('hide')
		
				
		// CENTER CANVASES RELATIVELY TO window
		centerStageCanvases()
		
		// POSITION PLAYER UI CANVAS
		document.getElementById('UI').style.top = 0;
		document.getElementById('UI').style.left = parseInt(window.innerWidth/2)+'px';
		document.getElementById('UI').style.marginLeft = -1 * parseInt(document.getElementById('UI').width/2)+'px';
		
		// LOAD CRACKS -- will be removed or replaced
		cracks = new Image();
		cracks.onload = function(){				
		}
		cracks.src = './game_assets/images/cracks.png';
		
		/*
			RESET COLLECTION ARRAYS
		*/
		sprites = []
		entities = []
		brickwalls = []
		path = []
		stages = []
		sounds = []
	    spriteFrames = []		
		
		/*	REGISTER SOUNDS THAT WILL NOT BE POPULATED FROM JSON -- begin */
		 sounds = []
		 registerSoundFx()
		/*	REGISTER SOUNDS THAT WILL NOT BE POPULATED FROM JSON -- end */
		
		/*
			get campaign (campaignName.cmp.json)
			change it to campaignName.exp
			
			populateAssetsTable(fileNameArray[0] + ".exp")
			load campaignName.exp.json
				populate dexie: 'assets' with entries  

		*/
		
		
		
		preloadAllImages()
		
		//loadAssets()
		
		
		
	 }// end initGlobals3()



	function loadAssets(){
		/* COUNT ASSETS OF CAMPAIGN campaign */
		spawn(function* (){
		
		var countAssets = 
			yield db.assets
			.where('campaignName')
			.equals(campaign)
			.count()
			
			console.log(countAssets)
			
			if( countAssets == 0 ){
				var fileNameArray = campaign.split('.')// campaignName.cmp.json
				var campaignExpFile = fileNameArray[0] + ".exp"//campaignName
				
				populateAssetsTable(campaignExpFile)//fileNameArray[0] + ".exp"    
			}		
			else
			{
				populateAssetsCollectionsFromDexieAssets()					
			}
			
		})// spawn
		/*	
			INIT GAME KEYS		
			INGAME KEYS:			
				SPACE - pause				
				F - use first slot item
				G - use second slot item
				H - use third slot item				
				UP, RIGHT, DOWN, LEFT - move		
		*/		
		/*
			SPACE, F, G, H
		*/		
		keyPressEventsInit(); // INIT KEYPRESS EVENTS (PC)
		/*
			UP, RIGHT, DOWN, LEFT
		*/
		keyDownEventsInit();  // INIT KEYDOWN EVENTS (PC)
		
		
	}


	
	function populateAssetsCollectionsFromDexieAssets(){
	
	/*
		POPULATE ASSET COLLECTION ARRAYS FROM Dexie db.assets table -- begin
	*/
	spawn(function* (){       
	   var assets = yield db.assets
			 .where('campaignName')
			 .equals(campaign)
			 .toArray()
		   assets.some( function(obj, idx){			   
			/* POPULATE COLLECTIONS ARRAYS -- begin	*/
			var jsonItem = obj.object
			addItemToCollectionFromJsonItem(obj.collection, jsonItem)
			/* POPULATE COLLECTIONS ARRAYS -- end */
		   }) // collections.some(function(selectedCollection) 
		   
		   // HIDE START SCREEN
		  document.querySelector('#app').setAttribute('style', 'display:none;');   
		  
		  //preloadAllImages()
		  
		   //createStageList4()
		   initStageMenuCreation()
		   //selectPage('stageSelection')
		   
		  
		   
		   selectPage('homeScreen')
		   
	})// spawn
	/*
		POPULATE ASSET COLLECTION ARRAYS FROM Dexie db.assets table -- end
	*/
	}
	
	
	window.addItemToCollectionFromJsonItem = function(collection, jsonItem){           
		/*
			POPULATE COLLECTIONS ARRAYS -- begin
		*/
		switch(collection){
			case 'sprites':
				createSpriteFromJson( jsonItem )
			break;
			case 'entities':
				createEntityFromJson( jsonItem )
			break;
			case 'paths':
				createPathFromJson( jsonItem )
			break;
			case 'brickwalls':
				createBrickWallFromJson( jsonItem )
			break;
			case 'stages':
				stagesList.push( jsonItem )				
			break;
			case 'sounds':
				createSoundFromJson( jsonItem )				
			break;
		}
		/*
			POPULATE COLLECTIONS ARRAYS -- end
		*/
	}

	  window.initSounds = function (soundsList){
		  
		  
			/*
				SOUNDS SPRITES FOR LATER
			*/
			/*sounds = new Howl({
			  src: ['ArrowSwoosh.mp3'],
			  sprite: {
				arrowSwoosh: [0, 1000]
			  }
			})	
			sounds.once('load', function(){
			  sounds.play('arrowSwoosh');
			});
			
			*/
		
		/*
			REGISTER SOUNDS -- begin
		*/
			sounds = [],
			soundsToLoad = [
				'angelShoutPunch.mp3',
				'ArrowSwoosh.mp3',
				'bounce1.mp3',
				'bounce2.mp3',
				'tik.mp3',
				'punchAMinor.mp3',
				'cartoonPunchWhack.mp3',
				'gotStar.mp3',
				'kid_ouch.mp3',
				'angel-choirs2s.mp3'/*,
				'heavenly_music-loop.mp3'// UI ambient BGM*/
			]
					
			soundsToLoad.some( function(sound, idx){
				sounds[idx] = new Howl({
				  src: [sound]
				})					
			})
			
			/*
			REGISTER SOUNDS:
				SO FAR ONLY BGM
		  */
			registerSounds( soundsList )
			
			
			// REGISTER MENU MUSIC
			//var src = 'bgm_11_heavenly-music-loop.mp3'
			//registerSound(src)
		/*
			REGISTER SOUNDS -- end
		*/	
		  
	  }




	

/*
	PRELOAD ALL PATHS FILES
	TO MAKE THEM ACCESSIBLE
	TO ENTITIES AND BRICKWALLS
*/
 window.loadPathsFromJson = function(){
	var n = 0;
	
	var path_json_files = [
		'path_vertical_corkscrew.json',
		'rigth-to-middle.json',
		'path_sharp_teeth.json',
		'v.abs.json',
		'complexe.abs.json',
		'doubleZ.rel.json',
		'anotherPastTest.path.rel.json'
	]
	
	if( arguments.length > 0 ){
		path_json_files = arguments[0]
	}
		
	if( path_json_files.length<1 ){ return }
				
	while (n <= path_json_files.length-1){
	
	if( arguments.length > 0 ){
		path_json_files[n] += '.json'
	}
		load(path_json_files[n],function(response){
			
			var jsonObj = JSON.parse(response)			
			/*
				RECREATE the json object:
					- path_name needs to become name for use of func 'search'
					- jsonObj.path_coords is saved width "" around, get rid of that
			*/
			var unstrigifiedJsonObj = {
				name: jsonObj.path_name,
				path_coords: JSON.parse(jsonObj.path_coords),
				pathMode: jsonObj.pathMode
				
			}
						
			path[path.length] = unstrigifiedJsonObj
			//////////////alert(JSON.stringify(path[path.length-1])) -- ok
			
		})
		n++
	}
}

/*
	ADD ALL BRICKWALLS TO brickwalls COLLECTION
	AND MAKE THEM ACCESSIBLE BY THEIR name ATTRIBUTE
*/
 window.loadBrickWallsFromJson = function(){
	var n = 0;	
	var BW_json_files = [
		'brickwalltest.json',
		'brickwalltestImage.json',
		'coloredTilesWallTest.json',
		'brickwalltestImageWB.json',
		'brickwalltestColors.json',
		'4x4x4x50-blue.brickwall.json',
		'brickwalltestColors.brickwall.json',
		'brickman.brickwall.json',
		'bwimgtest.brickwall.json',
		'redhead.brickwall.json',
		'fish2.brickwall.json'		
	]	
	
	if( arguments.length > 0 ){
		BW_json_files = arguments[0]
	}	
	
	if( BW_json_files.length < 1 ){ return }				
	
	console.log('BW_json_files: '+BW_json_files.length)
	console.log('BW_json_files: '+BW_json_files)
	
	 Array.prototype.some.call(BW_json_files, function (jsonFile, idx){
				
		//while (n <= BW_json_files.length-1){	
		if( arguments.length > 0 ){
			//jsonFile += '.json'
			BW_json_files[n] += '.json'
		}
		
			load(BW_json_files[n],function(response){			
				var jsonObj = JSON.parse(response)
				
				/*
					RECREATE the json object:
						- path_name needs to become name for use of func 'search'
						- jsonObj.wallBrickMap is saved width "" around, get rid of that
				*/
				var unstrigifiedJsonObj = {
					name: jsonObj.brickwall_name,
					wallBrickMap: JSON.parse(jsonObj.wallBrickMap),				
					wallBrickMapEnergy: JSON.parse(jsonObj.wallBrickMapEnergy),
					brickWidth: jsonObj.brickWidth,
					brickHeight: jsonObj.brickHeight,
					brickRowCount: jsonObj.brickRowCount,
					brickColumnCount: jsonObj.brickColumnCount,
					brickPadding: jsonObj.brickPadding,
					bricksFillStyle: jsonObj.bricksFillStyle,
					brickWallSkin: jsonObj.brickWallSkin,
					bricksEqualTiles: jsonObj.bricksEqualTiles,
					brickWallImage: jsonObj.brickWallImage,
					tileWidth: jsonObj.tileWidth,
					tileHeight: jsonObj.tileHeight,
					mapRows: jsonObj.mapRows,
					mapColumns: jsonObj.mapColumns,
					sourceWidth: jsonObj.sourceWidth,
					sourceHeight: jsonObj.sourceHeight
				}	
				brickwalls[brickwalls.length] = unstrigifiedJsonObj
			})
			n++
		}
	) //Array.prototype.some.call(BW_json_files, function (jsonFile){
	
}




/*
	function loadStageBrickWall( brickWallName )
	DOES: 
			LOAD, INIT, & GENERATE THE BRICKWALL WITH ATTRIBUTE name == brickWallName
	PARAMS: 
			brickWallName  - string -- required
	
	example: loadStageBrickWall('brickwalltestColors')

	NOTE : GLOBAL OBJECT brickwall{} IS PARTIALLY POPULATED HERE, 
			AND IN FUNCTION loadStageFromStages()
			i.e.: drawnCanvas
	
*/
function loadStageBrickWall( brickWallName ){
	var brickWallObject = search(brickWallName, brickwalls);		
	
	console.log(brickWallName)
	console.log(brickWallObject+'\r\n'+brickWallObject)
	
	brickwall.drawOnCanvas = ( brickwall.drawOnCanvas !== undefined)?brickwall.drawOnCanvas:canvases[0].name
	
	brickwall.brickHeight = brickWallObject.brickHeight
	brickwall.brickWidth = brickWallObject.brickWidth
	brickwall.tileHeight = brickWallObject.tileHeight
	brickwall.tileWidth = brickWallObject.tileWidth
		
	// WALLBRICK PARAMS
	brickRowCount = Number(brickWallObject.brickRowCount)
	brickColumnCount = Number(brickWallObject.brickColumnCount)
	brickWidth = Number(brickWallObject.brickWidth)
	brickHeight = Number(brickWallObject.brickHeight)
	
	brickPadding = Number(brickWallObject.brickPadding)
	bricksFillStyle = brickWallObject.bricksFillStyle
		
	brickWallSkin = brickWallObject.brickWallSkin
	tileWidth = Number(brickWallObject.tileWidth)
	tileHeight = Number(brickWallObject.tileHeight)
	mapRows = Number(brickWallObject.mapRows)
	mapColumns = Number(brickWallObject.mapColumns)
	sourceWidth = Number(brickWallObject.sourceWidth)
	sourceHeight = Number(brickWallObject.sourceHeight)
	
	wallBrickMap = [...brickWallObject.wallBrickMap]
	wallBrickMapEnergy = [...brickWallObject.wallBrickMapEnergy ]
			
	if( brickWallSkin == 'img' ){
		// SPRITESHEET (IMAGE) USED IF  brickWallSkin = 'img'
		img = new Image();
		img.onload = function(){
			//document.getElementById('canvas_main').style.background = "top center no-repeat url('"+img.src+"')"
			/*document.getElementById('canvas_main').style.top = 0;
			document.getElementById('canvas_main').style.left = 0;*/
		}
		img.src = brickWallObject.brickWallImage;
	}
	
	// RESET wallBrickMapEnergyInitial
	wallBrickMapEnergyInitial = [...wallBrickMapEnergy]
	
	// DRAW THE BRICKWALL
	drawBricks4(false);	
}




/*
	ADD ALL STAGES TO stages[] COLLECTION
	AND MAKE THEM ACCESSIBLE BY THEIR name ATTRIBUTE

window.loadStagesFromJson = function(){
	var n = 0;	
	var stage_json_files = [
		'myFirstStage.stg.json',
		'mySecondStage.stg.json',
		'myStage3.stg.json',
		'myFourthStage.stg.json',
		'myFifthStage.stg.json',
		'mySixthStage.stg.json'
	]

	if( arguments.length > 0 ){
		stage_json_files = arguments[0]
	}	
	
	if( stage_json_files.length<1 ){ return }

	while (n < stage_json_files.length){	
	
	if( arguments.length > 0 ){
		stage_json_files[n] += '.json'
	}
	
		load(stage_json_files[n],function(response){

			
			var jsonObj = JSON.parse(response)
			//var jsonObj = response
				console.log('response: \r\n'+JSON.stringify(response.scrollingScreens))
				console.log('jsonObj: \r\n'+JSON.stringify(jsonObj.scrollingScreens))
			
			if(jsonObj.description !== undefined){
				//////////alert(jsonObj.description)
			}
			
			var unstrigifiedJsonObj = {
				name: jsonObj.name,
				description: jsonObj.description,
				stage_entityCannons: jsonObj.stage_entityCannons,				
				music: jsonObj.music,				
				BW_drawOnCanvas: jsonObj.BW_drawOnCanvas,				
				stage_brickwall_name: jsonObj.stage_brickwall_name,
				BW_x: jsonObj.BW_x,
				BW_y: jsonObj.BW_y,
				BW_dx: jsonObj.BW_dx,
				BW_dy: jsonObj.BW_dy,
				BW_path: jsonObj.BW_path,
				BW_pathMode: jsonObj.BW_pathMode,
				BW_pathEnd: jsonObj.stage_BW_pathEnd,
				BW_pathStep: jsonObj.BW_pathStep,
				BW_pathIdx: jsonObj.BW_pathIdx,				
				BW_states: jsonObj.BW_states,
				BW_firstStateAt: jsonObj.BW_firstStateAt,
				scrollingScreens: jsonObj.scrollingScreens,				
				objectives: jsonObj.objectives						
			}
			stages.push( unstrigifiedJsonObj )
			//////////////alert('stages[stages.length]: \r\n'+stages[0])// ok
			
		})
		n++
		console.log(stages)
		
	}
	
}*/





window.UI_display_selected_stage = function(stageName){
	
	//stageLoadPromise = ''
	
	// INIT & INSTANCIATE SCROLLING			
	loadStageFromStages( stageName )
	.then(function(){		
		loadScrollings()
	})
}


//return new Promise(function(resolve, reject) { })


window.loadScrollings = function(){	
	scrollingScreens = stage.scrollingScreens
	if( typeof(stage.scrollingScreens) !== 'undefined' ){			
		scrollingScreens = stage.scrollingScreens
		if( scrollingScreens.length > 0 ){
			spawnScrollingScreens2()
			.then(function(){
				document.querySelector('#stageDetails').classList.add('UI-animation-down')
			})
		}
	}		
}


/*
	
	stageName,: e.g.: myFirstStage.stg
*/
window.loadStageFromJson = function( stageName ){
	
	console.log('LOADING '+stageName)
	
	var result = ''

	try{
		result = stages.find(t => t.name == stageName).name;
		console.log(result)
	}
	catch(error){
		// DO NOTHING
	}

	console.log(result)
		
	if( result != '' ){
		// IF STAGE IS ALREADY LOADED INTO stages[]
	    console.log('stage already loaded in stages[]')	
	    ////////////alert('stage already loaded in stages[]')	
		//start_game(stageName)
		UI_display_selected_stage(stageName)
	}
	else{
		var stageName0 = stageName+'.json';
		//stageName = stageName0
		
		// LOAD THE STAGE INTO stages[]
		//console.log('stage already not loaded in stages[] yet, loading ...')		
		
		totalPromises = []
		
		load(stageName0, function(response){			
				var jsonObj = JSON.parse(response)
				//var jsonObj = response
					console.log('response: \r\n'+JSON.stringify(response.scrollingScreens))
					console.log('jsonObj: \r\n'+JSON.stringify(jsonObj.scrollingScreens))
					
				var unstrigifiedJsonObj = {
					name: jsonObj.name,
					description: jsonObj.description,
					briefing: jsonObj.briefing,
					stage_entityCannons: jsonObj.stage_entityCannons,				
					music: jsonObj.music,				
					BW_drawOnCanvas: jsonObj.BW_drawOnCanvas,				
					stage_brickwall_name: jsonObj.stage_brickwall_name,
					BW_x: jsonObj.BW_x,
					BW_y: jsonObj.BW_y,
					BW_dx: jsonObj.BW_dx,
					BW_dy: jsonObj.BW_dy,
					BW_path: jsonObj.BW_path,
					BW_pathMode: jsonObj.BW_pathMode,
					BW_pathEnd: jsonObj.stage_BW_pathEnd,
					BW_pathStep: jsonObj.BW_pathStep,
					BW_pathIdx: jsonObj.BW_pathIdx,				
					BW_states: jsonObj.BW_states,
					BW_firstStateAt: jsonObj.BW_firstStateAt,
					scrollingScreens: jsonObj.scrollingScreens,				
					objectives: jsonObj.objectives,
					spawnBalls: jsonObj.spawnBalls,
					maxCasualties: jsonObj.maxCasualties
				}
				
				alert(unstrigifiedJsonObj)
				
				stages.push( unstrigifiedJsonObj )
				//////////////alert('stages[stages.length]: \r\n'+stages[0])// ok	

				
				Promise.all(promises).then(function(values) {			
					console.log('stage '+stageName+' loaded')
					//////////alert('stage: '+stageName)
					UI_display_selected_stage(stageName)
					
					/*
					loadStageFromStages( stageName )	
					
					// STAGE DETAILS: SHOW[PLAY]
					toggleButtonsVisibility([					
						{
							selector:'#stageDetails .stageDetailsControls .stage_play',
							removeClass: 'hiddenUIBtn',
							addClass:''
						}]				
					)
					// SLIDE #stageDetails DOWN
					document.querySelector('#stageDetails').classList.add('UI-animation-down')
					//hideAllPagesExcept('stageDetails')
					
					showPage('stageDetails')
					
					hidePage('stageSelection')
					*/
					
				})// promises

				
			})// load
		//}
		
	}
	
}


window.LoadStageFromStagesOrFromDexieAssets = function( stageName ){
	
	// Clearing the electricArc canvas
	ctx.clearRect(0,0,can.width,can.height);
	
	console.log('LOADING '+stageName)	
	var stgIsInStages = ''    
    
	try{
		stgIsInStages = stages.find(t => t.name == stageName).name;
		console.log(stgIsInStages)
	}
	catch(error){
		// DO NOTHING
	}
	console.log(stgIsInStages)
	
	if( stgIsInStages != '' ){
		// IF STAGE IS ALREADY LOADED INTO stages[]
	    console.log('stage already loaded in stages[]')	
		
		UI_display_selected_stage(stageName)	
	}
	else{
		console.log('2683 - loadStageFromDexieAssets')
	    loadStageFromDexieAssets(stageName)		
	}	
}


window.loadStageFromDexieAssets = function( stageName ){
    
	var replay = false
	var next = false
	/*
		if btn pushed is [retry] or [replay]...
	*/
	if(arguments.length == 2){
		if( arguments[1] == 'stage_replay'){
				replay = true
		}else if( arguments[1] == 'stage_next'){
				next = true
		}
	}	
		
    spawn(function* (){
        var params = 
        {
           collection : 'stages',
           name: stageName
        }

        yield db.assets
        .get(params)       
        .then(function(jsonObj){
           ////console.clear()
           console.log('LOADING: '+stageName+'\r\n')  
           console.log(jsonObj.object) 
          // console.log(JSON.parse(jsonObj.object)) 
		
            var unstrigifiedJsonObj = {
                name: jsonObj.name,
                description: jsonObj.description,
                briefing: jsonObj.object.briefing,
                stage_entityCannons: jsonObj.object.stage_entityCannons,				
                music: jsonObj.object.music,				
                BW_drawOnCanvas: jsonObj.object.BW_drawOnCanvas,				
                stage_brickwall_name: jsonObj.object.stage_brickwall_name,
                BW_x: jsonObj.object.BW_x,
                BW_y: jsonObj.object.BW_y,
                BW_dx: jsonObj.object.BW_dx,
                BW_dy: jsonObj.object.BW_dy,
                BW_path: jsonObj.object.BW_path,
                BW_pathMode: jsonObj.object.BW_pathMode,
                BW_pathEnd: jsonObj.object.stage_BW_pathEnd,
                BW_pathStep: jsonObj.object.BW_pathStep,
                BW_pathIdx: jsonObj.object.BW_pathIdx,				
                BW_states: jsonObj.object.BW_states,
                BW_firstStateAt: jsonObj.object.BW_firstStateAt,
                scrollingScreens: jsonObj.object.scrollingScreens,				
                objectives: jsonObj.object.objectives,
                spawnBalls: jsonObj.object.spawnBalls,
				maxCasualties: jsonObj.object.maxCasualties
            }

            console.log('unstrigifiedJsonObj\r\n')
            console.log(unstrigifiedJsonObj)
          
            stages.push( unstrigifiedJsonObj )// stage added to stages[]
			
			console.log('stage '+stageName+' loaded')
			
			/* 
				if btn pushed is [retry] or [replay]... 
				   load stage from stages
				   then show stage detail screen
			*/
			if(replay == true){										
					
				loadStageFromStages( stageName,'stage_replay' )
				.then(function(){		
					loadScrollings()
				})					
					
			}else if(next == true){								
							
				loadStageFromStages( stageName,'stage_next' )
				.then(function(){		
					loadScrollings()
				})
			}			
			else{ 
				
                //UI_display_selected_stage(stageName) // stage interface displayed
				loadStageFromStages( stageName )
				.then(function(){		
					loadScrollings()
				})				
			}
        })// then
		
    })// spawn
}



window.UI_display_selected_stage_fromReplayBtn = function(){
	// STAGE DETAILS: SHOW[PLAY] , HIDE #endStage [RETRY] && [NEXT]
	toggleButtonsVisibility([
		{
			selector:'#endStage .stageDetailsControls .stage_replay',
			removeClass: '',
			addClass:'hiddenUIBtn'
		},
		{
			selector:'#endStage .stageDetailsControls .stage_next',
			removeClass: '',
			addClass: 'hiddenUIBtn'
		},
		{
			selector:'#stageDetails .stageDetailsControls .stage_play',
			removeClass: 'hiddenUIBtn',
			addClass:''
		}
		]				
	)
	
	if( document.querySelector('#endStage').classList.contains('UI-animation-down')){
		document.querySelector('#endStage').classList.remove('UI-animation-down')
	}
	if( document.querySelector('#stageDetails').classList.contains('UI-animation-down')){
		document.querySelector('#stageDetails').classList.remove('UI-animation-down')
	}
	// SLIDE #stageDetails DOWN
		document.querySelector('#stageDetails').classList.add('UI-animation-down')					
		hideAllPagesExcept('stageDetails')
	
}


window.UI_display_selected_stage_fromNextBtn = function(){
	// STAGE DETAILS: SHOW[PLAY]
		
	toggleButtonsVisibility([					
		{
			selector:'#stageDetails .stageDetailsControls .stage_play',
			removeClass: 'hiddenUIBtn',
			addClass:''
		}]				
	)	
	
	if( document.querySelector('#endStage').classList.contains('UI-animation-down')){
		document.querySelector('#endStage').classList.remove('UI-animation-down')
	}
	// SLIDE #stageDetails DOWN
	document.querySelector('#stageDetails').classList.add('UI-animation-down')					
	hideAllPagesExcept('stageDetails')
	
}

/*
	LOAD JSON FILE WITH A CALLBACK FUNCTION
*/
/*function load(url, callback) {
  var xhr = new XMLHttpRequest();
  xhr.onreadystatechange = function() {
    if (xhr.readyState === 4) {
      callback(xhr.response);
    }
  }
  xhr.open('GET', url, true);
  xhr.send('');
}*/	


function load(url, callback) {
  var xhr = new XMLHttpRequest();
  
  promises[promises.length] = new Promise(function(resolve, reject) {
  
  window.totalPromises++
  
  xhr.onreadystatechange = function() {
    if (xhr.readyState === 4) {
      //callback(xhr.response);
	  console.log(xhr.response)
	  callback(xhr.response);
	  
	    resolve()
		window.solvedPromises++
		console.log(window.solvedPromises+' / '+window.totalPromises)
    }
  }//xhr.onreadystatechange = function()
  
  xhr.open('GET', url, true);
  xhr.send('');
  
  }) // promises[promises.length] = new Promise(function(resolve, reject) {
}



/*
	
		WORKS IN BROWSERS
		DOES NOT WORK ON PHONE
	
 window.load = function(url, callback) {

   promises[promises.length] = new Promise(function(resolve, reject) {
  
   window.totalPromises++
  
  
    const myHeaders = new Headers({
      "Content-Type": "application/json",
      Accept: "application/json"
    });
    
	fetch('./'+url,
		{headers: myHeaders}
	)
	 .then( (response) => {
		return response.json();
	  })
	 .then( (data)=>{
		//console.log('data:\r\n'+JSON.stringify(data))
		callback(JSON.stringify(data));
		resolve()

		window.solvedPromises++
		
		console.log(window.solvedPromises+' / '+window.totalPromises)
		
		var percentage = window.solvedPromises / window.totalPromises * 100
		//
	//	document.querySelector('#loadingStatus').innerHTML 
		//=  'Loading '+percentage.toFixed(0)+ '%'
		//
		if ( window.solvedPromises >= window.totalPromises){
			//document.querySelector('#loadingStatusContainer').classList.add('hiddenUIBtn')
		}
		
	 })
	 //.catch(error => {
    // Handle error
	//console.log("url:"+url)
	//console.log(error)
	
	});
  
 });	
	
 
}*/


/*


// REMOVE SRC HASH OF AALL sprite images

sources.map((e,i)=>{
    console.log(e+' '+i)
    let src = e.split('?')[0]
    sources[i] = src
})

console.log(sources)


*/


window.sources = [];
window.preloadAllImages = function(){
	
	//document.querySelector('#loadingStatus').innerHTML = 'Loading'	
	
	const preload = src => new Promise(function(resolve, reject) {
	  const img = new Image();
	  img.onload = function() {
		resolve(img);
	  }
	  img.onerror = reject;
	  img.src = src;	  
	});

	const preloadAll = sources =>
	  Promise.all(
		sources.map(
		  preload));

	preloadAll(sources)
	  .then(images => {
		console.log('Preloaded all', images);
		document.querySelector('#loadingStatusContainer').classList.add('hiddenUIBtn');
		/*
			LOAD ALL ASSETS
			images included after all images have been loaded in cache
		*/
		console.log('all images loaded in cache')
		loadAssets()	
	  })
	  .catch(err => {console.error('Failed', err);document.querySelector('#loadingStatusContainer').classList.add('hiddenUIBtn')});
}

		/*
			ADD SPRITE TO sprites COLLECTION
			- MAKES IT AVAILABLE JUST BY USING ITS NAME ATTRIBUTE
			  WITH THE function search() 
		*/
		window.createSpriteFromJson = function ( spriteDefObject ){		
			var newSprite = new Image();	
		
			var name = spriteDefObject.name,
				width = spriteDefObject.width,
				height = spriteDefObject.height,
				positions = spriteDefObject.positions,				
				frame = spriteDefObject.frame,
				frameMax = spriteDefObject.frameMax/*-1*/,
				frameTicker = spriteDefObject.frameTicker,
				nextFrameAt = spriteDefObject.nextFrameAt
				
				var hitboxes = []
				if(typeof spriteDefObject.hitboxes !=='undefined'){
					if( spriteDefObject.hitboxes.length > 0){
						hitboxes = spriteDefObject.hitboxes
						console.log(hitboxes)
						////////alert(JSON.stringify(hitboxes))
					}
				}				
				
			newSprite.onload = function(){									
			    spriteFrames.push(
					new Sprite(newSprite, width, height, positions, name, frame, frameMax, frameTicker, nextFrameAt, hitboxes)					
				)//push

				sources.push(newSprite.src)
			}	// on load	
			newSprite.src = spriteDefObject.src				
		}	
				
		/*
			ADD ENTITY TO entities COLLECTION
			- MAKES IT AVAILABLE JUST BY USING ITS NAME ATTRIBUTE
			  WITH THE function search() 
		*/
		window.createEntityFromJson = function( entityDefObject ){

			var entity = {			
				name : entityDefObject.name,			
				width : entityDefObject.width,
				height : entityDefObject.height,
				type : entityDefObject.type,

				collisionBoundaries : entityDefObject.collisionBoundaries,			
				rotateForOrientation : entityDefObject.rotateForOrientation,
				spriteFacingUp : entityDefObject.spriteFacingUp,
				
				
				drawOnCanvas : entityDefObject.drawOnCanvas,
				states : entityDefObject.states,					
				firstStateAt : entityDefObject.firstStateAt,
				
				frame : entityDefObject.frame,
				frameMax : entityDefObject.frameMax/*-1*/,
				frameTicker : entityDefObject.frameTicker,
				nextFrameAt : entityDefObject.nextFrameAt,
				
				energy: entityDefObject.energy,
				strength: entityDefObject.strength,				
				resistance: entityDefObject.resistance,	
				
				x: entityDefObject.x,
				y: entityDefObject.y,
				dx: entityDefObject.dx,
				dy: entityDefObject.dy,
				
				path: entityDefObject.path,
				pathStep: entityDefObject.pathStep,
				pathIdx: entityDefObject.pathIdx,				
				pathMode: entityDefObject.pathMode,
				pathEnd: entityDefObject.pathEnd,
				
					UP: entityDefObject.UP,
					LEFT: entityDefObject.LEFT,
					DEFAULT: entityDefObject.DEFAULT,
					RIGHT: entityDefObject.RIGHT,
					DOWN: entityDefObject.DOWN,
					APPEAR: entityDefObject.APPEAR,
					DISAPPEAR: entityDefObject.DISAPPEAR,
					PUNCHED: entityDefObject.PUNCHED,
				
				bounceHorizontally: entityDefObject.bounceVertically,
				bounceVertically: entityDefObject.bounceVertically,
				outOfHorizontalBoundaryRemove: entityDefObject.outOfHorizontalBoundaryRemove,
				outOfVerticalBoundaryRemove: entityDefObject.outOfVerticalBoundaryRemove,
				collideWithPaddleRemove: entityDefObject.collideWithPaddleRemove,
				collideWithPaddleBounce: entityDefObject.collideWithPaddleBounce,
				BounceBallVertically: entityDefObject.BounceBallVertically,
				BounceBallHorizontally: entityDefObject.BounceBallHorizontally,
				collideBallRemoveBall: entityDefObject.collideBallRemoveBall,
				collideBallAttacksBall: entityDefObject.collideBallAttacksBall,
				collidePaddleAttacksPaddle: entityDefObject.collidePaddleAttacksPaddle,
				collideBallLoseEnergy: entityDefObject.collideBallLoseEnergy,
				collidePaddleLoseEnergy: entityDefObject.collidePaddleLoseEnergy,
				
				collideWithBWRemove: entityDefObject.collideWithBWRemove,
				collideWithBWBounce: entityDefObject.collideWithBWBounce				
				
			}
			entities.push(entity)			
		}	
		
//
//	ANIMATION MANAGEMENT
//	
//
		//
		//
		//  ENTITIES : SPRITES & BRICKWALL 
		//
		//

		function Sprite(img, width, height, positions, name, frame, frameMax, frameTicker, nextFrameAt, hitboxes ){
		  this.img = img
		  this.width = width
		  this.height = height
		  this.positions = positions
		  this.name = name
		  this.frame = frame
		  this.frameMax = frameMax
		  this.frameTicker = frameTicker
		  this.nextFrameAt = nextFrameAt
		  this.hitboxes = hitboxes
		}
		
		var ang = 0
		Sprite.prototype = {
		  draw: function(position, x, y, context){    
			  let pos = this.positions[position];
			 //ctx.save();
			  if( pos != undefined ){
			 
			
			 /*
			 if( this.name != 'ball.entity' ){
				////////////alert(this.name)
				  //saves the state of canvas	
				  ctx.translate(x+this.width/2, y+this.height/2); //let's translate
				  ctx.rotate(Math.PI / 180 * (ang += 1)); //increment the angle and rotate the image 
				  ctx.translate( -(x+this.width/2), -(y+this.height/2) ); //let's translate
			  }
			  */
				  //if( sources.indexOf(this.img)!= -1 ){
				  
					  context.ctx.drawImage(
						this.img,
						pos[0],
						pos[1],
						this.width,
						this.height,
						x, y,
						this.width,
						this.height
					  );
					  
				   /*}else{
					   console.log('this.img:'+this.img)
				   }*/
			  }
			  /*
			  if( this.name != 'ball.entity' ){
			   // RESTORE AFTER ROTATION			  
			   ctx.restore(); //restore the state of canvas
			  }
			  */
			},
			drawEnergyLevel: function(energy, x, y, context, initEnergy){    
				//////////////alert(typeof energy)
			  if( typeof energy === 'number' && energy > 0 ){
				 // line color
				 
				 // Reset the current path
				  //context.ctx.beginPath(); 
				  // Starting point (10,45)
				 // context.ctx.moveTo(x,y-2);
				  // End point (180,47)
				  //context.ctx.lineTo(x+energy,y-2);
				  
				  var energyRemaining = energy / initEnergy * 100				  
				 
				  if( energyRemaining >= 80){
					context.ctx.fillStyle = "#00ff00";		 
				  }else if( energyRemaining >= 60){
					context.ctx.fillStyle = "#ffff00";		 
				  }else if( energyRemaining >= 40){
					context.ctx.fillStyle = "#ff9900";		 
				  }else if( energyRemaining >= 20){
					context.ctx.fillStyle = "#ff0000";		 
				  }else {
					context.ctx.fillStyle = "#000000";
				  }
				  /*
				  energyRemaining = x
				  ---------------   -
				  100               50
				  100*x = energyRemaining*/
				  // ADJUST THE WIDTH OF THE ENERGY BAR
				  var NRG = energyRemaining*20/100
				  
				  context.ctx.fillRect(x,y-10,NRG,8);
				  // Make the line visible
				  //context.ctx.stroke()
				  //context.ctx.closePath(); 
			  }	  
			}		
		}// end window.Sprite.prototype
		
		
		/*
			FADING OUT ENERGY POINTS -- BEGIN
		
			DISPLAYS ENERGY POINT LOST/GAINED BY ENTITY
			THE DISPLAY FADES AWAY AS IT ZOOMS IN
		
		USAGE: 
		var energyObject = {								
			color: [254,254,254],								
			idx: idx,				
			pointsAmount: damage,
			sign: -1,
			impactObject: ball //can be a ball or a sprite, used for its x,y,dx,dy
		}
		initEnergyPointFadeOut( energyObject )
		*/
			function initEnergyPointFadeOut( p ){
			
				var idx = energyObjects.length
				
				var impactObject = p.impactObject
				
				var energyObject = {
					step: 2,
					steps: 40,
					stepsInit: 40,
					opacity: 1,
					color: p.color,//'rgba(254,254,254,1)'
					idx: idx,
					iDx: impactObject.iDx,					
					x: impactObject.x + getRandomArbitrary(-10, 10),
					y: impactObject.y + getRandomArbitrary(-10, 10),
					dx: Math.sign(impactObject.dx)*getRandomArbitrary(-2, 2),
					dy: Math.sign(impactObject.dy)*getRandomArbitrary(-2, 2),								
					pointsAmount: p.pointsAmount,
					sign: p.sign
				}

				energyObjects[idx] = energyObject
			} //function initEnergyPointFadeOut(){
			
			/*
				FADING OUT ENERGY POINTS -- END
			*/
		
		/*
			FADE OUT ALL energy points FROM energyObjects[] -- being
		*/
		window.fadeOutEnergyPoints = function(){
			
			var canvas = document.getElementById('energyPoints')					
			var ctx = search('energyPoints', ctxs)	  
			ctx.ctx.clearRect(0, 0, canvas.width, canvas.height);
					
			energyObjects.filter(function(e,i){
				
				if( e.steps > 0){
									
					Step = e.step,
					StepsInit = e.stepsInit,
					Steps = e.steps,
					Opacity = e.opacity,
					//Color = e.color,				
					Idx = parseInt(e.idx),
					X = e.x,
					Y = e.y,
					dx = e.dx,
					dy = e.dy,
					Sign = e.sign,
					
					pointsAmount = parseInt(e.pointsAmount) 
					
					//Opacity -= Opacity.toFixed(2)/10
					var percentSteps = Steps / StepsInit * 100
										
					// OPACITY OS THE PERCENTAGE OF STEPS REMAINING COMPARED TO THE INITIAL VALUE OF STEPS
					Opacity = percentSteps.toFixed(1)
					
					Color = 'rgba('+e.color[0]+','+e.color[1]+','+e.color[2]+','+Opacity+')'			
					
					e.opacity = Opacity
					e.color = Color
					
					/*
						GET THE BRICKWALL's CONTEXT
					*/
					
					Steps --
					e.steps = Steps
					
					X += dx
					Y += dy
					
					e.x = X
					e.y = Y
										
					if (Steps < 1){
						//ctx.ctx.clearRect(parseInt(X-1), parseInt(Y-1), 50, 50) 					
						//delete energyObjects[Idx]
						//energyObjects.splice(Idx,1)
						//energyObjects[Idx].deleteMe = 1
						
						//console.clear()
						console.log(energyObjects.length)
						////////////alert(energyObjects.length)
						energyObjects.splice(i,1)
					}					
					else{
						ctx.ctx.fillStyle = Color	

						var FS = 10 + Math.abs(Steps-StepsInit)
						
						ctx.ctx.font = FS + "px Arial";	
						
						if(pointsAmount == 0){
							//pointsAmount = 'too weak!'	
						}else{
							var text = ( Sign < 0)?'-':'+'
								text += pointsAmount
						}	
						ctx.ctx.fillText(pointsAmount, X, Y);
					}
				}
			})
		
		}
		
	/*
		FADE OUT ALL energy points FROM energyObjects[] -- end
	*/	
		
		
		
		//
		// spawnSprite(spriteObject)
		//
		//    PARAMS : all params are optional
		//			 especially frame-related params
		//
		//	// INIT SPRITE SAMPLE
		//	let spriteObject = {
		//		x: x, // horizontal position
		//		y: y, // vertical position
		//		dx: dx, // horizontal vector
		//		dy: dy, // vertical vector,
		//		width:width, // sprite frame width
		//		height:height, // sprite frame height
		//		bounceHorizontally: true | false,
		//		outOfHorizontalBoundaryRemove: true | false,
		//		
		//		
		//		frame: 0, // default sprite frame
		//		frameMax: 1, // when frame == frameMax, reset sprite animation to frame 0 		
		//		frameTicker: 0, // ticker for switching to next sprite  frame
		//		nextFrameAt: 12 // when ticker == nextFrameAt, switch to next frame ('animation speed')
		//		
		//	}
		//	spawnSprite(spriteObject)
		//
		 function spawnSprite(spriteObject){
			let spriteObjectSpawned = {}
			
			// SPRITE IDENTITY
			spriteObjectSpawned.name = (  typeof  spriteObject.name  !== 'undefined')?   spriteObject.name:''					
			spriteObjectSpawned.drawOnCanvas = (  typeof  spriteObject.drawOnCanvas  !== 'undefined')?   spriteObject.drawOnCanvas:canvases[0].name
			spriteObjectSpawned.type = (  typeof  spriteObject.type  !== 'undefined')?   spriteObject.type:0			
			spriteObjectSpawned.spriteFrames = (  typeof  spriteObject.spriteFrames  !== 'undefined')?   spriteObject.spriteFrames:null		
			spriteObjectSpawned.animations = (  typeof  spriteObject.animations  !== 'undefined')?   spriteObject.animations:null			
			spriteObjectSpawned.energy = (  typeof  spriteObject.energy  !== 'undefined')?   spriteObject.energy:0
			spriteObjectSpawned.maxSimIterations = (  typeof  spriteObject.maxSimIterations  !== 'undefined')?   spriteObject.maxSimIterations:'undefined'
			
			// initEnergy: used to calculate 100%age of energy remaining
			spriteObjectSpawned.initEnergy = spriteObjectSpawned.energy
			spriteObjectSpawned.strength = (  typeof  spriteObject.strength  !== 'undefined')?   spriteObject.strength:0	
			spriteObjectSpawned.resistance = (  typeof  spriteObject.resistance  !== 'undefined')?   spriteObject.resistance:0	
			
			// LINEAR MOVEMENTS
			spriteObjectSpawned.x = (  typeof  spriteObject.x  !== 'undefined')?   spriteObject.x:0
			spriteObjectSpawned.y = (  typeof  spriteObject.y  !== 'undefined')?   spriteObject.y:0
			spriteObjectSpawned.dx = (  typeof  spriteObject.dx  !== 'undefined')?   spriteObject.dx:0
			spriteObjectSpawned.dy = (  typeof  spriteObject.dy  !== 'undefined')?   spriteObject.dy:0
						
			spriteObjectSpawned.collisionBoundaries = 
			(  typeof  spriteObject.collisionBoundaries  !== 'undefined')?   spriteObject.collisionBoundaries:null
			
			spriteObjectSpawned.rotateForOrientation = ( typeof spriteObject.rotateForOrientation  !== 'undefined')?spriteObject.rotateForOrientation:false
			spriteObjectSpawned.spriteFacingUp = ( typeof spriteObject.spriteFacingUp  !== 'undefined')?spriteObject.spriteFacingUp:false
						
			// PATHWAYS-BASED MOVEMENTS
			spriteObjectSpawned.px = ( typeof spriteObject.px  !== 'undefined')?spriteObject.px:0
			spriteObjectSpawned.py = ( typeof  spriteObject.py  !== 'undefined')?spriteObject.py:0
			spriteObjectSpawned.path = ( typeof  spriteObject.path  !== 'undefined')?spriteObject.path: -1
			spriteObjectSpawned.pathStep = ( typeof  spriteObject.pathStep  !== 'undefined')?spriteObject.pathStep:1
			spriteObjectSpawned.pathIdx = ( typeof  spriteObject.pathIdx  !== 'undefined')?spriteObject.pathIdx: 0
			spriteObjectSpawned.pathMode = ( typeof  spriteObject.pathMode  !== 'undefined')?spriteObject.pathMode:'absolute'
			spriteObjectSpawned.pathEnd = ( typeof  spriteObject.pathEnd  !== 'undefined')?spriteObject.pathEnd:'stop'
			
			//BOOLEANS --begin
			
			// INTERACTIONS WITH CANVAS: BOUNCE OR REMOVE	
			spriteObjectSpawned.bounceHorizontally = ( typeof spriteObject.bounceHorizontally === 'boolean'  )?spriteObject.bounceHorizontally:false		
			spriteObjectSpawned.bounceVertically = ( typeof spriteObject.bounceVertically === 'boolean'  )?spriteObject.bounceVertically:false		
			spriteObjectSpawned.outOfHorizontalBoundaryRemove = (  typeof spriteObject.outOfHorizontalBoundaryRemove === 'boolean'  )?spriteObject.outOfHorizontalBoundaryRemove:false		
			spriteObjectSpawned.outOfVerticalBoundaryRemove = (  typeof spriteObject.outOfVerticalBoundaryRemove === 'boolean'  )?spriteObject.outOfVerticalBoundaryRemove:false		
			
			// INTERACTIONS WITH BALLS AND PADDLE: BOUNCE OR REMOVE
			spriteObjectSpawned.collideWithPaddleRemove = (  typeof spriteObject.collideWithPaddleRemove === 'boolean'  )?spriteObject.collideWithPaddleRemove:false		
			spriteObjectSpawned.collideWithPaddleBounce = (  typeof spriteObject.collideWithPaddleBounce === 'boolean'  )?spriteObject.collideWithPaddleBounce:false		
			spriteObjectSpawned.BounceBallVertically = (  typeof spriteObject.BounceBallVertically === 'boolean'  )?spriteObject.BounceBallVertically:false		
			spriteObjectSpawned.BounceBallHorizontally = (  typeof spriteObject.BounceBallHorizontally === 'boolean'  )?spriteObject.BounceBallHorizontally:false		
			spriteObjectSpawned.collideBallRemoveBall = (  typeof spriteObject.collideBallRemoveBall === 'boolean'  )?spriteObject.collideBallRemoveBall:false		
			spriteObjectSpawned.collideBallAttacksBall = (  typeof spriteObject.collideBallAttacksBall === 'boolean' )?spriteObject.collideBallAttacksBall:false		
			spriteObjectSpawned.collidePaddleAttacksPaddle = (  typeof spriteObject.collidePaddleAttacksPaddle === 'boolean' )?spriteObject.collidePaddleAttacksPaddle:false		
			
			// NOT TAKEN INTO ACCOUNT IF SPRITE IS A BALL --begin //	
			spriteObjectSpawned.collideBallLoseEnergy  = (  typeof spriteObject.collideBallLoseEnergy === 'boolean'  )?spriteObject.collideBallLoseEnergy:true
			spriteObjectSpawned.collidePaddleLoseEnergy  = ( typeof spriteObject.collidePaddleLoseEnergy === 'boolean' )?spriteObject.collidePaddleLoseEnergy:true
			// NOT TAKEN INTO ACCOUNT IF SPRITE IS A BALL --end //	
			
			// INTERACTIONS WITH BRICKWALL (BALLS) -- begin
			spriteObjectSpawned.collideWithBWRemove  = (  typeof spriteObject.collideWithBWRemove === 'boolean'  )?spriteObject.collideWithBWRemove:false
			spriteObjectSpawned.collideWithBWBounce  = (  typeof spriteObject.collideWithBWBounce === 'boolean'  )?spriteObject.collideWithBWBounce:true
			
			// INTERACTIONS WITH BRICKWALL (BALLS) -- end
			
			
			// BOOLEAN --end
			
			// SPRITE: SIZE AND ANIMATION
			spriteObjectSpawned.frame = ( spriteObject.frame )?spriteObject.frame:0	
			spriteObjectSpawned.frameMax = ( spriteObject.frameMax )?spriteObject.frameMax:1		
			spriteObjectSpawned.frameTicker = ( spriteObject.frameTicker )?spriteObject.frameTicker:0
			spriteObjectSpawned.nextFrameAt = ( spriteObject.nextFrameAt )?spriteObject.nextFrameAt:0
			spriteObjectSpawned.width = ( spriteObject.width )?spriteObject.width:0
			spriteObjectSpawned.height = ( spriteObject.height )?spriteObject.height:0
			
			spriteObjectSpawned.invincibility = ( typeof spriteObject.invincibility !== 'undefined')?spriteObject.invincibility:-1
			spriteObjectSpawned.follow = ( spriteObject.follow > -1 )?spriteObject.follow: -1
			
			spriteObjectSpawned.txt = ( spriteObject.txt > -1 )?spriteObject.txt: ''
			
			
			spriteObjectSpawned.iDx = ( typeof spriteObject.iDx !='undefined' )?spriteObject.iDx: Date.now()
			
			// STATES			
			spriteObjectSpawned.currentStateIndex = -1// index of the state that is currently used				
			spriteObjectSpawned.states = ( spriteObject.states )?spriteObject.states:[]
			spriteObjectSpawned.firstStateAt = ( spriteObject.firstStateAt )?parseInt(spriteObject.firstStateAt):0// when to trigger spriteObjectSpawned.states[0] for the first time
			spriteObjectSpawned.nextStateAt = parseInt(timeUnit) + 1 + spriteObjectSpawned.firstStateAt//parseInt(timeUnit) // add 'next' to nextStateAt when item iterated
			
						
			if(	
				spriteObjectSpawned.type == 'ball'
				|| spriteObjectSpawned.type == 'obstacleBall' 
			){				
				/*
					IF THE LIMIT OF ALLOWED SIMULTANEOUS INSTANCES
					OF THIS ENTITY IS REACHED
					THEN DO NOT SPAWN A NEW INSTANCE
				*/		
				if( spriteObjectSpawned.maxSimIterations != 'undefined'){
										
					// HOW MANY OF THIS 
					let currentInstanceCount = balls.filter(function(o) { return o.name == spriteObjectSpawned.name }).length	
					if( parseInt(spriteObjectSpawned.maxSimIterations) !== -1
						&& currentInstanceCount >= parseInt(spriteObjectSpawned.maxSimIterations)
					){ 						
						return true  
					}				
				}
				
				/*
					IF BALL HAS INVINCIBILITY > -1
						BALL WILL HAVE A FORCE FIELD
						UNTIL ITS INVINCIBILITY < 0
				*/				
				if (spriteObjectSpawned.invincibility > 0){
					spriteObjectSpawned.forceField = {
						frame : 0,											 
						nextFrameAt : 1,
						frameTicker : 0	
					}
				}
			
				balls[balls.length] = spriteObjectSpawned;
				/*var ball = balls[balls.length]				
				swapSprite(sprite)*/				
				return true				
			}
			
			if(	
				spriteObjectSpawned.type == 'enemy' 
				|| spriteObjectSpawned.type == 'graphic'
				|| spriteObjectSpawned.type == 'powerup'
				|| spriteObjectSpawned.type == 'speedChanger'
				|| spriteObjectSpawned.type != 'ball'
				|| spriteObjectSpawned.type != 'bumper'
				|| spriteObjectSpawned.type == 'obstacle' 
			){				
				/*
					IF THE LIMIT OF ALLOWED SIMULTANEOUS INSTANCES
					OF THIS ENTITY IS REACHED
					THEN DO NOT SPAWN A NEW INSTANCE
				*/		
				if( spriteObjectSpawned.maxSimIterations != 'undefined'){
										
					// HOW MANY OF THIS 
					let currentInstanceCount = sprites.filter(function(o) { return o.name == spriteObjectSpawned.name }).length	
					if( parseInt(spriteObjectSpawned.maxSimIterations) !== -1
						&& currentInstanceCount >= parseInt(spriteObjectSpawned.maxSimIterations)
					){ 						
						return true  
					}				
				}				
				
				/*
					ennemy, graphic, powerup, speedChanger				
				*/
				sprites[sprites.length] = spriteObjectSpawned;				
				/*var sprite = sprites[sprites.length]				
				swapSprite(sprite)*/				
				return true
			}
			
		}
				
		//
		//	fonction animateSprite(sprite)
		//	 DOES: animate the sprite by switching to next frame
		//		   draw the current frame
		//	 PARAMS: ball (sprite) - required
		//
		 function animateSprite( sprite ) {		 
		   //////////////alert(JSON.stringify(sprite))//  comes 2 in here then nothing
		  // ANIMATION
		  if( sprite.frameTicker == sprite.nextFrameAt ){ 
			  sprite.frameTicker = 0;
			  sprite.frame++;
			  // IF ITERATED AFTER LAST FRAME, SWITCH TO FIRST FRAME
			  if( sprite.frame > sprite.frameMax ){
				sprite.frame = 0;
			  }	  
		  }
		  
		   var ctx = search(sprite.drawOnCanvas, ctxs);
		   //////////////alert(ctx)
		  /*
				SPRITE ROTATION 1/2
		  */
		  /*
		  paddle.rotation = 180
		  paddle.rotating = 1
		  */
		  
		 
		////console.clear()		
		/*console.log('name: '+sprite.name)
		console.log('type: '+sprite.type)
		console.log('rotateForOrientation: '+sprite.rotateForOrientation)
		console.log('spriteFacingUp: '+sprite.spriteFacingUp)
		 */
		if( sprite.rotateForOrientation == true){
			
			sprite.rotating = 1
		
			if( sprite.dx == 0 ){
				if( sprite.dy > 0  ){
					//var name = sprite.DOWN
					if( sprite.spriteFacingUp == false){	
						sprite.rotation = 0
					}
					else if( sprite.spriteFacingUp == true){	
						sprite.rotation = 180
					}
				}		
				else if( sprite.dy < 0  ){
					//var name = sprite.UP	
					if( sprite.spriteFacingUp == false){	
						sprite.rotation = 180
					}
					else if( sprite.spriteFacingUp == true){	
						sprite.rotation = 0
					}
				}				
			}
			
			else if( sprite.dy == 0 ){					
				if( sprite.dx > 0  ){					
					//var name = sprite.RIGHT					
					if( sprite.spriteFacingUp == false){	
						sprite.rotation = 270
					}
					else if( sprite.spriteFacingUp == true){	
						sprite.rotation = 90
					}
				}
				else if( sprite.dx < 0  ){					
					//var name = sprite.RIGHT					
					if( sprite.spriteFacingUp == false){	
						sprite.rotation =90
					}
					else if( sprite.spriteFacingUp == true){	
						sprite.rotation = 270
					}
				}
			}	
			
			else if( sprite.spriteFacingUp == true ){			
				if( sprite.dx > 0 && sprite.dy < 0 ){
					// up right
					sprite.rotation = 45			
				}
				else if( sprite.dx > 0 && sprite.dy > 0 ){
					// up right
					sprite.rotation = 135			
				}
				else if( sprite.dx < 0 && sprite.dy > 0 ){
					// up right
					sprite.rotation = 225			
				}
				else if( sprite.dx < 0 && sprite.dy < 0 ){
					// up right
					sprite.rotation = 315			
				}
			}
			
				else if( sprite.spriteFacingUp == false ){			
					if( sprite.dx > 0 && sprite.dy < 0 ){
						// up right
						sprite.rotation = 135			
					}
					else if( sprite.dx > 0 && sprite.dy > 0 ){
						// up right
						sprite.rotation = 45			
					}
					else if( sprite.dx < 0 && sprite.dy > 0 ){
						// up right
						sprite.rotation = 315			
					}
					else if( sprite.dx < 0 && sprite.dy < 0 ){
						// up right
						sprite.rotation = 225			
					}
				}
			
			
			}
		  
		  
		  
		  if( sprite.rotating == 1 && sprite.type != 'punched'){			  
				ctx.ctx.save();				  		
			    //saves the state of canvas	
				
				if( sprite.shaking > 0 ){
					ctx.ctx.translate( sprite.x+sprite.width/2, sprite.y+sprite.height); //let's translate
					
					ctx.ctx.rotate(Math.PI / 180 * sprite.rotation); //increment the angle and rotate the image
					
					ctx.ctx.translate( -(sprite.x+sprite.width/2), -(sprite.y+sprite.height) ); //let's translate
				}	
				else{
				
					ctx.ctx.translate( sprite.x+sprite.width/2, sprite.y+sprite.height/2); //let's translate
					ctx.ctx.rotate(Math.PI / 180 * sprite.rotation); //increment the angle and rotate the image 
					  /*if( sprite.shaking > 0 ){
						ctx.ctx.translate( -(sprite.x+sprite.width/2), -(sprite.y+sprite.height)-sprite.height ); //let's translate
					  }else{*/				  
					ctx.ctx.translate( -(sprite.x+sprite.width/2), -(sprite.y+sprite.height/2) ); //let's translate
					 /* }*/
				}
		   }
		   else
		  //document.getElementById('log').innerHTML = sprite.type+' '+sprite.punched
		  if( sprite.type == 'punched'){
			  
			name = sprite.animations.DEFAULT;
			
			//swapSprite(sprite,'PUNCHED')
			if( sprite.animations.PUNCHED != 'undefined'
				&& typeof sprite.animations.PUNCHED !== 'undefined'
				&& sprite.animations.PUNCHED != ''
				&& sprite.animations.PUNCHED != undefined
			){
				name = sprite.animations.PUNCHED;				
			}else{
				name = sprite.animations.DEFAULT;				
			}	
			////////////alert(name)			
			var frameObject = search(name, spriteFrames);				
			
			if( typeof frameObject == 'undefined' ){
				return false
			} 			
			sprite.spriteFrames = frameObject
			
			sprite.width = frameObject.width // sprite frame width
			sprite.height = frameObject.height // sprite frame 	
						
			sprite.frame = parseInt(frameObject.frame) // default sprite frame
			sprite.frameMax = parseInt(frameObject.frameMax) // when frame == frameMax, reset sprite animation to frame 0 		
			sprite.frameTicker = parseInt(frameObject.frameTicker) // ticker for switching to next sprite  frame
			sprite.nextFrameAt = parseInt(frameObject.nextFrameAt) // when ticker == nextFrameAt, switch to next frame 			
			
			
		   // ctx.clearRect(sprite.x,sprite.y,sprite.width,sprite.height)
			ctx.ctx.save();				  		
			  //saves the state of canvas	
			  ctx.ctx.translate(sprite.x+sprite.width/2, sprite.y+sprite.height/2); //let's translate
			  ctx.ctx.rotate(Math.PI / 180 * (ang += sprite.rotation)); //increment the angle and rotate the image 
			  
			 ctx.ctx.translate( -(sprite.x+sprite.width/2), -(sprite.y+sprite.height/2) ); //let's translate
			  
			  
		  }
		  // end  if( sprite.type == 'punched'){
		  
		  
		   
		  
		  //sprite.drawOnCanvas = 'ground' // HAS BEEN CHANGED
		  //var context = search(sprite.drawOnCanvas, ctxs);
		  
			//sprite.spriteFrames.draw( sprite.frame, sprite.x, sprite.y);// draw sprite - sprite frame index, left, top		  
			sprite.spriteFrames.draw( sprite.frame, sprite.x, sprite.y, ctx);// draw sprite - sprite frame index, left, top		  
			
			
			/*
			
			
			-- USED WITH spawnEntityFromJson('combo-star-100x500.ent',p)
			
			if( sprite.txt != undefined && sprite.txt != ''){
				////////////alert(sprite.txt)
				 var textX = parseInt(sprite.x) + 100/2
					 textY = parseInt(sprite.y) + 100/2	
					
					var ctx = search('comboStar',ctxs)
					
					ctx.ctx.font = "20px Century Gothic";
					ctx.ctx.textAlign = "center";
					ctx.ctx.textBaseline = "middle";
					
					ctx.ctx.fillStyle = "#000000";					
					ctx.ctx.fillText(sprite.txt, textX, textY - 5);
					
					ctx.ctx.font = "15px Arial";
					ctx.ctx.fillText('HITS !', textX, textY + 20);
					
					ctx.ctx.strokeStyle = "#000000";
					ctx.ctx.strokeText(sprite.txt+' hits!', textX, textY);				
			}*/
			
		  /*
				SPRITE ROTATION 2/2
		  */
		  if( sprite.rotating == 1){			   
				// RESTORE AFTER ROTATION				   
				ctx.ctx.restore(); //restore the state of canvas
				
				if(sprite.frame == 0){
					
					if(sprite.rotateForOrientation !== true){
						sprite.rotating = 0
						sprite.rotation = 0	
					}
					
				}
		  }		  
		  else if( sprite.type == 'punched'){
		   // RESTORE AFTER ROTATION				   
		   ctx.ctx.restore(); //restore the state of canvas	
		  }
		  
		  
		 // context = search('sky', ctxs);
		  //sprite.spriteFrames.drawEnergyLevel( sprite.energy, sprite.x, sprite.y, ctx, sprite.initEnergy );// draw sprite energy level
		  
		  if( sprite.displayEnergy > 0 ){
			displayEnergy( sprite )
			sprite.displayEnergy --
		  }
		  
		  
		  sprite.frameTicker++
		  
		}
		  
		  function displayEnergy( sprite ){
				context = search('sky', ctxs);
				sprite.spriteFrames.drawEnergyLevel( 
				sprite.energy, 
				sprite.x, 
				sprite.y, 
				context, 
				sprite.initEnergy );// draw sprite energy level
			}
		  
		 function hitCombo(paramsObject){			 
			/*
			if( paramsObject.x ){
				return
			}*/
			
			// register hit
			var lastHitAt = parseInt(paddle.lastHitAt)
			var currentCombo = parseInt(paddle.currentCombo)			
			
			 var p = {
				 x:paramsObject.x,
				 y:paramsObject.y,
				 w:paramsObject.width,
				 h:paramsObject.height				 
			 }			 
			 p.x = p.x - p.w/2
			 p.y = p.y - p.h/2
			 // ALWAYS MAKE SURE COMBO STARS ARE VISIBLE ON SCREEN
			 if( p.x < 100 ){ p.x = 100 }
			 if( p.x > 260 ){ p.x = 260 }
			 if( p.y < 100 ){ p.y = 100 }
			 if( p.y > 600 ){ p.y = 600 }
			 
			 var textX = parseInt(p.x) + 100/2
				 textY = parseInt(p.y) + 100/2			 
			 
			 // THE HIT COMBOS WILL DISPLAY ON THE 'combo' canvas
		    /*var ctx  = search('combo',ctxs)	 
				ctx.ctx.font = "30px Arial";
				ctx.ctx.textAlign = "center";
				ctx.ctx.textBaseline = "middle";
				ctx.ctx.fillStyle = "#000000";
			*/
		
			/*
				COMBO +1:
				IF DELAY WITH PREVIOUS HIT <= 1 second
				ADD A HIT COMBO
			*/
			if( timeUnit - lastHitAt < comboInterval ){
				paddle.currentCombo = currentCombo + 1
				// IF THIS COMBO IS GREATER THANT THE BEST, IT BECOMES THE BEST
				
				if (paddle.currentCombo > paddle.bestStageCombo){
					paddle.bestStageCombo = paddle.currentCombo
				}
			}else{
				/* 
					ELSE 
						IF CURRENT COMBO COUNT > 0 
							IT IS THE END OF THE CURRENT COMBO
							DISPLAY THE TOTAL
						ENDIF
					SET THE CURRENT COMBO COUNT TO 0
					END IF ELSE				
				*/
			
				if ( currentCombo > 1){
					p.txt = currentCombo
					
					var cbo = {
						x:p.x,
						y:p.y,
						spikes: 8,
						outerRadius: 50, 
						innerRadius: 35, 
						strokeStyle: 'bold #000', 
						fillStyle: 'rgba(255,255,0,0.8)', 
						txt: p.txt,
						duration: 60,
						rot:0
					}	
					
					combosObjects.push(cbo)
					
					/*
					var entityName = 'combo-star-100x500.ent'
					spawnEntityFromJson( entityName, p )*/
					/*
					var ctx = search('sky',ctxs)
					drawStar(ctx.ctx, x, y, 20, 60, 50, '#000', '#ff0')
					*/
					//*ctx.ctx.fillText(currentCombo, textX, textY);
					
					checkRelevantObjectiveCompletion( 'minCombos' )
					
				}								
				paddle.currentCombo = 0														
			}
			
			paddle.lastHitAt = timeUnit
		}// end hitCombo
		
		
		
		 function swapSprite(sprite){
						
			////////////alert(sprite.name+' '+sprite.rotateForOrientation)	
			var name = sprite.animations.DEFAULT;
			
			if( arguments.length == 2){
				name = arguments[1]	
				
				switch( name ){					
					case 'PUNCHED':						
						if( sprite.animations.PUNCHED == 'undefined'){
							name = sprite.animations.DEFAULT;							
						}						
					break;
				}		
				
			}
			else{
				
					if( sprite.dx == 0 ){
						if( sprite.dy > 0  ){
							//var name = sprite.DOWN
							name = ( sprite.animations.DOWN != '' )?sprite.animations.DOWN:name
						}		
						else if( sprite.dy < 0  ){
							//var name = sprite.UP	
							name = ( sprite.animations.UP != '' )?sprite.animations.UP:name
						}				
					}
					
					else if( sprite.dy == 0 ){					
						if( sprite.dx > 0  ){					
							//var name = sprite.RIGHT					
							name = ( sprite.animations.RIGHT != '' )?sprite.animations.RIGHT:name
						}		
						else if( sprite.dx < 0  ){
							//var name = sprite.LEFT
							name = ( sprite.animations.LEFT != '' )?sprite.animations.LEFT:name
						}
					}
					
					else if( Math.abs(sprite.dx) > Math.abs(sprite.dy) ){		
						if( sprite.dx > 0  ){					
							//var name = sprite.RIGHT					
							name = ( sprite.animations.RIGHT != '' )?sprite.animations.RIGHT:name
						}		
						else if( sprite.dx < 0  ){
							//var name = sprite.LEFT
							name = ( sprite.animations.LEFT != '' )?sprite.animations.LEFT:name
						}
					}

					else{
						if( sprite.dy > 0  ){
							//var name = sprite.DOWN
							name = ( sprite.animations.DOWN != '' )?sprite.animations.DOWN:name
						}		
						else if( sprite.dy < 0  ){
							//var name = sprite.UP	
							name = ( sprite.animations.UP != '' )?sprite.animations.UP:name
						}
					}				
				}
			
			var frameObject = search(name, spriteFrames);				
			
			if( typeof frameObject == 'undefined' ){				
				return false
			}
 			
			sprite.spriteFrames = frameObject
			
			sprite.width = frameObject.width // sprite frame width
			sprite.height = frameObject.height // sprite frame 	
						
			sprite.frame = parseInt(frameObject.frame) // default sprite frame
			sprite.frameMax = parseInt(frameObject.frameMax) // when frame == frameMax, reset sprite animation to frame 0 		
			sprite.frameTicker = parseInt(frameObject.frameTicker) // ticker for switching to next sprite  frame
			sprite.nextFrameAt = parseInt(frameObject.nextFrameAt) // when ticker == nextFrameAt, switch to next frame 			
			
			sprite.hitboxes = frameObject.hitboxes
			/*
			if( sprite.hitboxes.length > 0 ){
				//////alert(JSON.stringify(sprite.hitboxes))
			}*/
		}
		
		
		
		
		//
		//	 moveSprites()
		//	PARAMS: none
		//	DOES: 
		//		  iterate all sprites and handles
		//		  - sprites movements
		//		  - removal when colliding with paddle
		//		  - bouncing when colliding with paddle
		//
		 function moveSprites() {
		
		  let sprite_idx = 0;
		  
		   ////document.querySelector('#log').innerHTML = stageNthFrame
		  
		  if( sprites.length > 0){		  		  
		  		  
		   Array.prototype.some.call(sprites, function (sprite){
		   
		   if( sprite.shaking > 0 ){
			   sprite.rotating = true
			 /*sprite.x = sprite.archiveX + getRandomArbitrary(-10, 10)
			 sprite.y = sprite.archiveY + getRandomArbitrary(-10, 10)*/
			 
			if( sprite.shaking%2 == 0 ){
				sprite.rotation = getRandomArbitrary(1, 20)			
			}else if( sprite.shaking%2 == 0 ){
				sprite.rotation = getRandomArbitrary(339, 359)
			}
			 	 /*		  
			  if( sprite.shaking%2 == 0 ){
				  sprite.x = sprite.archiveX + 5
			  }else if( sprite.shaking%2 == 0 ){
				  sprite.x = sprite.archiveX - 5
			  }
			  
			  if( sprite.shaking%2 == 0 ){
				  sprite.y = sprite.archiveY - 5
			  }else if( sprite.shaking%2 == 0 ){
				  sprite.y = sprite.archiveY + 5
			  }
			  */		  
			  sprite.shaking --
			  if(sprite.shaking == 0){
				   sprite.x = sprite.archiveX
				   sprite.y = sprite.archiveY
			  }
		   }
		   else if( typeof sprite.archiveX != 'undefined'){
				   sprite.x = sprite.archiveX
				   sprite.y = sprite.archiveY
				   sprite.rotating = false
		   }
		  
			//  while ( sprite_idx < sprites.length){

				//sprite = sprites[sprite_idx];
				
			/* STATES -- begin  */
								
				//sprite.nextStateAt = 0; // add 'next' to nextStateAt when item iterated	
				//sprite.currentStateIndex = 0; // index of the state that is currently used	
				
			/*	
			  //console.clear()
			console.log(
				'sprites[0].currentStateIndex: '+sprites[0].currentStateIndex+'\r\n'
				+'sprites[0].nextStateAt: '+sprites[0].nextStateAt+'\r\n'
				+'sprites[0].states[sprite.currentStateIndex]: '+sprites[0].states[sprites[0].currentStateIndex]+'\r\n'				
				+'sprites[0].currentStateIndex: '+sprites[0].currentStateIndex+'\r\n'
			)
			
			console.log( timeUnit + ' == ' + sprite.nextStateAt  )*/
			if( sprite.states.length > 0){	
				/* 
					IF IT IS TIME TO SWITCH TO NEXT STATE -- begin					
				*/
				
				//document.querySelector('#log').innerHTML =  'timeUnit: '+timeUnit+'\r\n nextStateAt:'+ sprite.nextStateAt
				
				if( timeUnit == parseInt(sprite.nextStateAt) 
					|| (sprite.currentStateIndex == -1
					   && timeUnit == parseInt(sprite.firstStateAt)+1) // FIRST TIME THE FIRST STATE IS ITERATED
				){						
					// current state becomes next state
				    sprite.currentStateIndex = parseInt(sprite.currentStateIndex) + 1
					if( sprite.currentStateIndex == sprite.states.length){
					  sprite.currentStateIndex = 0
				    }
					
					var state = sprite.states[sprite.currentStateIndex]					
					
					// UPDATE ATTRIBUTE 'next' -- begin					
					if( typeof state.next !== 'undefined' ){
						sprite.nextStateAt = parseInt(timeUnit) + parseInt(state.next)			 
					}
					else {
						if( 
							timeUnit == parseInt(sprite.firstStateAt)+1
							&& sprite.currentStateIndex == -1
						)
						{						
							sprite.nextStateAt = parseInt(sprite.firstStateAt)						
						}						
					}
					// UPDATE ATTRIBUTE 'next' -- end
					
				  if( typeof state.x !== 'undefined' ){
					sprite.x = parseInt(state.x)
				  }				  
				  if( typeof state.y !== 'undefined'){
					sprite.y = parseInt(state.y)
				  }				  
				  if( typeof state.dx !== 'undefined' ){
					sprite.dx = parseInt(state.dx)
					swapSprite(sprite)
				  }				  
				  if( typeof state.dy !== 'undefined'){
					sprite.dy = parseInt(state.dy)
					//console.log(sprite)
					//console.log(state)
					//pause()
					swapSprite(sprite)
				  }				  
				  if( typeof state.path !== 'undefined' ){
					sprite.path = state.path
				  }
				  if( typeof state.pathEnd !== 'undefined' ){
					sprite.pathEnd = state.pathEnd
				  }
				  if( typeof state.pathIdx !== 'undefined' ){
					sprite.pathIdx = parseInt(state.pathIdx)
				  }
				  if( typeof state.pathStep !== 'undefined' ){
					sprite.pathStep = parseInt(state.pathStep)
				  }
				  if( typeof state.pathMode !== 'undefined' ){
					sprite.pathMode = state.pathMode
				  }
				  if( typeof state.resistance !== 'undefined' ){
					sprite.resistance = state.resistance
				  }
				  if( typeof state.strength !== 'undefined' ){
					sprite.strength = state.strength
				  }
				  
						
				  // EXECUTE ACTION IF AVAILABLE IN STATE -- begin
				  if( typeof state.action !== 'undefined' ){
					sprite.action = state.action					
					// FETCH THE FUNCTION MATCHING THE ATTRIBUTE 'name' OF THE ACTION, e.g.: 'killSelf'
					var action = search(sprite.action.name, actions)
					/*
						EXECUTE THE FUNTION WITH PARAMETERS
						& GET WHAT IS RETURNED BY THE FUNCTION
					*/
					
					/*
						Add 1 attribute to params						
						SelfIdx = the index of Self in the collection sprites[]
							      to make it possible to remove this sprite from sprites[]
					*/
					var params = sprite.action.params						
						params.SelfIdx = sprite_idx
						params.This = sprite
						
					// EXECUTE THE ACTION					
					action.Function( params )
					//console.log(params)
					////////////alert('here')
					
					/*
						IF THE SPRITE IS THE COMBO STAR (combo-star-100x500.ent)
						( THE ACTION IS REMOVESELF)
						CLEAR THE TEXT ON CANVAS 'combo'
						AT SPRITE COORDINATES 						
					*/
					/*if( sprite.name == 'combo-star-100x500.ent'){						
						 var xc = sprite.x//- sprite.width/2,
							 yc = sprite.y// - sprite.height/2
						 var textX = parseInt(xc) + 100/2
							 textY = parseInt(yc) + 100/2
						var ctx  = search('combo',ctxs)
					    ctx.ctx.clearRect(xc, yc, sprite.width, sprite.height);						
					}*/
					
				  }
				  // EXECUTE ACTION IF AVAILABLE IN STATE -- end
				  
				  //console.log(state.spriteFramesObject)				  
				  if( typeof state.spriteFramesObject !== 'undefined'){
					  //console.log(state.spriteFramesObject)
					  var frameObject = search(state.spriteFramesObject, spriteFrames);

					  if( frameObject !== undefined ){
						  sprite.spriteFrames = frameObject
						  sprite.width = frameObject.width // sprite frame width
						  sprite.height = frameObject.height // sprite frame
						  sprite.frame = parseInt(frameObject.frame) // default sprite frame
						  sprite.frameMax = parseInt(frameObject.frameMax) // when frame == frameMax, reset sprite animation to frame 0 		
						  sprite.frameTicker = parseInt(frameObject.frameTicker) // ticker for switching to next sprite  frame
						  sprite.nextFrameAt = parseInt(frameObject.nextFrameAt) // when ticker == nextFrameAt, switch to next frame 			
					  }
				  }
					
				}
				/* 
					IF IT IS TIME TO SWITCH TO NEXT STATE -- end					
				*/	  
			} // if states !== undefined, ...
			/* STATES -- end  */
				  
			      
				  var canvas = document.getElementById(sprite.drawOnCanvas)
		
				  if( typeof sprites[sprite_idx] === 'undefined' ){
					//continue
				  }
				
				  // SKIP IF FRAME ERROR
				  if ( isNaN(sprite.frame) == true ) {				  
					//continue	  
				  }	

				// DRAW ONLY IF IN THE STAGE BOUNDARIES
				if( 					
					sprite.y <= parseInt(canvas.style.top) + parseInt(canvas.getAttribute('height')) + parseInt(sprite.height)
					 /*&&	sprite.y >= parseInt(canvas.style.top) - parseInt(sprite.height)*/
					 && sprite.x <= parseInt(canvas.style.left) + parseInt(canvas.getAttribute('width')) + parseInt(sprite.width)
					 /*&& sprite.x >= parseInt(canvas.style.left) - parseInt(sprite.width)*/			
				 ){				 
				  animateSprite(sprite);
				 }
				//if( sprite.type != 'ennemy' && sprite.type != 'punched' ){////////////alert(sprite.type)}
				
				
			if( sprite.type != 'graphic' ){ 
		 		  /*  TO BE MODIFIED */
				  // 
				  //  ITERATE balls COLLECTION TO TEST 
				  //  INTERACTIONS sprite VS ball
				  //  -- begin
				  let e_idx = 0; // ball index in balls
				  Array.prototype.some.call(balls, function (ball){					
					
					/*
						IF PADDLE IS INVINCIBLE
							ANIMATE THE FORCE FIELD AROUND IT
							-- begin
					*/			
					let invincibility = ball.invincibility
					if( invincibility > 0 ){
						
						var forceField = search( 'force-field-50x50.sprt', spriteFrames )
							forceField.x = ( ball.x + parseInt(ball.width)/2 ) - parseInt(forceField.width)/2,// center horiz
							forceField.y = ( ball.y + parseInt(ball.height)/2 ) - parseInt(forceField.height)/2,// center vert					 
							
							frameTicker = parseInt(ball.forceField.frameTicker),
							nextFrameAt = parseInt(ball.forceField.nextFrameAt),
							forceFieldFrame = parseInt(ball.forceField.frame)
							frameTicker ++
								
							if( frameTicker == nextFrameAt ){
								
								forceFieldFrame ++						
								
								if ( forceFieldFrame == parseInt(forceField.frameMax) ){
									 forceFieldFrame = 0
									 nextFrameAt ++ // LOWER THE FORCE FIELD ANIMATION FRAME RATE							 
								}
								
								ball.forceField.frame = forceFieldFrame
								ball.forceField.nextFrameAt = nextFrameAt						
								frameTicker = 0
							}					
							ball.forceField.frameTicker = parseInt(frameTicker)					
							forceField.drawOnCanvas = search('sky',ctxs)
							forceField.draw( forceFieldFrame, forceField.x, forceField.y, forceField.drawOnCanvas);
						
						// ball is invincible, decrease invincibility
						invincibility --
						ball.invincibility = parseInt(invincibility)				
					}
					/*
						IF PADDLE IS INVINCIBLE
							ANIMATE THE FORCE FIELD AROUND IT
							-- end
					*/
					
					
					//let ball = e					
					// ON COLLISION WITH THE ITERATED BALL ...
					
					  if( 
						  (ball.x >= sprite.x && ball.x < (sprite.x + sprite.width)		  		  
						  && ball.y + ball.height >= sprite.y && ball.y <= (sprite.y + sprite.height) )
						  ||
						  ( sprite.x >= ball.x && (sprite.x + sprite.width) < ball.x + ball.width		  		  
						  && sprite.y + sprite.height >= ball.y && sprite.y <= (ball.y + ball.height) )
					  ){  
						
						/*
							IF sprite.collisionBoundaries !== null
								IF ball WITHOUT BOUNDING BOX
									return // NO COLLISION
								ENDIF
							ENDIF
							
							BOUNDING BOX
								
						*/
						
						/*
						
						
						if( typeof sprite.hitboxes !== 'undefined' ){
							if( sprite.hitboxes.length > 0 ){
								var f = sprite.frame
								var hb = sprite.hitboxes[f]
								
								var hbx = parseInt(hb.x)
								var hby = parseInt(hb.y)
								var hbw = parseInt(hb.w)
								var hbh = parseInt(hb.h)
								var spritex = parseInt(sprite.x)
								var spritey = parseInt(sprite.y)
								
								if( sprite.rotation > 45 && sprite.rotation <= 90
									|| sprite.rotation > 225 && sprite.rotation <= 315
								){									
									hbx = parseInt(hb.y)
									hby = parseInt(hb.x)
									hbw = parseInt(hb.h)
									hbh = parseInt(hb.w)
									spritex = parseInt(sprite.y)
									spritey = parseInt(sprite.x)
								}
								
								var HSTotal = parseInt(spritex) + parseInt(hbx) + parseInt(hbw)
								var HBTotal = parseInt(ball.x) + parseInt(ball.width)													
								var VSTotal = parseInt(spritey) + parseInt(hby) + parseInt(hbh)
								var VBTotal = parseInt(ball.y) + parseInt(ball.height)
																								
								if( 
									(HBTotal > HSTotal)		  		  
								  ||(HBTotal < sprite.x)
								  ||(VBTotal > VSTotal)		  		  
								  ||(VBTotal < sprite.y)							  
								){  
									console.log(' NO COLLISION !')
									return false
								}
								else{
									//console.clear()
									console.log(' COLLISION !')
								}							
							}
						}*/
					 
					 /*
						THE SPRITE IS A SPEED CHANGER
							ball.dx = sprite.dx 
							ball.dy = sprite.dy
					 */
					 
					 if( 
						   sprite.type == 'speedChanger' 
						&& ball.name.indexOf('arrow') == -1 // is not affected by speedChanger
						&& ball.name.indexOf('portal') == -1 // is not affected by speedChanger
						){
							ball.dx = sprite.dx 
							ball.dy = sprite.dy								
					 }
					 
					 
					 if( 
						   sprite.type == 'obstacle'
						    && ball.type != 'obstacleBall'
							&& sprite.iDx != ball.iDx
							/*&& ball.metObstacle == false	*/
					 ){
							/*
							ball.x -= (ball.dx + sprite.dx)
							ball.y -= (ball.dy + sprite.dy)
							*/							
							if( ball.y + ball.height/2 < (sprite.y + sprite.height/2) ){
								ball.y = sprite.y - ball.height
							}else{
								ball.y = sprite.y + sprite.height
							}
							/*							
							if( ball.x + ball.width/2 < (sprite.x + sprite.width/2) ){
								ball.x = sprite.x - ball.width
							}else{
								ball.x = sprite.x + sprite.width
							}*/
							
							/*ball.dx *= -1 
							ball.dy *= -1*/
							ball.dx = (sprite.dx != 0) ? sprite.dx : -1 * ball.dx
							ball.dy = (sprite.dy != 0) ? sprite.dy : -1 * ball.dy
							ball.x += ball.dx
							ball.y += ball.dy
							ball.metObstacle = true
					 }
					 					
				     if( 
						   ball.type == 'obstacleBall' 
						    && sprite.type != 'obstacle'
							&& sprite.iDx != ball.iDx
							/*&& sprite.metObstacle == false*/			
					 ){		
							/*
							sprite.x -= (sprite.dx + ball.dx)
							sprite.y -= (sprite.dy + ball.dy)
							*/
							
							if( sprite.y + sprite.height/2 < (ball.y + ball.height/2) ){
								sprite.y = ball.y - sprite.height
							}else{
								sprite.y = ball.y + ball.height
							}
							/*
							if( sprite.x + sprite.width/2 < (sprite.x + sprite.width/2) ){
								sprite.x = sprite.x - sprite.width
							}else{
								sprite.x = sprite.x + sprite.width
							}*/							
							sprite.dx = (ball.dx != 0) ? ball.dx : -1 * sprite.dx
							sprite.dy = (ball.dy != 0) ? ball.dy : -1 * sprite.dy
							sprite.x += sprite.dx
							sprite.y += sprite.dy
							sprite.metObstacle = true							
					 }	
					 								
					 /*
						THE SPRITE IS A BUMPER					 
					 */
					 if( 
						   sprite.type == 'bumper'
						   /*&& ball.name.indexOf('arrow') == -1*/
						   && ball.type == 'punched'
					 ){
						
						if( typeof sprite.shaking =='undefined' 
							|| sprite.shaking == 0
						){		
							sprite.shaking = 10 
							sprite.archiveX = sprite.x		
							sprite.archiveY = sprite.y		
						}		
						
						ball.dx = -ball.dx *2
						ball.dy = -ball.dy *2
						
						/*
							IF BALL IS ENEMY PUNCHED
								MAKE IT STAY A PUNCHED BALL LONGER
						*/
						if( ball.type == 'punched'){							
							ball.alteredState *= 10
						}
												
						ball.x += ball.dx 
						ball.y += ball.dy	
						
					 }
					 
					
					  // ON COLLISION WITH THE BALL, SPRITE LOSES ENERGY
					  if( sprite.collideBallLoseEnergy == true ){
						//Score(sprite)
						
						var spriteX = parseInt(sprite.x),
							spriteY = parseInt(sprite.y)
						
						var paramsObject = {
							 x:spriteX,
							 y:spriteY,
							 width:parseInt(sprite.width),
							 height:parseInt(sprite.height)
							}
						
						
						if( 
							parseInt(ball.strength) > parseInt(sprite.resistance) 
							// arrows always damage enemies with collideBallLoseEnergy == true				
							|| ball.name.indexOf('arrow') != -1 
						){
							
							var c = {
								x:ball.x,
								y:ball.y,
								w:paramsObject.width,
								h:paramsObject.height,
								entityName:'small-collision-48x48.ent',								 
								iDx:ball.iDx
							}									
							collisionSparkle(c)
							
								// IMPACT SOUND - damage
								sounds[2].play()															
							
							var damage = parseInt(ball.strength) - parseInt(sprite.resistance)
							
							if (damage <= 0 && ball.strength > 0){ damage = 0 }
							
							sprite.energy -= damage							
							sprite.displayEnergy = 100
							
							/*
								IF THE COLLIDING BALL IS A PUNCHED ENEMY
								&& sprite.energy > 0
									TURN sprite INTO A punched ball
								ENDIF
							
							*/
							if( ball.type == 'punched' && sprite.energy > 0 ){
																
								balls[balls.length] = sprite
								
								sprites.splice( sprite_idx, 1)
								
								var newBall = balls[balls.length-1]
								newBall.type = 'punched' // will rotate and bounce
																
								//swapSprite(newBall,'PUNCHED')
								newBall.rotation = 5 //paddle.strength							  
								//newBall.energy = paddle.strength * 3 
								newBall.bounceHorizontally = true
								newBall.bounceVertically = true
								newBall.outOfHorizontalBoundaryRemove = false
								newBall.outOfVerticalBoundaryRemove = false
								newBall.collideWithPaddleBounce = true
								newBall.dx = Math.sign(ball.dx)
								newBall.dy = Math.sign(ball.dy)
								newBall.states = []	
								
								newBall.alteredState = ball.alteredState//10 * parseInt(paddle.strength) 
							}
							
							//sprite_idx
							/*
								INIT FADING OUT ENERGY POINTS
							*/
							var energyObject = {								
								color: [254,254,254],
								pointsAmount: damage,
								sign: -1,
								impactObject: ball //can be a ball or a sprite, used for its x,y,dx,dy
							}
							
							let isAlreadyDisplayed = energyObjects.filter(obj => {
							  return obj.iDx === iDx
							})
							
							if( isAlreadyDisplayed.length === 0 ){
								initEnergyPointFadeOut( energyObject )
							}
							
							Score(sprite)
							
							// SPRITE DIES
							if( sprite.energy < 1 ){
								
								// ADD THIS SPRITE TO THE LIST OF SPRITES ELIMINATED
								spritesEliminated [ spritesEliminated.length ] = sprite							
								spawnGoldCoins(sprite)							
														
								spawnEntityFromJson('disappear-600x100.ent',paramsObject)
								// deregister this sprite from sprites
								sprites.splice( sprite_idx, 1)
								 //////alert('THAT IS THE ONE '+4430)	
								checkRelevantObjectiveCompletion('targets')	
								

								if(damage > 0){		
									hitCombo(paramsObject)
								}
								return
							}
							
							if(damage > 0){		
								hitCombo(paramsObject)
							}
							
						}else{
							// IMPACT SOUND - no damage
							sounds[5].play()							
						}
						
						//hitCombo(paramsObject)
						
					  }
					// end - ON COLLISION WITH THE BALL, SPRITE LOSES ENERGY
					
					/*
						IF SPRITE IS AN "escorteeTarget"
						AND ball belongs to the list of escortees
						
					 */
										
					if( 
						isEscorteeInObjectives(ball.name) === true
						&& sprite.type == 'escorteeTarget' )
					{
						var paramsObject = {
						 x:ball.x,
						 y:ball.y,
						 width:parseInt(ball.width),
						 height:parseInt(ball.height)
						}								
						
						/*
							RANDOMLY PLAY
							1st or 2nd male or female 'thank you' sample
							if ball.name contains 'male' : play male sample
							if ball.name contains 'female' : play female sample
						*/
												
						if( ball.name.indexOf('male') != -1 || ball.name.indexOf('female') != -1){							
							var maleThx = [sounds[10],sounds[11]],
							    femaleThx = [sounds[12],sounds[13]]							
							list_sounds = (ball.name.indexOf('female') != -1)?[...femaleThx]:[...maleThx]							
							var sidx = getRandomArbitrary(0, list_sounds.length-1)
							console.log(sidx.toFixed(0))
							var snd = list_sounds[sidx.toFixed(0)]
							snd.play()
						}
												
						
						// add this ball to the list of escortess saved escorteesSaved[]
						escorteesSaved [ escorteesSaved.length ] = ball	

						ball.strength = 50
						// .strength is used to increase the amount of Gold
						spawnGoldCoins(ball)
						
						//spawnEntityFromJson('disappear-600x100.ent',paramsObject)
						//spawnEntityFromJson('combo-star-100x500.ent',paramsObject)
						
						// deregister this ball from balls[]
						removeObjectByItsIdxValue(balls,'iDx',ball.iDx)
						
						checkRelevantObjectiveCompletion( 'escortees' )	
						return 
					}
					
					
					 /*
						IF SPRITE IS NOT A BUMPER NOR "escorteeTarget"
					 */
					 if( sprite.type != 'bumper' && sprite.type != 'escorteeTarget'){	
						  
					  // IF BALL IS NOT INVINCIBLE
					  if ( invincibility <= 0 ){ 
					  
						  // BOUNCE THE BALL HORIZONTALLY
						  if( sprite.BounceBallHorizontally == true 
							&& ball.type != 'obstacleBall' 
							){			  
							if( ball.dx == 0 ){ ball.dx = getRandomArbitrary(-2, 2); }				
							ball.dx *= -1;
							ball.x += ball.dx*10;
							
							// BOUNCE SPRITE ON COLLISION WITH BALL
							 sprite.dx *= -1;
							//sprite.x -= parseInt(sprite.dx)
							//sprite.x = parseInt(sprite.x) - parseInt(ball.strength)
						  }			  
						  
						  // BOUNCE THE BALL VERTICALLY
						  if( sprite.BounceBallVertically === true 
						  && ball.type != 'obstacleBall'){ 
							 			  
							if( ball.dy == 0 ){ ball.dy = getRandomArbitrary(-2, 2); }	
					
							ball.dy *= -1; 
							ball.y += ball.dy*10;
							// BOUNCE SPRITE ON COLLISION WITH BALL
							sprite.dy *= -1;  
							////////////alert(parseInt(sprite.dy))
							sprite.y = parseInt(sprite.y) - 1//parseInt(ball.strength)
						  }
					  
						  // REMOVE THE BALL
						  if( sprite.collideBallRemoveBall === true ){							
							
								if( stageEnded === false
									&& stage.ingame === true
									) {
										lose_one_ball(e_idx)									
										return
									}
						  }
						 
						
						  
						  // ATTACK THE BALL, IF BALL'S ENERGY < 0, REMOVE THE BALL
						  if( sprite.collideBallAttacksBall === true ){	
								
							if( 
								invincibility <= 0
							){	

								// IF ENNEMY's STRENGTH > BALL's RESISTANCE					
								if( parseInt(ball.resistance) < parseInt(sprite.strength) ){
									
									var damage = parseInt(sprite.strength) - parseInt(ball.resistance)
										ball.energy -= damage									

									if( ball.name.indexOf('arrow') == -1 ){
										/*
											INIT FADING OUT ENERGY POINTS
										*/
										var energyObject = {								
											color: [254,254,0],
											pointsAmount: damage,
											sign: -1,
											impactObject: sprite //can be a ball or a sprite, used for its x,y,dx,dy
										}

										
										let isAlreadyDisplayed = energyObjects.filter(obj => {
										  return obj.iDx === iDx
										})
										
										if( isAlreadyDisplayed.length === 0 ){
											initEnergyPointFadeOut( energyObject )
										}																			
										
										ball.x -= Math.sign(sprite.dx) * 10
										ball.y -= Math.sign(sprite.dy) * 10
									
										// OUCH								
										sounds[8].play()
									
									}// ball is not arrow 
									else{
										// MISS!
										//if( parseInt(ball.strength) < parseInt(sprite.resistance) ){
											sounds[5].play()						
										//}	
									}
									
									if( ball.energy < 0 ){																				
										if( stageEnded === false
										&& stage.ingame === true
										) {
											lose_one_ball(e_idx)									
											return
										}	
									} // ball.energy < 0
								
								}
															
							}// IF BALL IS NOT INVINCIBLE
																					
						  }
						 
					  }
					  
					}
					/* IS SPRITE IS NOT A BUMPER NOR A "escorteeTarget" */
					  
				  }// ON COLLISION WITH THE ITERATED BALL ...
				e_idx++;
				
			  })// Array.prototype.some.call(balls, (e){
			  
			}// end if( sprite.type == 'ennemy' )
				  	
				  
				  // 
				  //  ITERATE balls COLLECTION TO TEST 
				  //  INTERACTIONS sprite VS ball
				  //  -- end
				  
				  //animateSprite(sprite); 
				  //collisionDetection(sprite);// TO BE REMOVED
				  
				  // 
				  //  INTERACTIONS sprite VS paddle
				  //  -- begin
				  
				  /*
					THE SPRITE IS A POWERUP -- begin
				  */
				  if( sprite.type == 'powerup' ){
					  
					  if( 
						  (sprite.x >= paddleX && sprite.x < (paddleX + paddleWidth)		  		  
						  && sprite.y + sprite.height >= paddleY && sprite.y <= (paddleY + paddleHeight) )
						  ||
						  ( paddleX >= sprite.x && (paddleX + paddleWidth) < sprite.x + sprite.width		  		  
						  && paddleY + paddleHeight >= sprite.y && paddleY <= (sprite.y + sprite.height) )
					  ){	
						  
						/*
							NOTE: sprite => power-up object 
							  sprt => character selected sprite	xxx.sprt
							see below
						*/
						/*
							SET paddle.weaponEquippedDuration (HOW LONG THE WEAPON REMAINS EQUIPPED)
							- BASED ON DEFAULT VALUES
							- IF duration can be elevated, then this has to be updated						
						*/ 
						// IF power-up IS NOT A GOLD COIN, THEN EQUIP IT
						if( sprite.name != 'gold-coin-12.5x13.ent'){
														
							var weapon = items.filter(function(weapon){								
								return weapon.entityName == sprite.name
							})
							
							paddle.WED = paddle.weaponEquippedDuration
							paddle.weaponEquippedDuration = weapon[0].duration  
							
							// EQUIP paddle WITH WEAPON
							paddleEquipWeapon(sprite.name)
							
						}
						else{
							// SPRITE IS NOT A GOLD COIN
							stage.earnedGold++
							sounds[7].play()							
							document.querySelector('#UI_wrapper .gold').textContent	= stage.earnedGold	
						}
						  // unregister the powerup sprite from sprites						  
						  sprites.splice( sprite_idx, 1)
						   //////alert('THAT IS THE ONE '+4679)	
						}// END IF WITHIN HITBOX
				  }// IF POWER-UP
				  /*
					THE SPRITE IS A POWERUP -- end
				  */
			

					if( sprite.type != 'bumper'){			
						 
						  // BOUNCE HORIZONTALLY WHEN OUT OF HORIZONTAL LIMITS
						  if( sprite.bounceHorizontally == true ){	  
							  if( 
									( 
										sprite.x + sprite.dx > canvas.width - sprite.width
									&& sprite.dx > 0 
									)
								 || 
									(
										sprite.x + sprite.dx < 0
									&& sprite.dx < 0
									)
							  ){						
								sprite.dx = -sprite.dx;	
								swapSprite(sprite)						
							  }
						  }
						  
						  // BOUNCE VERTICALLY WHEN OUT OF VERTICAL LIMITS
						  if( sprite.bounceVertically == true ){				  
							  if( 
									( 
										sprite.y + sprite.dy > Number.parseInt(canvas.style.top) + canvas.height - sprite.height
									&& sprite.dy > 0 
									)
								|| 
									(
										sprite.y + sprite.dy < Number.parseInt(canvas.style.top) 
									&& sprite.dy < 0
									)
							  ){
								sprite.dy = -sprite.dy;
								swapSprite(sprite)					
							  }
						  }
						  
						  // DISAPPEAR WHEN OUT OF CANVAS HORIZONTAL LIMIT
						  if( sprite.outOfHorizontalBoundaryRemove == true ){				 
							  if( 
									( 
										sprite.x > Number.parseInt(canvas.style.left) + canvas.width 
									&& sprite.dx > 0 
									)
								 || 
									(
										sprite.x < Number.parseInt(canvas.style.left) - sprite.width 
									&& sprite.dx < 0
									)
							  ){							
									// deregister this sprite from sprites
									sprites.splice( sprite_idx, 1)							
									//////alert('THAT IS THE ONE - 4737')
							  }
						  }
							
						  // DISAPPEAR WHEN OUT OF CANVAS VERTICAL LIMIT
						  if( sprite.outOfVerticalBoundaryRemove == true ){
							  if( 
									( 
										sprite.y > Number.parseInt(canvas.style.top) + canvas.height 
									&& sprite.dy > 0 
									)
								 || 
									(
										sprite.y < Number.parseInt(canvas.style.top) - sprite.height 
									&& sprite.dy < 0
									)
							  ){
									// deregister this sprite from sprites
									sprites.splice( sprite_idx, 1)
									//////alert('THAT IS THE ONE - 4755')
							  }
						  }
						  
						  // IF ENTITY COLLIDE WITH PADDLE WHEN PADDLE HAS GLOVES
						  //  sprite.type != 'graphic' && sprite.type != 'powerup'
					}
				  
				  
					  if( sprite.type == 'enemy' ){	
					  
						  if( 
							  (sprite.x >= (paddleX - sprite.width) && sprite.x < (paddleX + paddleWidth)		  		  
							  && sprite.y + sprite.height >= paddleY && sprite.y <= (paddleY + paddleHeight) )
							  ||
							  ( paddleX >= (sprite.x - paddleWidth) && (paddleX + paddleWidth) < sprite.x + sprite.width		  		  
							  && paddleY + paddleHeight >= sprite.y && paddleY <= (sprite.y + sprite.height) )
						  ){
							
								/*
									IF sprite.collisionBoundaries !== null
										IF ball WITHOUT BOUNDING BOX
											return // NO COLLISION
										ENDIF
									ENDIF
									
									BOUNDING BOX
										
								*/
								/*
								if( typeof sprite.hitboxes !== 'undefined' ){
									if( sprite.hitboxes.length > 0 ){
																		
										var f = sprite.frame
										var hb = sprite.hitboxes[f]
										
										var hbx = parseInt(hb.x)
										var hby = parseInt(hb.y)
										var hbw = parseInt(hb.w)
										var hbh = parseInt(hb.h)
										var spritex = parseInt(sprite.x)
										var spritey = parseInt(sprite.y)
										
										if( sprite.rotation > 45 && sprite.rotation <= 90
											|| sprite.rotation > 225 && sprite.rotation <= 315
										){									
											hbx = parseInt(hb.y)
											hby = parseInt(hb.x)
											hbw = parseInt(hb.h)
											hbh = parseInt(hb.w)
											spritex = parseInt(sprite.y)
											spritey = parseInt(sprite.x)
										}										
										
										var HSTotal = parseInt(sprite.x) + parseInt(hbx) + parseInt(hbw)
										var HBTotal = parseInt(paddleX) + parseInt(paddleWidth)													
										var VSTotal = parseInt(sprite.y) + parseInt(hby) + parseInt(hbh)
										var VBTotal = parseInt(paddleY) + parseInt(paddleHeight)	
										
										if( 
											(HBTotal > HSTotal)		  		  
										  ||(HBTotal < sprite.x)
										  ||(VBTotal > VSTotal)		  		  
										  ||(VBTotal < sprite.y)							  
										){  
											console.log(' 4834 - NO COLLISION !')
											//return -- BUGGY
										}
										else{
											console.log(' COLLISION ! ')
										}
									}
								}*/
								
								/*
									ROTATE THE PADDLE
									TO FOLLOW THE POSITION OF THE ENEMY COLLIDED
								*/								
								paddle.rotation = 0
								paddle.rotating = 0
								
								if(
									paddle.weapon == 'gloves'
									|| paddle.weapon == 'swordAndShield'
								){	
								
									if( (sprite.y) > paddleY+paddleHeight/2){
										paddle.rotation = 180
										if( (sprite.x+(sprite.width/2)) > paddleX+(paddle.width/2)){
											paddle.rotation = 135										
										}
										if( (sprite.x+(sprite.width/2)) < paddleX+(paddle.width/2)){
											paddle.rotation = 225										
										}
										paddle.rotating = 1										
									} else if( (sprite.y) <= paddleY+paddleHeight/2){
										paddle.rotation = 0
										if( (sprite.x+(sprite.width/2)) > paddleX+(paddle.width/2)){
											paddle.rotation = 45										
										}
										if( (sprite.x+(sprite.width/2)) < paddleX+(paddle.width/2)){
											paddle.rotation = 315										
										}
										paddle.rotating = 1										
									}
								}
								
								/*
									END ROTATE THE PADDLE
									TO FOLLOW THE POSITION OF THE ENEMY COLLIDED
								*/	
								
								
								/*
								
									BOXING GLOVES ALWAYS REACH ENEMIES
								
								*/
								
								// IF THE ANGEL HAS BOXING GLOVES
									// PUNCH ENNEMY AWAY
									// TURN IT INTO A BALL
									if( paddle.weapon == 'gloves' ){							  
										Score(sprite)								  
																		  
										var paramsObject = {
											 x:parseInt(sprite.x),
											 y:parseInt(sprite.y),
											 width:parseInt(sprite.width),
											 height:parseInt(sprite.height)
										}
										
										
										var damage = parseInt(paddle.strength) - parseInt(sprite.resistance)										
										if( damage < 1){ 										
											damage = 0
										}
										
										//damage = 0// collision with gloves does no damage									
										
										sprite.energy -= damage
										sprite.displayEnergy = 50 // how long the energy bar will show up
										//
										//	INIT FADING OUT ENERGY POINTS
										//
										var energyObject = {								
											color: [254,254,254],
											pointsAmount: damage,
											sign: -1,
											impactObject: sprite //can be a ball or a sprite, used for its x,y,dx,dy
										}
										
										
										// IF THIS PUNCH KILLS THE SPRITE IN ONE BLOW, SPRITE DIES
										if( sprite.energy < 1){	
											// ADD THIS SPRITE TO THE LIST OF SPRITES ELIMINATED
											spritesEliminated [ spritesEliminated.length ] = sprite							
											spawnGoldCoins(sprite)
											// deregister this sprite from sprites
											sprites.splice( sprite_idx, 1)	
											//////alert('THAT IS THE ONE '+4934)											
											checkRelevantObjectiveCompletion('targets')							
											spawnEntityFromJson('disappear-600x100.ent',paramsObject)
											
											//hitCombo(paramsObject)
											sprite_idx++; // iterate next sprite
											return
										}
																				
										var iDx = sprite.iDx
										if(damage > 0){	
											// WHACK PUNCH
											sounds[6].play();

											let isAlreadyDisplayed = energyObjects.filter(obj => {
											  return obj.iDx === iDx
											})
											
											if( isAlreadyDisplayed.length === 0 ){
												initEnergyPointFadeOut( energyObject )
											}
											
											if( sprite.metObstacle != true ){
												sprite.x -= Math.sign(sprite.dx) * 10
												sprite.y -= Math.sign(sprite.dy) *10
											}
										
											hitCombo(paramsObject)
										
										
											balls[balls.length] = sprite
											
											
											sprites.splice( sprite_idx, 1)								  
											var newBall = balls[balls.length-1];
											newBall.type = 'punched' // will rotate and bounce
											
											/*
												newBall.iDx 
												WILL BE USED TO DELETE 
												THIS BALL WHEN RELEVANT
												newBall.iDx  
												MUST BE UPDATED WHEN 
												A sprite BECOMES a ball
												OR 
												A ball BECOMES a sprite
											*/
											newBall.iDx = iDx/*newBall.name+'-'+Date.now()*/					
											//swapSprite(newBall,'PUNCHED')
											
											// WHEN PUNCHED ENNEMIES HAVE SOME ATTRIBUTES MODIFIED
												
											//- their speed increases
											//- when they collide with the stage boundaries they bounce					
											//- they can bounce up 3 three times  
											//- they keep rotating
											
											// increase speed
											//newBall.dx = Math.sign(newBall.dx) * 10 * -1
											//newBall.dy = Math.sign(newBall.dy) * 10 * -1
											
											//newBall.dx = Math.sign(newBall.dx) * 2
											//newBall.dy = Math.sign(newBall.dy) * 2
											
											newBall.rotation = 5 //paddle.strength							  
											//newBall.energy = paddle.strength * 3 
											newBall.bounceHorizontally = true
											newBall.bounceVertically = true
											newBall.outOfHorizontalBoundaryRemove = false
											newBall.outOfVerticalBoundaryRemove = false
											newBall.collideWithPaddleBounce = true
											newBall.dx = 0;//Math.sign(newBall.dx) * 1
											newBall.dy = 0;//Math.sign(newBall.dy) * 1
											newBall.states = []
											
											//
											//	HOW LONG THIS ENTITY WILL BE A BALL:
											//	alteredState
											//	
											//	DEPENDS ON paddle.strength
											//	
											//
											newBall.alteredState = 1 +  parseInt(paddle.strength) * parseInt(paddle.strength) 										
											
											var dataObject = {
												ball:newBall,
												blX:newBall.x,
												blY:newBall.y,
												blW:newBall.width,
												blH:newBall.height,
												blDx:newBall.dx,
												blDy:newBall.dy,
												brX:paddleX,				
												brY:paddleY,
												brW:paddleWidth,
												brH:paddleHeight,
												bounceAgainst: 'paddle'
											} 

											var c = {
												x:dataObject.blX,
												y:dataObject.blY,
												w:dataObject.blW,
												h:dataObject.blH,
												entityName:'small-collision-48x48.ent',								 
												iDx:iDx								
											}									
											collisionSparkle(c)

											// BOUNCE ENNEMY BECOME A BALL
											bounceObject(dataObject)
											sprite_idx++										
											return 
										
										}// if(damage > 0){	
										else{
											
											let isAlreadySparkled = combosObjects.filter(obj => {
											  return obj.iDx === iDx
											})
											
											if( isAlreadySparkled.length === 0 ){												
												var c = {
													x:sprite.x,
													y:sprite.y,
													w:sprite.w,
													h:sprite.h,
													/*entityName:'small-collision-48x48.ent',*/
													fillStyle: ' rgba(128,128,128,1)',
													txt: 'too weak!',
													type: 'msg',								 
													iDx:iDx,
													duration: 50
												}									
												collisionSparkle(c)
												if(
													sprite.type.indexOf('obstacle') == -1
													&& ball.type.indexOf('obstacle') == -1
												){
													sounds[1].play();// missed
												}
										}
											
										}
										
										
									} // if( paddle.weapon == 'gloves' ){
								/*
									PADDLE DAMAGES SPRITE
									
										- PADDLE HAS ALWAYS AN ADVANTAGE ON SPRITES:
										  if paddle.resistance == sprite.resistance
										  || 
										  if paddle.strength == sprite.strength 
											PADDLE DAMAGES SPRITE
									
								*/
								else if( parseInt(paddle.strength) >= parseInt(sprite.resistance) 
									//&& parseInt(paddle.strength) >= parseInt(sprite.strength)									
								){
									//////alert('THAT IS THE ONE '+5038)		
									if( paddle.weapon == 'swordAndShield' ){
													
										Score(sprite)								  
										//IMPACT
										sounds[5].play();

										var paramsObject = {
										 x:parseInt(sprite.x),
										 y:parseInt(sprite.y),
										 width:parseInt(sprite.width),
										 height:parseInt(sprite.height)
										}

										var dataObject = {
											ball:sprite,
											blX:sprite.x,
											blY:sprite.y,
											blW:sprite.width,
											blH:sprite.height,
											blDx:sprite.dx,
											blDy:sprite.dy,
											brX:paddleX,				
											brY:paddleY,
											brW:paddleWidth,
											brH:paddleHeight,
											bounceAgainst: 'paddle'
										} 

										var c = {
											x:dataObject.blX + dataObject.blW/2,
											y:dataObject.blY,
											w:dataObject.blW,
											h:dataObject.blH,
											entityName:'small-collision-48x48.ent',								 
											iDx:iDx								
										}

										collisionSparkle(c)	
										
										var damage = parseInt(paddle.strength) - parseInt(sprite.resistance)
										
										if( damage < 1){  damage = 0; }
										
										sprite.energy -= damage
										sprite.displayEnergy = 100
										/*
											INIT FADING OUT ENERGY POINTS
										*/
										var energyObject = {								
											color: [254,254,254],
											pointsAmount: damage,
											sign: -1,
											impactObject: sprite //can be a ball or a sprite, used for its x,y,dx,dy
										}
										
										let isAlreadyDisplayed = energyObjects.filter(obj => {
										  return obj.iDx === iDx
										})
										
										if( isAlreadyDisplayed.length === 0 ){
											initEnergyPointFadeOut( energyObject )
										}
										
										sprite.x -= Math.sign(sprite.dx) * 10
										sprite.y -= Math.sign(sprite.dy) *10
										
										// SPRITE DIES
										if( sprite.energy < 1 ){
																				
											// ADD THIS SPRITE TO THE LIST OF SPRITES ELIMINATED
											spritesEliminated [ spritesEliminated.length ] = sprite							
											spawnGoldCoins(sprite)
											sprites.splice( sprite_idx, 1)	

											//////alert('THAT IS THE ONE '+5109)		
											
											checkRelevantObjectiveCompletion('targets')							
											spawnEntityFromJson('disappear-600x100.ent',paramsObject)
											// deregister this sprite from sprites
											
											if(damage > 0){		
												hitCombo(paramsObject)
											}
											 sprite_idx++; // iterate next sprite
											return 
										}		
											
										if(damage > 0){		
											hitCombo(paramsObject)
										}
												
										bounceObject(dataObject)
											
										  //continue
									} // if( paddle.weapon == 'swordAndShield' ){	
								
								}// END IF paddle.strength > sprite.resistance
								
								
								/*
									SPRITE DAMAGES PADDLE
								*/
								else if( parseInt(sprite.strength) > parseInt(paddle.resistance) 
									&& parseInt(sprite.strength) > parseInt(paddle.strength)
									&& sprite.collidePaddleAttacksPaddle === true
								){
									//////alert(5133+' paddle TAKES DAMAGE !')
									//
									//	IF sprite.strength > paddle.resistance
									//		paddle TAKES DAMAGE
									//
									
									let invincibility = parseInt(paddle.invincibility)
									
									if( 
										invincibility <= 0
									){	

											
										var damage = parseInt(sprite.strength) - parseInt(paddle.resistance)
											if( damage < 1){ damage = 0 }

										//
										//	INIT FADING OUT ENERGY POINTS
										//
										var energyObject = {								
											color: [254,254,0],
											pointsAmount: damage,
											sign: -1,
											impactObject: sprite //can be a ball or a sprite, used for its x,y,dx,dy
										}
										
										let isAlreadyDisplayed = energyObjects.filter(obj => {
										  return obj.iDx === iDx
										})
										
										if( isAlreadyDisplayed.length === 0 ){
											initEnergyPointFadeOut( energyObject )
										}
										
										paddle.energy -= damage
										
										console.log('paddle.energy:'+paddle.energy)
										
										// SOUND OUCH ! -- WILL BE CHANGED
										sounds[0].play()

										if( paddle.energy < 1 ){						
											//stage.casualties ++										
											lives --;// remove one life
											
											if( lives <= 0 ) {
												lives = 0
											}
											
											writeLives();// INGAME UI UPDATE lives FIELD
											
											
											// UPDATE DB.character.lives  						
											db.character.lives = db.character.where({profileId:1}).modify({lives:lives}) 
											.then(()=>{
											
											// 
											//	paddle RUNS OUT OF ENERGY,
											//	LOSE AS lIFE
											//	
											
											if( lives <= 0 ) {
												
												// PAUSE, THEN STOP EVERYTHING
												cancelAnimationFrame(myReq)
												// STOP ALL PLAYING SOUNDS
												stopAllPlayingSounds()				
												// IF RAF LOOPING, THEN EXIT IT
												
												// RESET lives TO 0
												lives = 0
												
												writeLives();// INGAME UI UPDATE lives FIELD
												stagePayToContinueSpawn()
																								
											}
											else{
											//
											//	LIVES REMAINING
											//	GIVE THE PADDLE A FORCEFIELD (invincibility)
											//	AND UPDATE LIVES STOCK
											//											
												// GIVE PADDLE A FORCE FIELD
												paddle.invincibility = paddleInvincibilityTime											
												paddle.forceField = {}
												paddle.forceField.frame = 0											 
												paddle.forceField.nextFrameAt = 1
												paddle.forceField.frameTicker = 0
												
												// REFILL PADDLE ENERGY LEVEL
												paddle.energy = profile.character.energy
												sounds[9].play()// angel wooooo
												//drawLives(); // draw lives											
											}
											
											})// then()
											
											
										}// if( paddle.energy < 1 ){
										else{											
																						
											if( paddle.weapon.indexOf('swordAndShield') != -1 ){
												let isAlreadySparkled = combosObjects.filter(obj => {
												  return obj.iDx === iDx
												})
												
												if( isAlreadySparkled.length === 0 ){												
													var c = {
														x: sprite.x,
														y: sprite.y,
														w: sprite.w,
														h: sprite.h,
														/*entityName:'small-collision-48x48.ent',*/
														fillStyle: ' rgba(128,128,128,1)',
														txt: 'too weak!',
														type: 'msg',								 
														iDx: iDx,
														duration: 50
													}									
													collisionSparkle(c)
													if( typeof sprite != 'undefined' ){
														if( sprite.type.indexOf('obstacle') == -1
															&& ball.type.indexOf('obstacle') == -1){
															sounds[1].play();// missed
														}
													}
												}
											}
	
										}	
											
									}// if invincibility < 0
									
								}// if( parseInt(sprite.strength) > parseInt(paddle.resistance) ){
							
							}// END IF paddle & sprite COLLIDE
							
					  }// END IF sprite.type == 'enemy'
				
				  
				  if( sprite.type != 'bumper' && sprite.type != 'escorteeTarget'){	
				  
				  // ENTITY LOSES ENERGY WHEN COLLIDE WITH PADDLE
				  if( sprite.collidePaddleLoseEnergy === true ){					  
					 if( 
							  (sprite.x >= (paddleX - sprite.width) && sprite.x < (paddleX + paddleWidth)		  		  
							  && sprite.y + sprite.height >= paddleY && sprite.y <= (paddleY + paddleHeight) )
							  ||
							  ( paddleX >= (sprite.x - paddleWidth) && (paddleX + paddleWidth) < sprite.x + sprite.width		  		  
							  && paddleY + paddleHeight >= sprite.y && paddleY <= (sprite.y + sprite.height) )
						  ){
						
							 var damage = paddle.strength - sprite.resistance
							 if( paddle.weapon !='' ){					

								if( damage == 0 ){												 
									sprite.energy -= damage
									sprite.displayEnergy = 100
									
									 Score(sprite)
						  
								    var paramsObject = {
										 x:parseInt(sprite.x),
										 y:parseInt(sprite.y),
										 width:parseInt(sprite.width),
										 height:parseInt(sprite.height)
									}
									if(damage > 0){		
										hitCombo(paramsObject)
									}								
								}
							 }
						  
						  
						  if( sprite.energy < 1 ){
							 
							// ADD THIS SPRITE TO THE LIST OF SPRITES ELIMINATED
							spritesEliminated [ spritesEliminated.length ] = sprite
							
							// deregister this sprite from sprites
							sprites.splice( sprite_idx, 1)
							
							//////alert('THAT IS THE ONE '+5337)	
							
							checkRelevantObjectiveCompletion('targets')
							
							
							//	GENERATES IT IN THE MIDDLE OF THE SCREEN
							
							spawnEntityFromJson('disappear-600x100.ent',Location)
							 sprite_idx++; // iterate next sprite
							return 
						   }
					  }
				    }// if( parseInt(paddle.strength)  > parseInt(sprite.resistance) ){
				 
				  // DESTROY SPRITE ON COLLISION WITH THE PADDLE
				  if( sprite.type != 'escorteeTarget' && sprite.collideWithPaddleRemove === true ){
					  if( 
						  (sprite.x >= (paddleX - sprite.width) && sprite.x < (paddleX + paddleWidth)		  		  
						  && sprite.y + sprite.height >= paddleY && sprite.y <= (paddleY + paddleHeight) )
						  ||
						  ( paddleX >= (sprite.x - paddleWidth) && (paddleX + paddleWidth) < sprite.x + sprite.width		  		  
						  && paddleY + paddleHeight >= sprite.y && paddleY <= (sprite.y + sprite.height) )
					  ){
						Score(sprite)
						var paramsObject = {
								 x:parseInt(sprite.x),
								 y:parseInt(sprite.y),
								 width:parseInt(sprite.width),
								 height:parseInt(sprite.height),								 
								 iDx:iDx
								}
							hitCombo(paramsObject)		
							
							// ADD THIS SPRITE TO THE LIST OF SPRITES ELIMINATED
								spritesEliminated [ spritesEliminated.length ] = sprite
							
						  // deregister this sprite from sprites
							sprites.splice( sprite_idx, 1)
							//////alert('THAT IS THE ONE '+5374)	
							checkRelevantObjectiveCompletion('targets')
							
							spawnEntityFromJson('disappear-600x100.ent',Location)
							 sprite_idx++; // iterate next sprite
							return
					  }
				  }
				  
				  
				  // BOUNCE SPRITE ON COLLISION WITH THE PADDLE
				  if( sprite.collideWithPaddleBounce === true ){
					  if( 
							  (sprite.x >= (paddleX - sprite.width) && sprite.x < (paddleX + paddleWidth)		  		  
							  && sprite.y + sprite.height >= paddleY && sprite.y <= (paddleY + paddleHeight) )
							  ||
							  ( paddleX >= (sprite.x - paddleWidth) && (paddleX + paddleWidth) < sprite.x + sprite.width		  		  
							  && paddleY + paddleHeight >= sprite.y && paddleY <= (sprite.y + sprite.height) )
						  ){	
							var dataObject = {
									ball:sprite,
									blX:sprite.x,
									blY:sprite.y,
									blW:sprite.width,
									blH:sprite.height,
									blDx:sprite.dx,
									blDy:sprite.dy,
									brX:paddleX,				
									brY:paddleY,
									brW:paddleWidth,
									brH:paddleHeight,
									bounceAgainst: 'paddle'
								} 
							  
							  bounceObject(dataObject)
								////alert('BOUNCED!')
						  sprite.x += sprite.dx //* sprite.width;
						  sprite.y += sprite.dy //* sprite.height; 
					  }
				  }
				  
				  // 
				  //  INTERACTIONS sprite VS paddle
				  //  -- end
				  
				  
				  /*
					 IF sprite.type NOT speedChanger
						MOVE sprite						
				  
				  if( sprite.type != 'speedChanger'){				  
					  // MOVE THE SPRITE
					  sprite.x += sprite.dx ;
					  sprite.y += sprite.dy ; 
				  }*/
				  	  
				  // 
				  //  IF ENTITY HAS PATH, FOLLOW IT
				  //
				  if(sprite.path != -1 ){
					  if( typeof entityObj !== 'brickwall') {
						moveEntity( sprite ) 
					  }
					  sprite.x += Number(sprite.px) ;
					  sprite.y += Number(sprite.py) ;
				  }
				  
				}//if( sprite.type != 'bumper'){		
                  
				  
				  /*
					 IF sprite.type NOT speedChanger
						MOVE sprite						
				  */
				  if( sprite.type != 'speedChanger'){				  
					  // MOVE THE SPRITE
					  sprite.x += sprite.dx ;
					  sprite.y += sprite.dy ; 
				  }
				
				  sprite_idx++; // iterate next sprite
			  })// Array.prototype.some.call(sprites, function (sprite){
			  
			  
			}// if (sprites.length > 0)
			
			
		
		}// end moveSprites()
			
			
		window.removeObjectByItsIdxValue = function(myArray,field,val){	
			/*myArray = myArray.filter(function( obj ) {
				
				////////alert(obj[field])
				
				return obj.iDx !== val;
			});
			*/
			console.clear()
			console.log(myArray)
			console.log(myArray.length)
			
			for (var i = balls.length - 1; i >= 0; --i) {
				if (balls[i].iDx === val) {
					balls.splice(i,1);
				}
			}
			console.log(myArray.length)
			////////alert(';')
			return
		}
		
//drawComboStar(Canvas, x, y, spikes, outerRadius, innerRadius, strokeStyle, fillStyle, txt, rot)		
		
		function collisionSparkle(dataObject){	
			
			/*
				IF A SPARKLE RELATED TO THE OBJECT WITH iDx = dataObject.iDx IS ALREADY DISPLAYED 
				DO NOT SPARKLE IT AGAIN
			*/
			let isAlreadySparkled = combosObjects.filter(obj => {
			  return obj.iDx === dataObject.iDx
			})
			if( isAlreadySparkled.length > 0 ){
				return;
			}
						
			var txt = false,
				Type = undefined,
				fillStyle = ' rgba(255,255,0,1)',//default color: yellow				
				duration = 20
				
			// COLLISION SPARKLE
			var c = dataObject			
			// spawnEntityFromJson(dataObject.entityName,c)
					
					
			if(typeof c.fillStyle !== 'undefined')	{
				fillStyle  = c.fillStyle
			}
				
			if(typeof c.txt !== 'undefined')	{
				txt  = c.txt
			}
			
			if(typeof c.type !== 'undefined')	{
				Type  = c.type
			}
			
			if(typeof c.duration !== 'undefined')	{
				duration  = c.duration
			}
					
			var cbo = {
				x:c.x,
				y:c.y,				
				spikes: 10,
				outerRadius: 8, 
				innerRadius: 5, 
				strokeStyle: '#fff', 
				fillStyle: fillStyle, 
				txt: txt,
				type: Type,
				duration: duration,
				rot:0,
				iDx:c.iDx
			}	
			
			combosObjects.push(cbo) 
	 		 
		}
		
		
		//
		//  moveEntity()
		//  
		//	NOTE: an entity is either a sprite or a brickwall
		//
		//  DOES : iterate through the waypoints collection 
		//         and changes the values of: 
		//			 
		//			 for wallbrick (see in main loop)
		//			     brickOffsetLeft
		//			 &&  brickOffsetTop
		//			 
		//			 for sprites 
		//				sprite.px
		//				sprite.py
		//	 
		//	 
		//  PARAMS: entityObj - required
		//          object that is going to be moved according to its attributes
		//          (x, y, path, pathStep, pathIdx, pathMode)
		// 
		//
		 
function moveEntity( entityObj ){ 

		 
		
		 // ////////////alert('moveEntity():'+JSON.stringify(entityObj)) //-- NOT COMING HERE
		  //
		  ///  GET THE OBJECT'S ATTRIBUTES:
		  //    - waypoints: path this object follows
		  //    - pathIdx: index of path currently itterated
		  //    - pathStep: increment of pathIdx
		  //    - pathMode: 
		  //                'absolute' : move object to x,y 
		  //                'relative' : move object horizontally by x
		  //                             move object vertically by y
		  //		  
		  /*
			GET PATH NAME FROM 
				ENTITY OBJECT
		  */
		  let pathName = entityObj.path,
			  pathEnd =  entityObj.pathEnd,  
			  pathIdx = entityObj.pathIdx,
			  pathStep = entityObj.pathStep,
			  pathMode = entityObj.pathMode,	
			  px = entityObj.px,
			  py = entityObj.py			  
			
		//////////////alert('moveEntity():'+JSON.stringify(entityObj))
			
		  let pathData = search (pathName, path)
		  
		  if( typeof( pathData ) ==='undefined' ){return}
		  
/*
		  console.log(
			 '2028 \r\n'
			+'pathName: '+pathName+'\r\n'
			+'pathData: '+pathData+'\r\n'			
		  )
	*/	  
		  
		  
		  let waypoints = [...pathData.path_coords]
		  
		  pathIdx = parseInt(pathIdx) + parseInt(pathStep)
		  		  
		   //console.log('entityObj \r\n'+JSON.stringify(entityObj))
		   
		   console.log(
			 'pathEnd: '+pathEnd+'\r\n'
			+'pathName: '+pathName+'\r\n'
			+'pathData: '+pathData+'\r\n'			
			+'pathIdx: '+pathIdx+'\r\n'			
			+'pathStep: '+pathStep+'\r\n'			
			+'waypoints: '+waypoints+'\r\n'			
			+'waypoints.length: '+waypoints.length+'\r\n'	
			+'waypoints[0][0]: '+waypoints[0][0]+'\r\n'					
			+'waypoints[0][1]: '+waypoints[0][1]+'\r\n'					
		  )
		  
		  
		  if ( pathStep > 0 && pathIdx >= waypoints.length-1){
			  
			  /* STOP path */
			  if(  typeof pathEnd === 'undefined' || pathEnd == 'stop' ){				  
				  entityObj.pathStep = 0
				  entityObj.path = -1
				  entityObj.pathIdx = 0;
				  return true				  
			  }
			  else if( pathEnd == 'loop'){
				/*  LOOP */							  
				  pathIdx = 0				 
			  }			  		  
			  else if( pathEnd == 'reverseLoop' ){
				// LOOP THE OTHER WAY AROUND
				/*  REVERSE */
				if ( pathIdx >= waypoints.length-1 ){
				  pathStep = -1
				  pathIdx = waypoints.length-1				 
				}
			  }
			  
			  //alert('CHANGED!'+'\r\n pathStep:'+pathStep+'\r\n pathIdx:'+pathIdx)
			 
		   }
		   
		   else if ( pathStep < 0 && pathIdx <= 0){			
		   
			  /* STOP path */	
			  if( pathEnd == 'stop' ){				  
				  entityObj.pathStep = 0
				  entityObj.path = -1
				  entityObj.pathIdx = 0;
				  return true				  
			  }			   
			  // START THE LOOP OVER
			  else if( pathEnd == 'loop' || typeof pathEnd === 'undefined'){
				/*  LOOP */							  
				  pathIdx = waypoints.length-1				 
			  }			  		  
			  else if( pathEnd == 'reverseLoop' ){
				// LOOP THE OTHER WAY AROUND
				/*  REVERSE */
				if ( pathIdx <= 0  ){
				  pathStep = 1
				  pathIdx = 0				 
				}
			  }	
			   //alert('CHANGED!'+'\r\n pathStep:'+pathStep+'\r\n pathIdx:'+pathIdx)
		   }
		   
		   
		  
/*
		 document.querySelector('#log').innerHTML =
			  'TEST MOVEMENT ATTRIBUTES: \r\n'
			  +'pathName: '+pathName+'\r\n'
			  +'waypoints.length: '+waypoints.length+'\r\n'
			  +'pathEnd: '+pathEnd+'\r\n'
			  +'pathIdx: '+pathIdx+'\r\n'
			  +'pathStep: '+pathStep+'\r\n'
			  +'pathMode: '+pathMode+'\r\n'			 
			  +'entityObj: '+entityObj.name+'\r\n'			 
			  +'x: '+entityObj.x+'\r\n'
			  +'y: '+entityObj.y+'\r\n'			  
			  +'px: '+entityObj.px+'\r\n'
			  +'py: '+entityObj.py+'\r\n'
			  +'waypoints[pathIdx][0]: '+Number(waypoints[pathIdx][0])+'\r\n'
			  +'waypoints[pathIdx][1]: '+Number(waypoints[pathIdx][1])+'\r\n'
	*/		   
		  
		  // ////////////alert( entityObj.py +' '+ waypoints[pathIdx][1] )
		   
		  //
		  //  UPDATE THE ORIGINAL OBJECT'S POSITION ACCORDING ITS ATTRIBUTE pathMode
		  //		  
			if( pathMode == 'absolute'){
			  entityObj.x = waypoints[pathIdx][0]
			  entityObj.y = waypoints[pathIdx][1]      
			}else if( pathMode == 'relative' ){
				
			  entityObj.px = Number(waypoints[pathIdx][0])
			  entityObj.py = Number(waypoints[pathIdx][1])
			 
			  //////////////alert(entityObj.px+' / '+entityObj.py)
			}
		  		  
		  entityObj.pathStep = pathStep
		  entityObj.pathIdx = pathIdx
		}
		// end moveEntity = function( entityObj ){ ]
		 
		 
		
		//
		//	ANIMATE BRICKS FADING AWAY -- begin
		//
		function hexToRGB(h) {
		  let r = 0, g = 0, b = 0;

		  // 3 digits
		  if (h.length == 4) {
			r = "0x" + h[1] + h[1];
			g = "0x" + h[2] + h[2];
			b = "0x" + h[3] + h[3];

		  // 6 digits
		  } else if (h.length == 7) {
			r = "0x" + h[1] + h[2];
			g = "0x" + h[3] + h[4];
			b = "0x" + h[5] + h[6];
		  }
		  return {r: +r ,g: +g ,b: +b}
		}

		 /*
			FADE OUT ONE BRICK ,i.e. brickObject{}
			USED WHEN brickWallSkin == color
		 */
		function fadeOut(brickObject){
			var 
				Step = brickObject.step,
				Steps = brickObject.steps,
				Opacity = brickObject.opacity,
				Color = brickObject.color,
				StrokeColor = brickObject.strokeColor,
				Idx = brickObject.idx,
				X = brickObject.x,
				Y = brickObject.y, 
				W = brickObject.w, 
				H = brickObject.h
			
				Opacity -= Opacity.toFixed(2)/10
				
				var RColor = "rgba("
					+Color.r
					+","
					+ Color.g
					+","
					+ Color.b
					+","
					+Opacity.toFixed(2)
					+")",
					
					RStrokeColor = "rgba("
					+StrokeColor.r
					+","
					+ StrokeColor.g
					+","
					+ StrokeColor.b
					+","
					+Opacity.toFixed(2)
					+")"
				
				/*
					GET THE BRICKWALL's CONTEXT
				*/
				
				//brickwall.drawOnCanvas = 'ground' // HAS BEEN CHANGED
				
				var canvas = document.getElementById(brickwall.drawOnCanvas)
				
				var ctx = search(brickwall.drawOnCanvas, ctxs)	  
				ctx.ctx.clearRect(0, 0, canvas.width, canvas.height);	  
				
				
				if (Opacity.toFixed(2) < 0){
					ctx.ctx.clearRect(parseInt(X-1), parseInt(Y-1), parseInt(W+2), parseInt(H+2)) 
					
					brickObjects.splice(Idx,1)
					return true
				}else{
					ctx.ctx.fillStyle = RColor 
					ctx.ctx.strokeStyle = RStrokeColor 

					ctx.ctx.fillRect(X, Y, W, H)
					ctx.ctx.strokeRect(X, Y, W, H);  
				}
					
			var brickObjectBis = {
				step: Step,
				steps : Steps,
				opacity : Opacity,
				color : Color,
				strokeColor : StrokeColor,
				idx: Idx,
				x: X,
				y: Y,
				w: W,
				h: H        
			}			
		   brickObjects[Idx] = brickObjectBis
		}
		
		/*
			FADE OUT ONE BRICK ,i.e. brickObject{}
			USED WHEN brickWallSkin == img
		*/
		function fadeOutImage(brickObject){
			var 
				Step = brickObject.step,
				Steps = brickObject.steps,
				Opacity = brickObject.opacity,				
				b_idx = brickObject.b_idx
				Idx = brickObject.idx,
				X = brickObject.x,
				Y = brickObject.y, 
				W = brickObject.w, 
				H = brickObject.h
			
				Opacity -= Opacity.toFixed(2)/10
				
				//brickwall.drawOnCanvas = 'ground' // HAS BEEN CHANGED
				
				var canvas = document.getElementById(brickwall.drawOnCanvas)
				
				var ctx = search(brickwall.drawOnCanvas, ctxs)	  
				ctx.ctx.clearRect(0, 0, canvas.width, canvas.height);
				
				if (Opacity.toFixed(2) < 0){
					ctx.ctx.clearRect(parseInt(X-1), parseInt(Y-1), parseInt(W+2), parseInt(H+2)) 
					brickObjects.splice(Idx,1)
					return true
				}else{
					let tile = tiles[wallBrickMap[b_idx]]					
					ctx.ctx.globalAlpha = Opacity.toFixed(2);					
					ctx.ctx.drawImage(
						img,
						tile.x*W,
						tile.y*H,
						W,
						H,
						X, 
						Y,
						W,
						H
					 );
					ctx.ctx.globalAlpha = 1.0;					
				}
					
			var brickObjectBis = {
				step: Step,
				steps : Steps,
				opacity : Opacity,				
				idx: Idx,
				b_idx: b_idx,
				x: X,
				y: Y,
				w: W,
				h: H        
			}			
		   brickObjects[Idx] = brickObjectBis
		}

		 
		/*
			FADE OUT ALL BRICKS FROM brickObjects[]
		*/
		function fadeOutBricks(){
			var n = 0    
			while ( n < brickObjects.length ) {			
				if( typeof (brickObjects[n]) != 'undefined'  ){	
					if( brickWallSkin == 'color' ){
						fadeOut(brickObjects[n])  
					}else if( brickWallSkin == 'img' ){
						fadeOutImage(brickObjects[n])  
					}
				}	
				n++
			}
		}
		//
		//	ANIMATE BRICKS FADING AWAY -- end
		//
		
		
	
		
	//
	//
	//  ENTITIES : SPRITES & BRICKWALL -- end
	//
	//
	
	
	//
	//
	// INGAME UI -- begin
	// 
	//
	 function writeScore() {
	  /*
	  var ctx = search('sky',ctxs)
		  ctx.ctx.font = "16px Arial";
		  ctx.ctx.fillStyle = "#000000";
		  ctx.ctx.fillText('Score: '+parseInt(stage.score), 8, 20);
	  */
	  document.querySelector('#UI_wrapper #score')
	  .innerHTML = 'Score: '+parseInt(stage.score)	
		  
	}

	
	drawBricksRemaining = function() {
	  
	  var ctx  = search('sky',ctxs)
	
	  ctx.font = "16px Arial";
	  ctx.ctx.fillStyle = "#000000";
	  ctx.ctx.fillText("Bricks: "+bricksTotal, 100, 20);
	  
	}
	
	writeBricksRemaining = function() {	  
	   document.getElementById('bricks').innerHTML = parseInt(bricksTotal)
	}
	
	

	drawLives = function() {
	    /*
		var ctx  = search('sky',ctxs)
		 
		var canvas  = search('sky',canvases)
		 
		ctx.ctx.font = "16px Arial";
		ctx.ctx.fillStyle = "#000000";
		*/
			/*if(  boySprite.src.length > 0
			  && boySprite.src != ''
			){  
			  ctx.ctx.drawImage(
				boySprite,
				0,
				0,
				20.5,
				24,
				canvas.width-65, 8,
				10.25,
				12
			  );
			}*/
		
		//ctx.ctx.fillText(lives, canvas.width-50, 20);
		/*
		document.querySelector('#UI_wrapper #bricks')
	    .innerHTML = 'Bricks: '+parseInt(bricksTotal)	
		*/
	}
	
	
	window.writeLives = function() {		
		document.getElementById('livesStock').innerHTML = parseInt(lives)			
	}
	
	window.writeCasualties = function() {		
		if(stage.casualties < maxCasualties){
			document.getElementById('casualtiesContainer').classList.remove('critical')
			document.getElementById('casualtiesCount').innerHTML = parseInt(stage.casualties)
			document.getElementById('casualtiesMax').innerHTML = parseInt(maxCasualties)
		}else{
			document.getElementById('casualtiesContainer').classList.add('critical')			
		}
	}
	
	
	
	
	//
	//
	// INGAME UI -- end
	//
	//
	
	//
	//
	//	 draw()
	//	
	//	DOES: draw everything ingame
	//	      see rAF for animation management
	//
	//
	 window.draw = function() {
		
	 // FIX FOR LIVE EDITOR	
	 if( typeof paddle.spriteFrames != 'undefined'){
		 if(paddle.spriteFrames.name.indexOf('push') == -1){
			// SAVE CURRENT PADDLE SPRITE FOR RESTORING LATER
			paddle.currentSprite = paddle.spriteFrames.name
		 }
	 }else{
		 try{
			var selectedSprite = charactersActionsSprites[profile.character.charId].flying			
				setPaddleSprite(selectedSprite)
				paddle.currentSprite = paddle.spriteFrames.name
		}
		catch(err){
			console.log(err)
			/*
				FIX TO DELAY THE USE OF 
				charactersActionsSprites[profile.character.charId]
				THAT IS NOT AVAILABLE NOW
				- should be changed later
			*/
			window.setTimeout(function(){
				var selectedSprite = charactersActionsSprites[profile.character.charId].flying				
					setPaddleSprite(selectedSprite)
					paddle.currentSprite = paddle.spriteFrames.name
			},1000)
			 
	 }
	 }
	 
	  /*
		CLEAR ALL CANVASES i.e. ground, aboveGround, sky
	  */
	  //for( var n = 0 ; n < canvases.length; n++ ){
	  Array.prototype.some.call(canvases, function (canvas){	  
		  
		  //if( canvases[n].name != 'combo' ){
		  if( canvas.name != 'combo' ){
			  //var ctx = search(canvases[n].name,ctxs)
			  var ctx = search(canvas.name,ctxs)
			
			/*
				IF THE CANVAS IS A SCROLLING CANVAS
				AND NO SCREEN WILL BE SCROLLED
					DO NOT CLEAR THE CANVAS 
			*/
			if( 				
				canvas.name.indexOf('Scrolling') != -1 
			 && canvas.screensToScroll == false
			){
				ctx.ctx.clearRect(0, 0, canvas.width, canvas.height);
			}			
			else{			  
			  //ctx.ctx.clearRect(0, 0, canvases[n].width, canvases[n].height);
			  ctx.ctx.clearRect(0, 0, canvas.width, canvas.height);
			}  
			  //if( ball.type == 'punched' ){
			/*
				IF THE CANVAS HAS THE CLASS shakingH
					IF 2 seconds have passed	
						REMOVE .shakingH
			*/ 
			var canvasEl = document.getElementById( canvas.name )			
			var classes = canvasEl.classList.value
			
			if ( classes.indexOf('shakingH') != -1){
				var time = canvasEl.getAttribute('shakingH')
				if( timeUnit - time > 2 ){
					canvasEl.classList = ''
				} 				
			}	
			  
		  }
			
	  })
	
	/*
	// SIMPLE SCROLLING
	// SCROLLING - DISPLAY AND MOVE	
	if( stageScrolling.length > 0 && screensToScroll > 0){
		scrolling()
	}
	*/
	
	
	if( 
		typeof stageScrolling[0] !=='undefined'
		|| typeof stageScrolling[1] !=='undefined'
		|| typeof stageScrolling[2] !=='undefined'
	){
	
		// PARALLAX
		// SCROLLING - DISPLAY AND MOVE	
		/*if( 
			stageScrolling[0].length > 0 && screensToScroll[0] > 0
			|| stageScrolling[1].length > 0 && screensToScroll[1] > 0
			|| stageScrolling[2].length > 0 && screensToScroll[2] > 0
		){*/
		if(
			stageScrolling.length > 0
		){
			scrolling2()
		}
		
	}
	 
	//brickwall.drawOnCanvas = 'ground' // HAS BEEN CHANGED
	//var canvas = search(brickwall.drawOnCanvas, canvases)
	var canvas = document.getElementById(brickwall.drawOnCanvas)
	
	/*
	
		BRICKWALL OPERATIONS -- begin
		
	*/
	if( brickwall.brickwall_name != '' ) {
	


			/* BRIKCWALL STATES -- begin  */
								
				//brickwall.nextStateAt = 0; // add 'next' to nextStateAt when item iterated	
				//brickwall.currentStateIndex = 0; // index of the state that is currently used	
				
			/*	
			  //console.clear()
			console.log(
				'brickwalls[0].currentStateIndex: '+brickwalls[0].currentStateIndex+'\r\n'
				+'brickwalls[0].nextStateAt: '+brickwalls[0].nextStateAt+'\r\n'
				+'brickwalls[0].states[brickwall.currentStateIndex]: '+brickwalls[0].states[brickwalls[0].currentStateIndex]+'\r\n'				
				+'brickwalls[0].currentStateIndex: '+brickwalls[0].currentStateIndex+'\r\n'
			)*/
			
			//console.log( timeUnit + ' == ' + brickwall.nextStateAt  )
			
	if( typeof brickwall.states !== 'undefined'){
			if( brickwall.states.length > 0){	
				/* 
					IF IT IS TIME TO SWITCH TO NEXT STATE -- begin					
				*/
				
				document.querySelector('#log').innerHTML =  'timeUnit: '+timeUnit+'\r\n nextStateAt:'+ brickwall.nextStateAt
				
				if( timeUnit == brickwall.nextStateAt 
					|| (brickwall.currentStateIndex == -1 && timeUnit == parseInt(brickwall.firstStateAt)+1) // FIRST TIME THE FIRST STATE IS ITERATED
				){					
					// current state becomes next state
				    brickwall.currentStateIndex = parseInt(brickwall.currentStateIndex) + 1
					if( brickwall.currentStateIndex == brickwall.states.length){
					  brickwall.currentStateIndex = 0
				    }
					
					var state = brickwall.states[brickwall.currentStateIndex]					
					
					// UPDATE ATTRIBUTE 'next' -- begin					
					if( typeof state.next != 'undefined' ){
						brickwall.nextStateAt = parseInt(timeUnit) + parseInt(state.next)			 
					}
					else {
						if( 
							timeUnit == parseInt(brickwall.firstStateAt)+1
							&& brickwall.currentStateIndex == -1
						)
						{						
							brickwall.nextStateAt = parseInt(brickwall.firstStateAt)						
						}						
					}
					// UPDATE ATTRIBUTE 'next' -- end
					
				  if( typeof state.x != 'undefined' ){
					brickwall.x = parseInt(state.x)
				  }				  
				  if( typeof state.y != 'undefined'){
					  brickwall.y = parseInt(state.y)
				  }				  
				  if( typeof state.dx != 'undefined' ){
					brickwall.dx = parseInt(state.dx)
				  }				  
				  if( typeof state.dy != 'undefined'){
					  brickwall.dy = parseInt(state.dy)
				  }				  
				  if( typeof state.path != 'undefined' ){
					brickwall.path = state.path
				  }
				  if( typeof state.pathEnd != 'undefined' ){
					brickwall.pathEnd = state.pathEnd
				  }
				  if( typeof state.pathIdx != 'undefined' ){
					brickwall.pathIdx = parseInt(state.pathIdx)
				  }
				  if( typeof state.pathStep != 'undefined' ){
					brickwall.pathStep = parseInt(state.pathStep)
				  }
				  if( typeof state.pathMode != 'undefined' ){
					brickwall.pathMode = state.pathMode
				  }
				  
				  if( typeof state.drawOnCanvas != 'undefined' ){
					brickwall.drawOnCanvas = state.drawOnCanvas
				  }
				  
				  
				  // EXECUTE ACTION IF AVAILABLE IN STATE -- begin
				  if( typeof state.action != 'undefined' ){
					brickwall.action = state.action					
					// FETCH THE FUNCTION MATCHING THE ATTRIBUTE 'name' OF THE ACTION, e.g.: 'killSelf'
					var action = search(brickwall.action.name, actions)
					/*
						EXECUTE THE FUNTION WITH PARAMETERS
						& GET WHAT IS RETURNED BY THE FUNCTION
					*/
					
					/*
						Add 1 attribute to params						
						SelfIdx = the index of Self in the collection brickwalls[]
							      to make it possible to remove this brickwall from brickwalls[]
					*/
					var params = brickwall.action.params						
						params.SelfIdx = 'brickwall'//brickwall_idx
					
					params.This = brickwall
					
					// EXECUTE THE ACTION					
					action.Function( params )
					/*var actionExecuted = action.Function( params )
					////////////alert(actionExecuted)*/
				  }
				  // EXECUTE ACTION IF AVAILABLE IN STATE -- end
				  
				  /*
				  console.log(state.brickwallFramesObject)			
				  
				  if( typeof state.brickwallFramesObject !== 'undefined'){
					  console.log(state.brickwallFramesObject)
					  var frameObject = search(state.brickwallFramesObject, brickwallFrames);

					  if( frameObject !== undefined ){
						  brickwall.brickwallFrames = frameObject
						  brickwall.width = frameObject.width // brickwall frame width
						  brickwall.height = frameObject.height // brickwall frame
						  brickwall.frame = parseInt(frameObject.frame) // default brickwall frame
						  brickwall.frameMax = parseInt(frameObject.frameMax) // when frame == frameMax, reset brickwall animation to frame 0 		
						  brickwall.frameTicker = parseInt(frameObject.frameTicker) // ticker for switching to next brickwall  frame
						  brickwall.nextFrameAt = parseInt(frameObject.nextFrameAt) // when ticker == nextFrameAt, switch to next frame 			
					  }
				  }
					*/
				}
				/* 
					IF IT IS TIME TO SWITCH TO NEXT STATE -- end					
				*/	  
			} // if states !== undefined, ...
			
	}
			/* BRIKCWALL STATES -- end  */

	

	
	if( brickwall.dx != 0 ){
	  brickwall.x = parseInt(brickwall.x) + parseInt(brickwall.dx)
	/*
		STATES CAN TAKE CARE OF THIS
		OR 
	   ADD A BOOLEAN
		
	  if( brickwall.x < 0 ){
			brickwall.dx = Math.abs(brickwall.dx)
	  }
	  else if( brickwall.x + brickWidth * mapColumns > canvas.width ){
			brickwall.dx = Math.abs(brickwall.dx) * -1
	  }
	 */
	}
	
	brickOffsetLeft = brickwall.x
	  
	if( brickwall.dy != 0 ){
	  brickwall.y = parseInt(brickwall.y) + parseInt(brickwall.dy)
	  
	  /*
		STATES CAN TAKE CARE OF THIS
		OR 
	   ADD A BOOLEAN
	  
	  if( brickwall.y < 0 ){		 
			brickwall.dy = Math.abs(brickwall.dy)
	  }
	  else if( brickwall.y + brickHeight * mapRows > canvas.height ){
			brickwall.dy = Math.abs(brickwall.dy) * -1
	  }*/
	  
	}
	brickOffsetTop = brickwall.y
	  
	  // IF BRICKWALL HAS A PATH, THEN LET IT FOLLOW IT
	  if( brickwall.path != -1 /*&&  brickwall.path_coords !== undefined*/){	
		  
		  //if( typeof entityObj !== 'brickwall') {
		  //if( typeof entityObj !== 'brickwall') {
			moveEntity( brickwall ) 
		  //}
		  			
		  if( brickwall.pathMode == 'absolute' ){  
			brickOffsetLeft = parseInt(brickwall.x)
			brickOffsetTop = parseInt(brickwall.y)
		  }else if( brickwall.pathMode == 'relative' ){		  
			brickOffsetLeft = parseInt(brickOffsetLeft)+parseInt(brickwall.px)
			brickwall.x = /*parseInt(brickwall.x) +*/ parseInt(brickOffsetLeft)
			
			brickOffsetTop = parseInt(brickOffsetTop)+parseInt(brickwall.py)
			brickwall.y = /*parseInt(brickwall.y) +*/ parseInt(brickOffsetTop)
		  }	  
	  }
	}  
	 // END OF IF BRICKWALL HAS A PATH, THEN LET IT FOLLOW IT
	
	  //drawBricksRemaining() // Bricks left to destroy
	  
	  if( brickObjects.length > 0 ){
		fadeOutBricks()
	  }	

	
	  //drawBricks4(true); // draw brickwall - ingame == true
	  if( playOnce !== true){
		
		var sprite = search('teleportation.ent', sprites);
		var sprite2 = search('teleportation-back.ent', sprites);
		
		// ONLY DRAW PADDLE IF NO TELEPORTATION SPRITE IS ON STAGE
		if( /*sprite === undefined 
			&& sprite2 === undefined
			&&*/ displayAngel == true
		){		
			drawPaddle(); // draw paddle
		}		
		
	  }
	  //writeScore(); // draw score
	  //drawLives(); // draw lives
	  /*
	  drawBricksRemaining() // Bricks left to destroy
	  
	  if( brickObjects.length > 0 ){
		fadeOutBricks()
	  }
	  */
	  
					
	   //for ( let ball_idx = 0; ball_idx < balls.length; ball_idx++ ){	  
	  
	  
	 balls.some(function(ball, ball_idx){
	  
		  ball = balls[ball_idx];		  
		  
		  var iDx = ball.iDx
		  
		  /*
			IF alteredState 
				ball IS AN ENEMY WITH type == punched
				decrease alteredState
			
				IF alteredState == 0
					TURN ball back INTO THE ENNEMY sprite IT WAS FORMERLY
				ENDIF
			ENDIF 	
		  
		  */
		  		  
		  if( typeof ball.alteredState !== 'undefined' ){			  
			  var alteredState = parseInt(ball.alteredState)
			      alteredState --
			  ball.alteredState = alteredState
			  			  
			  if( ball.energy <= 0 ){
							  
					// ADD THIS SPRITE TO THE LIST OF SPRITES ELIMINATED
					spritesEliminated [ spritesEliminated.length ] = ball


					/*
						GET THE INDEX OF ball IN balls[]
					*/
					//var iDx = balls.length - 1	
					//var iDx = ball.iDx

										checkRelevantObjectiveCompletion('targets')					
					var Location = {
						 x:parseInt(ball.x),
						 y:parseInt(ball.y),	
					} 
					spawnEntityFromJson('disappear-600x100.ent',Location)
					// deregister this sprite from sprites
					//balls.splice( iDx, 1)	
					removeObjectByItsIdxValue(balls,'iDx',ball.iDx)					
					return false
			  }
			  
			 /*
				TURN ball back INTO THE ENNEMY sprite IT WAS FORMERLY -- begin			 
			 */ 
			  
			  if( alteredState == 0 ){				  
				// TURN THE BALL BACK INTO AN ENEMY				
				var X = ball.x,
					Y = ball.y,
					name = ball.name,
					energy	= ball.energy	
				
				// GET THE ENTITY CANNON BASE OBJECT		
				var custom0 = Array.prototype.filter.call(stage.stage_entityCannons,function(entity,idx){  
				  if( entity.entityName == name ){
					return entity    
				  }  
				})
				
				// GET THE ENTITY BASE OBJECT
				var modelEntity = Array.prototype.filter.call(entities,function(entity,idx){  
				  if( entity.entityName == name ){
					return entity    
				  }  
				})
				
							
								
				var custom = custom0[0]	
				
				if( typeof custom == 'undefined' ){
					custom = ball
				}
								
				//console.log(custom)
								
				sprites[sprites.length] = ball;
				
				// REMOVE ENTITY FROM balls[]
				//balls.splice( ball_idx, 1)

				let sprite = sprites[sprites.length-1]	
				
				sprite.type = 'enemy'				

				sprite.x = X
				sprite.y = Y
				sprite.energy = energy
				
				/*
				if( sprite.energy <= 0 ){
							  
					// ADD THIS SPRITE TO THE LIST OF SPRITES ELIMINATED
					spritesEliminated [ spritesEliminated.length ] = sprite					
					var iDx = sprites.length-1																				
					checkRelevantObjectiveCompletion('targets')					
					var Location = {
						 x:parseInt(sprite.x),
						 y:parseInt(sprite.y),	
					} 
					spawnEntityFromJson('disappear-600x100.ent',Location)
					// deregister this sprite from sprites
					sprites.splice( iDx, 1)					
					return false
				}*/
				
				
				sprite.drawOnCanvas = ( typeof custom.drawOnCanvas !== 'undefined' )
				?custom.drawOnCanvas:ball.drawOnCanvas
				
				sprite.dx = ( typeof custom.dx !== 'undefined' )?custom.dx:ball.dx
				sprite.dy = ( typeof custom.dy !== 'undefined' )?custom.dy:ball.dy
				
				sprite.states = ( typeof custom.states !== 'undefined' )?[...custom.states]:[...ball.states]
				
				sprite.currentStateIndex = 0				
				
				sprite.nextStateAt = parseInt(timeUnit) + 1
				
				sprite.bounceHorizontally = ( typeof custom.bounceHorizontally !== 'undefined' )?custom.bounceHorizontally:modelEntity.bounceHorizontally
				sprite.bounceVertically = ( typeof custom.bounceVertically !== 'undefined' )?custom.bounceVertically:modelEntity.bounceVertically
				sprite.outOfHorizontalBoundaryRemove = ( typeof custom.outOfHorizontalBoundaryRemove !== 'undefined' )?custom.outOfHorizontalBoundaryRemove:modelEntity.outOfHorizontalBoundaryRemove
				sprite.outOfVerticalBoundaryRemove = ( typeof custom.outOfVerticalBoundaryRemove !== 'undefined' )?custom.outOfVerticalBoundaryRemove:modelEntity.outOfVerticalBoundaryRemove
				sprite.collideWithPaddleBounce = ( typeof custom.collideWithPaddleBounce !== 'undefined' )?custom.collideWithPaddleBounce:modelEntity.collideWithPaddleBounce
				
				var name = sprite.animations.DEFAULT
				
				if( sprite.dx == 0 ){
					if( sprite.dy > 0  ){
						//var name = sprite.DOWN
						name = ( sprite.animations.DOWN != '' )?sprite.animations.DOWN:name
					}		
					else if( sprite.dy < 0  ){
						//var name = sprite.UP	
						name = ( sprite.animations.UP != '' )?sprite.animations.UP:name
					}				
				}				
				else if( sprite.dy == 0 ){					
					if( sprite.dx > 0  ){					
						//var name = sprite.RIGHT					
						name = ( sprite.animations.RIGHT != '' )?sprite.animations.RIGHT:name
					}		
					else if( sprite.dx < 0  ){
						//var name = sprite.LEFT
						name = ( sprite.animations.LEFT != '' )?sprite.animations.LEFT:name
					}
				}
				else if( Math.abs(sprite.dx) > Math.abs(sprite.dy) ){		
					if( sprite.dx > 0  ){					
						//var name = sprite.RIGHT					
						name = ( sprite.animations.RIGHT != '' )?sprite.animations.RIGHT:name
					}		
					else if( sprite.dx < 0  ){
						//var name = sprite.LEFT
						name = ( sprite.animations.LEFT != '' )?sprite.animations.LEFT:name
					}
				} else if( Math.abs(sprite.dx) <= Math.abs(sprite.dy) ){
					if( sprite.dy > 0  ){
						//var name = sprite.DOWN
						name = ( sprite.animations.DOWN != '' )?sprite.animations.DOWN:name
					}		
					else if( sprite.dy < 0  ){
						//var name = sprite.UP	
						name = ( sprite.animations.UP != '' )?sprite.animations.UP:name
					}
				}
								
				var frameObject = search(name, spriteFrames);
					sprite.spriteFrames = frameObject
				
				// REMOVE ENTITY FROM balls[]
				removeObjectByItsIdxValue(balls,'iDx',ball.iDx)
				return
			  }
			 /*
				TURN ball back INTO THE ENNEMY sprite IT WAS FORMERLY -- end			 
			 */ 

			  
		 }   // end if( typeof ball.alteredState !== 'undefined' ){
		  
		  //
		  //
		  //  BALL STATES -- begin
		  //
		  //
		  /*
		  //console.clear()
			console.log(
				'balls[0].currentStateIndex: '+balls[0].currentStateIndex+'\r\n'
				+'balls[0].nextStateAt: '+balls[0].nextStateAt+'\r\n'
				+'balls[0].states[ball.currentStateIndex]: '+balls[0].states[balls[0].currentStateIndex]+'\r\n'				
				+'balls[0].currentStateIndex: '+balls[0].currentStateIndex+'\r\n'
			)
			*/
		
		/*
			ball can change states only if it is not punched
			ennemies being punched cannot change states
		*/		
		if( ball.type != 'punched'){	
			
		  if( ball.states.length > 0){	
				// 
				//	IF IT IS TIME TO SWITCH TO NEXT STATE -- begin					
				//
				
				//document.querySelector('#log').innerHTML =  'timeUnit: '+timeUnit+'\r\n nextStateAt:'+ ball.nextStateAt
				
				if( timeUnit == parseInt(ball.nextStateAt) 
					|| (ball.currentStateIndex == -1
					   && timeUnit == parseInt(ball.firstStateAt)+1) // FIRST TIME THE FIRST STATE IS ITERATED
				){						
					// current state becomes next state
				    ball.currentStateIndex = parseInt(ball.currentStateIndex) + 1
					if( ball.currentStateIndex == ball.states.length){
					  ball.currentStateIndex = 0
				    }
					
					var state = ball.states[ball.currentStateIndex]					
					
					// UPDATE ATTRIBUTE 'next' -- begin
					
					if( typeof state.next !== 'undefined' ){
						//////////////alert(state.next) OK
						ball.nextStateAt = parseInt(timeUnit) + parseInt(state.next)	
						//////////////alert('1701- ball.nextStateAt:'+ball.nextStateAt)						 
					}
					else {
						if( 
							timeUnit == parseInt(ball.firstStateAt)+1
							&& ball.currentStateIndex == -1
						)
						{						
							ball.nextStateAt = parseInt(ball.firstStateAt)
							//////////////alert('1707- ball.nextStateAt:'+ball.nextStateAt)							
						}						
					}
					// UPDATE ATTRIBUTE 'next' -- end
					
				  if( typeof state.x !== 'undefined' ){					  
					ball.x = parseInt(state.x)					
				  }
				  
				  if( typeof state.y !== 'undefined'){
					  ball.y = parseInt(state.y)
				  }
				  
				  if( typeof state.dx !== 'undefined' ){
					ball.dx = parseInt(state.dx)
				  }
				  
				  if( typeof state.dy !== 'undefined'){
					  ball.dy = parseInt(state.dy)
				  }
				  
				  if( typeof state.path !== 'undefined' ){
					ball.path = state.path
				  }
				  if( typeof state.pathEnd !== 'undefined' ){
					ball.pathEnd = state.pathEnd
				  }
				  if( typeof state.pathIdx !== 'undefined' ){
					ball.pathIdx = parseInt(state.pathIdx)
				  }
				  if( typeof state.pathStep !== 'undefined' ){
					ball.pathStep = parseInt(state.pathStep)
				  }
				  if( typeof state.pathMode !== 'undefined' ){
					ball.pathMode = state.pathMode
				  }
				  
				  // EXECUTE ACTION IF AVAILABLE IN STATE -- begin
				  if( typeof state.action !== 'undefined' ){
					ball.action = state.action					
					// FETCH THE FUNCTION MATCHING THE ATTRIBUTE 'name' OF THE ATION, e.g.: 'killSelf'
					var action = search(ball.action.name,actions)
					//
					//	EXECUTE THE FUNTION WITH PARAMETERS
					//	& GET WHAT IS RETURNED BY THE FUNCTION
					//
					
					//
					//	Add 2 attributes to params
					//	Self: this sprite from sprites[]
					//	SelfIdx = the index of Self in the collection sprites[]
					//
					var params = ball.action.params
						//params.Self = ball
						params.SelfIdx = ball_idx // MAYBE USE iDx for selfRemove()
						params.collection = 'ball'
						params.collection = balls// WILL BE CHANGED
						params.This = ball
						
					var actionExecuted = action.Function( params )
					
				  }
				  // EXECUTE ACTION IF AVAILABLE IN STATE -- end
				  
				  //console.log(state.spriteFramesObject)
				  
				  if( typeof state.spriteFramesObject !== 'undefined'){
		//			  console.log(state.spriteFramesObject)
					  var frameObject = search(state.spriteFramesObject, spriteFrames);

					  if( frameObject !== undefined ){
						  ball.spriteFrames = frameObject
						  ball.width = frameObject.width // sprite frame width
						  ball.height = frameObject.height // sprite frame
						  ball.frame = parseInt(frameObject.frame) // default sprite frame
						  ball.frameMax = parseInt(frameObject.frameMax) // when frame == frameMax, reset sprite animation to frame 0 		
						  ball.frameTicker = parseInt(frameObject.frameTicker) // ticker for switching to next sprite  frame
						  ball.nextFrameAt = parseInt(frameObject.nextFrameAt) // when ticker == nextFrameAt, switch to next frame 			
					  }
				  }
					
				}
				// 
				//	IF IT IS TIME TO SWITCH TO NEXT STATE -- end					
				//	  
			} // if states !== undefined, ...
		  }// if( ball.type == 'punched'){
		  //
		  //
		  // BALL STATES -- end
		  //
		  //
		 	  
		  var canvas = document.getElementById(ball.drawOnCanvas)
		  
		  if ( isNaN(ball.frame) == true ) {console.log('SKIPPED!');/*breakcontinue*/}	
		  
		    // DRAW ONLY IF IN THE STAGE BOUNDARIES
			if(	 
					ball.y  <= Number.parseInt(canvas.style.top) + parseInt(canvas.height)		 
				 && ball.x  <= Number.parseInt(canvas.style.left) + parseInt(canvas.width) 				 	
			 ){		
				animateSprite(ball); 
			 }
		  /*
		  if (brickwall.brickwall_name !== ''){
			ball.ball_idx = ball_idx  
			collisionDetection(ball);// TEST COLLISION BETWEEN ball VS brickwall's bricks
		  }
		  */
		  	var dataObject = {
				ball:ball,
				blX:ball.x,
				blY:ball.y,
				blW:ball.width,
				blH:ball.height,
				blDx:ball.dx,
				blDy:ball.dy,
				brX:paddleX,				
				brY:paddleY,
				brW:paddleWidth,
				brH:paddleHeight,
				bounceAgainst: 'paddle'
			} 
		
		 /* IF BALL IS BEYOND THE MAIN CANVAS RIGHT BOUNDARY
			       PLACE IT BACK ON THE BOUNDARY
				   REVERSE ITS dx
			*/
		  if( ball.x + ball.width > canvas.width  ) {		  	  
			  // BOUNCE HORIZONTALLY WHEN OUT OF HORIZONTAL LIMITS
			  if( ball.bounceHorizontally === true ){	  
				ball.x = canvas.width - ball.width;
				ball.dx = -ball.dx;
				if( ball.type == 'punched'){										
					//shakeCanvas(ball.drawOnCanvas)					
					shakeCanvas('ground')					
				}
				// CHANGE THE BALLS's animation
			
				if( ball.type == 'punched'){
					swapSprite(ball,'PUNCHED')
				}else{
					swapSprite(ball)	
				}
				   
			  }// end BOUNCE HORIZONTALLY WHEN OUT OF HORIZONTAL LIMITS
			  
			  // DISAPPEAR WHEN OUT OF CANVAS HORIZONTAL LIMIT
			  // -- for projectiles
			  
				
				
			//	balls.splice( iDx, 1)//ball_idx
			  
			  if( ball.outOfHorizontalBoundaryRemove === true ){
					// REMOVE ENTITY FROM balls[]	
				  			
				   //balls.splice(iDx, 1)// ball_idx
				   removeObjectByItsIdxValue(balls,'iDx',ball.iDx)		
			  }
		  }
		  
		  
		  /* IF BALL IS BEYOND THE MAIN CANVAS LEFT BOUNDARY
			       PLACE IT BACK ON THE BOUNDARY
				   REVERSE ITS dx
			*/
		  if( ball.x < canvas.clientLeft ) {//Number.parseInt(canvas.style.left)
			 // BOUNCE HORIZONTALLY WHEN OUT OF HORIZONTAL LIMITS
			if( ball.bounceHorizontally === true ){	
				ball.x = canvas.clientLeft//Number.parseInt(canvas.style.left);
				ball.dx = -ball.dx;	
				if( ball.type == 'punched'){										
					//shakeCanvas(ball.drawOnCanvas)					
					shakeCanvas('ground')					
				}
				// CHANGE THE BALLS's animation
			
				if( ball.type == 'punched'){
					swapSprite(ball,'PUNCHED')
				}else{
					swapSprite(ball)	
				}	
				
			}// end BOUNCE HORIZONTALLY WHEN OUT OF HORIZONTAL LIMITS
			
			// DISAPPEAR WHEN OUT OF CANVAS HORIZONTAL LIMIT
			 // -- for projectiles
			if( ball.outOfHorizontalBoundaryRemove === true ){				 
			   //balls.splice(ball_idx, 1)
			   //balls.splice( iDx, 1)
			    removeObjectByItsIdxValue(balls,'iDx',ball.iDx)		
			}
		  }
		
			/* IF BALL IS BEYOND THE MAIN CANVAS BOTTOM BOUNDARY
			       PLACE IT BACK ON THE BOUNDARY
				   REVERSE ITS dy
			*/
		  if( ball.y + ball.height > canvas.height  ) {
			// BOUNCE VERTICALLY WHEN OUT OF VERTICAL LIMITS
			  if( ball.bounceVertically === true ){	  
				ball.y = canvas.height - ball.height;
				ball.dy = -ball.dy;
				
				if( ball.type == 'punched'){										
					//shakeCanvas(ball.drawOnCanvas)					
					shakeCanvas('ground')					
				}			
				
				// CHANGE THE BALLS's animation			
				if( ball.type == 'punched'){
					swapSprite(ball,'PUNCHED')
				}else{
					swapSprite(ball)	
				}	
				
			  }
			   // -- for projectiles
			  if (ball.outOfVerticalBoundaryRemove === true){
				 //balls.splice(ball_idx, 1)					
				//balls.splice( iDx, 1)
				 removeObjectByItsIdxValue(balls,'iDx',ball.iDx)		
			  }
			  
		   }// end BOUNCE VERTICALLY WHEN OUT OF VERTICAL LIMITS 
	

		  /* IF BALL IS BEYOND THE MAIN CANVAS TOP BOUNDARY
			       PLACE IT BACK ON THE BOUNDARY
				   REVERSE ITS dy
			*/
		  if( ball.y < Number.parseInt(canvas.style.top) ) {
			// BOUNCE VERTICALLY WHEN OUT OF VERTICAL LIMITS
			if( ball.bounceVertically === true ){  
				ball.y = Number.parseInt(canvas.style.top);
				ball.dy = -ball.dy;
				
				if( ball.type == 'punched'){										
					//shakeCanvas(ball.drawOnCanvas)					
					shakeCanvas('ground')					
				}	
				
				// CHANGE THE BALLS's animation			
				if( ball.type == 'punched'){
					swapSprite(ball,'PUNCHED')
				}else{
					swapSprite(ball)	
				}
				
			}
			 // -- for projectiles
			if (ball.outOfVerticalBoundaryRemove === true){
				//balls.splice(ball_idx, 1)
				//balls.splice(iDx, 1)	
				removeObjectByItsIdxValue(balls,'iDx',ball.iDx)						
			}
			
		  }
		  			
		  // BOUNCE BALL ON COLLISION WITH THE PADDLE
		if( ball.collideWithPaddleBounce === true 			
		){
		  
		  // BOUNCE ON THE PADDLE
		  if( 	  
				ball.x >= paddleX-ball.width && ball.x + ball.width/2 <= (paddleX + paddleWidth)		  		  
			 && ball.y >= paddleY-ball.height && ball.y + ball.height/2 <= (paddleY + paddleHeight) 
				){		
			   
			   /*
					ROTATE THE PADDLE
					TO FOLLOW THE POSITION OF THE ENEMY COLLIDED
				*/								
				paddle.rotation = 0
				paddle.rotating = 0
				
				// SAVE CURRENT PADDLE SPRITE FOR RESTORING LATER
				//paddle.currentSprite = paddle.spriteFrames.name				
								
				if(
					paddle.weapon == ''
					|| paddle.weapon.indexOf('portal') != -1					
				){	
					// SET THE pushing paddle sprite
					var sprt = charactersActionsSprites[profile.character.charId].pushing
					setPaddleSprite(sprt)
					
					if( (ball.y) > paddleY+paddleHeight/2){
						paddle.rotation = 180
						if( (ball.x+(ball.width/2)) > paddleX+(paddle.width/2)){
							paddle.rotation = 135										
						}
						if( (ball.x+(ball.width/2)) < paddleX+(paddle.width/2)){
							paddle.rotation = 225										
						}
						paddle.rotating = 1										
					} else if( (ball.y) <= paddleY+paddleHeight/2){
						paddle.rotation = 0
						if( (ball.x+(ball.width/2)) > paddleX+(paddle.width/2)){
							paddle.rotation = 45										
						}
						if( (ball.x+(ball.width/2)) < paddleX+(paddle.width/2)){
							paddle.rotation = 315										
						}
						paddle.rotating = 1										
					}
				}
				else{
					// RESTORE CURRENT PADDLE SPRITE BY DEFAULT	  
					 if (typeof paddle.currentSprite !=='undefined'){
						paddle.spriteFrames.name = paddle.currentSprite
					 }	
					
				}
				/*
					END ROTATE THE PADDLE
					TO FOLLOW THE POSITION OF THE ENEMY COLLIDED
				*/	
			   
			   
			   // IF THE BALL IS A PUNCHED ENNEMY, KEEP ITS VELOCITY HIGH
			   if( ball.type == 'punched' ){				   
				   
				   if( paddle.weapon == 'gloves' ){
						  
						  ball.dx = Math.sign(ball.dx)* 3
						  ball.dy = Math.sign(ball.dy)* 3
						  
						  var paramsObject = {							
							 x:parseInt(ball.x),
							 y:parseInt(ball.y),
							 width:parseInt(ball.width),
							 height:parseInt(ball.height)
							}
						  
						  var c = {
								x:paramsObject.x,
								y:paramsObject.y,
								w:paramsObject.width,
								h:paramsObject.height,
								entityName:'small-collision-48x48.ent',								 
								iDx:iDx
							}									
							collisionSparkle(c)
						  
						  ball.dx *= 1	
						  ball.dy *= 1	
						  
						  //swapSprite(ball,'PUNCHED')
						  
						  ball.x = parseInt( ball.x ) - parseInt( paddle.width ) * Math.sign( ball.dx ) * 1.5
						  ball.y = parseInt( ball.y ) - parseInt( paddle.width ) * Math.sign( ball.dy ) * 1.5
						 
						  var damage = parseInt(paddle.strength) - parseInt(ball.resistance)
						  
						  //damage = 1
						  
							if( damage < 1){ damage = 0 }

							/*
								INIT FADING OUT ENERGY POINTS
							*/
							var energyObject = {								
								color: [254,254,254],
								pointsAmount: damage,
								sign: -1,
								impactObject: ball //can be a ball or a sprite, used for its x,y,dx,dy
							}
							
							let isAlreadyDisplayed = energyObjects.filter(obj => {
							  return obj.iDx === iDx
							})
							
							if( isAlreadyDisplayed.length === 0 ){
								initEnergyPointFadeOut( energyObject )
							}
							
							
							ball.x -= Math.sign(ball.dx) * 10
							ball.y -= Math.sign(ball.dy) *10
						 
						 ball.energy -= damage
						 
						 if( ball.energy <= 0 ){
							 
							 spawnGoldCoins(ball)
							// ADD THIS SPRITE TO THE LIST OF SPRITES ELIMINATED
							 ball.type = 'enemy'
							 spritesEliminated [ spritesEliminated.length ] = ball
							 							 
							var Location = {
								 x:parseInt(ball.x),
								 y:parseInt(ball.y),	
							} 
							spawnEntityFromJson('disappear-600x100.ent',Location)
							checkRelevantObjectiveCompletion('targets')
							
							// deregister this sprite from balls (it s a former sprite)
							//balls.splice( ball.ball_idx,1)
							//balls.splice( iDx,1)
							 removeObjectByItsIdxValue(balls,'iDx',ball.iDx)		
						 }
						  
						  hitCombo(paramsObject)
					   
						  // WHACK PUNCH						 					  
						  /*if( sounds[6].playing() == false ){
							sounds[6].play()
						  } */
						  
						  if( typeof sprite != 'undefined' ){
							  if( sprite.type.indexOf('obstacle') == -1
									&& ball.type.indexOf('obstacle') == -1){
									sounds[6].play();// missed
							  }
						  }
					}
				 
			   }
			  /* 
			  // BOUNCE the ball against the paddle 
			  // ONLY IF paddle HAS PUNCHING GLOVES
			   if( ball.type == 'punched' && paddle.weapon.indexOf('gloves') == -1){
				   
			   }
			   else{
				   bounceObject(dataObject)
			   }
			   */
			   /*
					PADDLE BOUNCES THE BALL
						IF BALL IS NOT A PUNCHED ENEMY
						OR IF BALL IS A PUNCHED ENEMY AND PADDLE HAS BOXING GLOVES
			   */
			   			   
			   if( 
					(ball.type == 'punched' && paddle.weapon.indexOf('gloves') != -1 )
					|| ball.type != 'punched'				   
			   ){
				   bounceObject(dataObject)
			   }
			   
			  
			  // CHANGE THE BALLS's animation
			
				if( ball.type == 'punched'){
					swapSprite(ball,'PUNCHED')
				}else{
					swapSprite(ball)	
				}
			  
			   
			}
		}// BOUNCE SPRITE ON COLLISION WITH THE PADDLE  
		
		if (brickwall.brickwall_name !== ''){
			ball.ball_idx = ball_idx  
			collisionDetection(ball);// TEST COLLISION BETWEEN ball VS brickwall's bricks
		  }
		
		ball.x += ball.dx;
		ball.y += ball.dy; 
		  
	  }// for ( let ball_idx = 0; ball_idx < balls.length; ball_idx++ ){
	  )
	  
	   
	   
	  moveSprites() //-- WILL BE RENAMED BECAUSE MAKES MUCH MORE THAN MOVING SPRITES
	      
	  if (brickwall.brickwall_name !== ''){
		drawBricks4(true); // draw brickwall - ingame == true
	  }
	 
	  fadeOutEnergyPoints()
	  
	  
	}// end draw()
	
	
		
		reload = function(){
			document.location.reload();
		}
		
		/*
		 spawnABall = function( entityName ){
			 			
			 // WILL BE USED AS A PARAMETER
			 //var entityName = 'ball.entity'; // name of the ball entity to spawn			 
			 var ballDefaultSpriteAnimation = search( entityName, entities ) // get entity	
			 var ball = search( ballDefaultSpriteAnimation.DEFAULT, spriteFrames )	// get sprite 'boyWalkUp'			 
			 			 
			// SPAWN IN THE CENTER BOTTOM PART OF THE STAGE			 
				var X = 180,
					Y = 650
			    //
				//	GET THE SPRITES OF THE TWO ENTITIES THAT WILL BE SPAWNED:
				//	forcefield & ball
				//	EXTRACT THEIR width & height to center & overlap them
				//
				var forceField = search( 'force-field-50x50.sprt', spriteFrames )
					
				var p = {					
					x : ( X + parseInt(ball.width)/2 ) - parseInt(forceField.width)/2,// center horiz
					y : ( Y + parseInt(ball.height)/2 ) - parseInt(forceField.height)/2,// center vert
					dx:0,  
					dy:0,
					drawOnCanvas: 'sky',					
					follow: -1,
					type: 'ball',
					invincibility: 1000
				}
				// SPAWN AN ENTITY THAT INDICATES THE BALL IS INVINCIBLE FOR A LIMITED TIME
				spawnEntityFromJson( 'force-field-50x50.ent', p )
				
				//
				//	SPAWN THE BALL
				//	NOTE: 
				//		THE FORCE FIELD SPAWN JUST BEFORE WILL 
				//		RECEIVE THE INDEX OF THE BALL ( attribute: follow )
				//		ONCE IT'S BEEN SPAWNED (see spawnSprite() )
				//
				var params = {invincibility: 1000, x: X, y: Y, dx:0, dy:0}				
				spawnEntityFromJson(entityName,params) 
		}
		*/
		
		window.spawnABall = function( entityName ){
			 
			// SPAWN IN THE CENTER BOTTOM PART OF THE STAGE			 
				var X = 180,
					Y = 650
					
			    /*
					LIVES REMAINING
					SPAWN A BALL WITH A FORCEFIELD (invincibility) (SEE spawnSpriteFromJson)
				*/
				var p = {					
					invincibility : spawnBallInvincibilityTime
				}
				spawnEntityFromJson(entityName, p)	
		}
	
/*
  function search(nameKey, myArray)
  DOES: search an objet fromn an array
		by its name attribute
		return the object found
  i.e.:
  spriteFrames[0] = {
    name:'sprite 1'  
  }  
  PARAMS: nameKey (string) - required
		  myArray (array)  - required
*/
/*
function search(nameKey, myArray){
    for (var i=0; i < myArray.length; i++) {
        if (myArray[i].name === nameKey) {
            return myArray[i];
        }
    }
}
*/


/*
    function isEscorteeInObjectives(escorteeToFind)
    DOES: returns true if escorteeToFind is found in objectives[],
                  false otherwise
    PARAMS:
         escorteeToFind: string - entity.name, e.g.: swimmer-female-blonde.ent
		 
	USE EXAMPLE: isEscorteeInObjectives('swimmer-female-blonde.ent')
*/
window.isEscorteeInObjectives = function(escorteeToFind){
    var escortees = []  
    objectives.some(function(o){ 
       if( typeof o.value != 'undefined' && Array.isArray(o.value) === true ){
            escortees = o.value.some(function(o2){
                if( o2.value !== null && typeof o2.name != 'undefined'){
                    return (o2.name === escorteeToFind)
                }
            })
       }
    })
    //console.log(escortees)
    return escortees    
}


 window.search = function(nameKey, myArray){
	var i = 0;
    while ( i <= myArray.length-1 ) {
        if (myArray[i].name === nameKey) {
            return myArray[i];
        }
		i++
    }
}



window.removeArrayItemByName = function(nameKey, myArray){
	var i = 0;
    while ( i <= myArray.length-1 ) {
        if (myArray[i].name === nameKey) {
            myArray.splice(i,1);
			 //////alert('THAT IS THE ONE '+7076)	
        }
		i++
    }
}


/*
	SCROLLING FUNCTIONS
*/
  window.findMinMax = function(arr) {
  let min = arr[0].y, max = arr[0].y;

  for (let i = 1, len=arr.length; i < len; i++) {
    let v = arr[i].y;
    min = (v < min) ? v : min;
    max = (v > max) ? v : max;
  }

  return [min, max];
}


window.searchSmallestY = function(nameKey, myArray){
	var i = 0;
    while ( i <= myArray.length-1 ) {
        if (myArray[i].y === nameKey) {
            return myArray[i];
        }
		i++
    }
}

/*
	FIND AN OBJECT BY ITS ID ATTRIBUTE 
	WITHIN A COLLECTION ARRAY
*/
function searchByID(nameKey, myArray){
	var i = 0;
	while ( i <= myArray.length-1 ) {
		if (myArray[i].ID === nameKey) {
			return myArray[i];
		}
		i++
	}
}

/*
	function searchEC()
	get a collection array of 
	entities which attribute 'start' equals stageNthFrame
*/

function searchEC(){
	var i = 0,
		ECs = [];
		
    while ( i <= entityCannons.length-1 ) {
        if (entityCannons[i].start === timeUnit) {//stageNthFrame
		
			//console.log('i:'+i+'entityCannons[i].start: '+entityCannons[i].start)
		
             ECs.push(i);
        }
		i++
    }
	
	
	//console.log(ECs)
	
		//return JSON.stringify(ECs)
		return ECs
}

/*
window.searchEC = function(){
	var i = 0,
		ECs = [];
	
    ECs = entityCannons.map((cv,i,a) => {
        if(cv.start === timeUnit){
            return cv
        }
        else{
            
        }
    })

    console.log(ECs)

    return JSON.stringify(ECs)
    i++
}
//console.log(searchEC(timeUnit))
*/


 spawnSpriteFromJson = function( params ){
	
	// GET THE SPRITE's ANIMATIONS FROM COLLECTION 'spriteFrames[]'
	
	var name = params.name
	
	var frameObject = search(name, spriteFrames);
		
	let spriteObject = {
		
		drawOnCanvas: params.drawOnCanvas,
		
		spriteFrames: frameObject,
		/*	
		animations:{
			UP: 'boyWalkUp',
			DOWN: 'boyWalkDown',
			LEFT: 'boyWalkLeft',
			RIGHT: 'boyWalkRight'	
		},	
		
 	    energy: ,
	    strength: 0,			
		*/
		x: params.x, // horizontal position
		y: params.y, /*// vertical position
		dx: params.dx | 0, // horizontal vector
		dy: params.dy | 0, // vertical vector,*/
		/*
		// added params for sprites
		px : 0, // path x
		py : 0, // path y
		path : -1,//"v.abs",//path[1] // which path does the entity follow?
		pathStep : 1, // the higher, the faster the entity moves
		pathIdx : 0, // index used to iterate through path 
		pathMode : 'absolute', // move to : 'absolute' | move by 'relative'
		*/
		width: frameObject.width, // sprite frame width
		height: frameObject.height, // sprite frame 	
				
		frame: frameObject.frame, // default sprite frame
		frameMax: frameObject.frameMax, // when frame == frameMax, reset sprite animation to frame 0 		
		frameTicker: frameObject.frameTicker, // ticker for switching to next sprite  frame
		nextFrameAt: frameObject.nextFrameAt, // when ticker == nextFrameAt, switch to next frame ('animation speed')
				
		bounceHorizontally: false,
		bounceVertically: false,
		outOfHorizontalBoundaryRemove: false,
		outOfVerticalBoundaryRemove: false,
		collideWithPaddleRemove: false,// remove this on collide with paddle 
		collideWithPaddleBounce: false,
		BounceBallVertically: false,
		BounceBallHorizontally: false, 
		collideBallRemoveBall: false,// remove ball on collide
		collideBallAttacksBall: false,// on collision the sprite attacks the ball that loses energy
		collidePaddleAttacksPaddle: false,// on collision the sprite attacks the ball that loses energy
		
		collideBallLoseEnergy: false,
		collidePaddleLoseEnergy: false
	}
	
	
	spawnSprite(spriteObject)
}
	

 /*
 spawnEntityFromJson = function( name )
 DOES: 
  	spawn a registered entity (entities) onto the stage
 ARGUMENTS:
	name -- entities, name -- required
	entities attributes object (attribute "stage_entityCannons" generated by stages editor) -- optional
	ID,entityName,iterations,drawOnCanvas,
	next,start,archiveIterations,archiveStart,
	x,y,dx,dy,pathpathEnd,reverseLoop
	NOTE: does not exist if entity is spawned by another entity
 */
 window.spawnEntityFromJson = function( name ){

	//////////////alert('spawnEntityFromJson:\r\n'+name+' '+obj )
	// GET THE SPRITE's ANIMATIONS FROM COLLECTION 'spriteFrames[]'	
	var entityObject = search(name, entities);
	
	if( typeof entityObject === 'undefined' ){		
		return false
	}
	
	var sprite_name = entityObject.DEFAULT	
	
	/*
		ENTITY's DEFAULT ATTRIBUTES VALUES
		IS SUPERCHARGED BY obj BELOW IF obj !== undefined (entity spawned by EC)
	*/	
	var x = entityObject.x,
		y = entityObject.y,
		dx = parseInt(entityObject.dx),
		dy = parseInt(entityObject.dy),
		type = entityObject.type,
		path = entityObject.path,
		pathStep = entityObject.pathStep,
		pathIdx = entityObject.pathIdx,
		pathMode = entityObject.pathMode,
		pathEnd = entityObject.pathEnd,
		drawOnCanvas = entityObject.drawOnCanvas,// HAS BEEN CHANGED
		states = entityObject.states,
		firstStateAt = entityObject.firstStateAt,
		invincibility = -1,// TIME IN 10TH OF SECONDS DURING WHICH THE ENTITY IS UNTOUCHABLE				
		
		energy = entityObject.energy,
		strength = entityObject.strength,
		resistance = entityObject.resistance,
		
		collisionBoundaries = entityObject.collisionBoundaries,
		rotateForOrientation = entityObject.rotateForOrientation,
		spriteFacingUp = entityObject.spriteFacingUp, /* true: up / false: down */
		maxSimIterations = 'undefined'// not present in entities editor so far
	/*
		SUPERCHARGED BY entity cannon i.e.
		: arguments[1]
	*/
	if( arguments.length > 1 ){
		var obj = arguments[1]
		
		//////////////alert(JSON.stringify(obj)) -- OK
		
		/*
			IF obj !== undefined
			obj SUPERCHARGES ENTITY's DEFAULT ATTRIBUTES (see above)
		*/
		if( typeof obj !== 'undefined' ){
			
			//spawnSpriteFromJson
			x = (typeof obj.x !== 'undefined')?obj.x:x 		
			y = (typeof obj.y !== 'undefined')?obj.y:y
			dx = (typeof obj.dx !== 'undefined')?obj.dx:dx
			dy = (typeof obj.dy !== 'undefined')?obj.dy:dy
			type = (typeof obj.type !== 'undefined')?obj.type:type
			collisionBoundaries	= (typeof obj.collisionBoundaries !== undefined)?obj.collisionBoundaries:collisionBoundaries		
			/*rotateForOrientation = (typeof obj.rotateForOrientation !== undefined)?obj.rotateForOrientation:false,
			spriteFacingUp = (typeof obj.spriteFacingUp !== undefined)?obj.spriteFacingUp:false,*/ /* true: up / false: down */
			
			path = (typeof obj.path !== 'undefined')?obj.path:path
			pathStep = (typeof obj.pathStep !== 'undefined')?obj.pathStep:pathStep
			pathIdx = (typeof obj.pathIdx !== 'undefined')?obj.pathIdx:pathIdx
			pathEnd = (typeof obj.pathEnd !== 'undefined')?obj.pathEnd:pathEnd
			pathMode = (typeof obj.pathMode !== 'undefined')?obj.pathMode:pathMode
			drawOnCanvas = (typeof obj.drawOnCanvas !== 'undefined')?obj.drawOnCanvas:drawOnCanvas	
			
			states = (typeof obj.states !== 'undefined')?obj.states:states
			invincibility = (typeof obj.invincibility !== 'undefined')?obj.invincibility:invincibility
			
			firstStateAt = (typeof obj.firstStateAt !== 'undefined')?obj.firstStateAt:firstStateAt
			energy = (typeof obj.energy !== 'undefined')?obj.energy:energy
			strength = (typeof obj.strength !== 'undefined')?obj.strength:strength
			resistance = (typeof obj.resistance !== 'undefined')?obj.resistance:resistance
			var txt = (typeof obj.txt !== 'undefined')?obj.txt:'' // FOR COMBO STARS
			
			maxSimIterations = (typeof obj.maxSimIterations !== 'undefined')?obj.maxSimIterations:'undefined'
			
		} 		
	}
	//console.log('maxSimIterations: '+maxSimIterations)
	/*
		
		IF entity IS AN OBSTACLE
			spawn 1 instance for sprites
			then spawn 1 instance for balls		
	*/
	if(type == 'obstacle'){		
		if( arguments.length > 1 ){
			let params = arguments[1]
				params.type = 'obstacleBall'				
			console.log(params)
			spawnEntityFromJson(name, params)			
		}else{
			let params = {}
				params.type = 'obstacleBall'				
			console.log(params)
			spawnEntityFromJson(name, params)						
		}		
	}
		
	/*
		GET ENTITIE's SPRITE ANIMATIONS
	*/
	
	//console.clear()
	//console.log(sprite_name)
	
	var frameObject = search(sprite_name, spriteFrames);
	
	//console.log(entities)
	//console.log(spriteFrames)
	
	if( typeof frameObject === undefined ){
		//console.log('sprite_name: '+sprite_name)
		//console.log('name: '+name)
		////////////alert(sprite_name)
	}
	
	
	let spriteObject = {		
		name: name,		
		spriteFrames: frameObject,		
		animations:{
			UP: entityObject.UP,
			LEFT: entityObject.LEFT,
			DEFAULT: entityObject.DEFAULT,
			RIGHT: entityObject.RIGHT,
			DOWN: entityObject.DOWN,
			APPEAR: entityObject.APPEAR,
			DISAPPEAR: entityObject.DISAPPEAR,
			PUNCHED: entityObject.PUNCHED,
		},		
		energy: energy,
	    strength: strength,
	    resistance: resistance,
		type: type,
		
		/*
			POSITION & MOVEMENT ATTRIBUTES
			(CAN BE SUPERCHARGED BY STAGE EDITOR)
		*/
		drawOnCanvas: drawOnCanvas, // name/id of canvas to draw this entity on
		
		states: states, // states
		
		firstStateAt: firstStateAt,
		
		x: x, // horizontal position
		y: y, // verticaldrawOnCanvas position
		dx: dx, // horizontal vector
		dy: dy, // vertical vector,
		collisionBoundaries: collisionBoundaries, // inner collision boundaries
		rotateForOrientation: rotateForOrientation,
		spriteFacingUp: spriteFacingUp,
		
		// added params for sprites
		px : entityObject.px, // path x
		py : entityObject.py, // path y
		path : path,//"v.abs",//path[1] // which path does the entity follow?
		
		pathStep : pathStep, // the higher, the faster the entity moves
		pathIdx : pathIdx, // index used to iterate through path 
		pathMode : pathMode, // move to : 'absolute' | move by 'relative'		
		pathEnd : pathEnd, // loop | reverseLoop | stop	
		
		width: frameObject.width,// sprite frame width
		height: frameObject.height,// sprite frame 	
		
		invincibility:invincibility,
		
		txt:txt,
		
		frame: frameObject.frame, // default sprite frame
		frameMax: frameObject.frameMax, // when frame == frameMax, reset sprite animation to frame 0 		
		frameTicker: frameObject.frameTicker, // ticker for switching to next sprite  frame
		nextFrameAt: frameObject.nextFrameAt, // when ticker == nextFrameAt, switch to next frame ('animation speed')
		
		bounceHorizontally: entityObject.bounceHorizontally,
		bounceVertically: entityObject.bounceVertically,
		outOfHorizontalBoundaryRemove: entityObject.outOfHorizontalBoundaryRemove,
		outOfVerticalBoundaryRemove: entityObject.outOfVerticalBoundaryRemove,
		collideWithPaddleRemove: entityObject.collideWithPaddleRemove,// remove this on collide with paddle 
		collideWithPaddleBounce: entityObject.collideWithPaddleBounce,
		BounceBallVertically: entityObject.BounceBallVertically,
		BounceBallHorizontally: entityObject.BounceBallHorizontally, 
		collideBallRemoveBall: entityObject.collideBallRemoveBall,// remove ball on collide
		collideBallAttacksBall: entityObject.collideBallAttacksBall,// on collision the sprite attacks the ball that loses energy
		collidePaddleAttacksPaddle: entityObject.collidePaddleAttacksPaddle,// on collision the sprite attacks the ball that loses energy
		collideBallLoseEnergy: entityObject.collideBallLoseEnergy,
		collidePaddleLoseEnergy: entityObject.collidePaddleLoseEnergy,
		
		collideWithBWRemove: entityObject.collideWithBWRemove,
		collideWithBWBounce: entityObject.collideWithBWBounce,
		
		iDx: Date.now(),
		maxSimIterations: maxSimIterations
	}
	////////////alert('spriteObject: '+spriteObject.x+ ' '+spriteObject.y)// OK
	spawnSprite(spriteObject)
	
	
	/*
		newBall.iDx 
		WILL BE USED TO DELETE 
		THIS BALL WHEN RELEVANT
		newBall.iDx  
		MUST BE UPDATED WHEN 
		A sprite BECOMES a ball
		OR 
		A ball BECOMES a sprite
	*/
	
}
	
	//
	//	rAF - begin
	//


		window.requestAnimationFrame = function () {
			return window.requestAnimationFrame ||
			window.webkitRequestAnimationFrame ||
			window.mozRequestAnimationFrame ||
			window.msRequestAnimationFrame ||
			window.oRequestAnimationFrame ||
			function(f) {				
					window.setTimeout(f,1000/60);				
				}
		}()
		/*
		var updateId,
			previousDelta = 0,
			fpsLimit = 60;
		*/
	   window.update = function(currentDelta) {	
			
			if( 
				stageEnded === true 
				|| paused === true
				|| (playOnce === true && stageNthFrame > 1)				 
			){
				return
			}
			
			updateId = requestAnimationFrame(update);

			var delta = currentDelta - previousDelta;
						
			if (fpsLimit && delta < 1000 / fpsLimit) {
				
				if( arguments.length < 2){
					return;
				}				
				
			}

			/* your code here */			
			myReq = requestAnimationFrame( main );	

			
			previousDelta = currentDelta;
			
			//updateId = requestAnimationFrame(update);
			
			
		}
		
		
		window.cancelAnimationFrame = window.cancelAnimationFrame || window.mozCancelAnimationFrame
			/*
			var entityCannons = [
				{
					start: 50, // nth frame to start from, when reached, beomes stageNthFrame + next 
					next: 100, // next spawning if any
					iterations: -1, // how many iterations:  N | -1 = unlimited
					entityName: 'skeletonWalksRight.entity'
				},
				{
					start: 200,
					next: 50,
					iterations: 5,
					entityName: 'starbucks.ent'
				}
			]
			*/
		/*function triggerEntityCannons( found ){
			for (var n = 0; n <= found.length-1; n++){								
				if( found[n] !== null){
					if( parseInt(found[n].iterations) === -1
						|| parseInt(found[n].iterations) > 0){ 							
							  spawnEntityFromJson( found[n].entityName, found[n] )						
							// FIND THE ENTITY CANNON TO UPDATE BY ITS ID ATTRIBUTE						
							var entityCannon = searchByID(found[n].ID, entityCannons)	
								entityCannon.start = parseInt( timeUnit) + parseInt(found[n].next)						
							if( parseInt(found[n].iterations) !== -1 ){
								entityCannon.iterations = parseInt(found[n].iterations) - 1
							}
					}
				}
			}
		}*/
		
		/*
			found = array[0,1,2,3,4,5]		
		*/		
		
		function triggerEntityCannons( foundIndexes ){
			
			found = entityCannons
			
			for (var n = 0; n <= foundIndexes.length-1; n++){								
				if( foundIndexes[n] !== null){
					if( parseInt(found[foundIndexes[n]].iterations) === -1
						|| parseInt(found[foundIndexes[n]].iterations) > 0){ 							
							  spawnEntityFromJson( found[foundIndexes[n]].entityName, found[foundIndexes[n]] )						
							// FIND THE ENTITY CANNON TO UPDATE BY ITS ID ATTRIBUTE						
							var entityCannon = searchByID(found[foundIndexes[n]].ID, entityCannons)	
								entityCannon.start = parseInt( timeUnit) + parseInt(found[foundIndexes[n]].next)						
							if( parseInt(found[foundIndexes[n]].iterations) !== -1 ){
								entityCannon.iterations = parseInt(found[foundIndexes[n]].iterations) - 1
							}
					}
				}
			}
		}
		

		 window.main = function(currentTime) {
			
			/* 
				nth frame since the beginning of the stage
				used for triggering 
					'entity cannons'
				can also be used if there is a time limit counter
			*/
			/*
				CHECK IF entityCannons contains any item which attribute 'start' equals stageNthFrame
					if so, then get all items which attribute 'start' equal stageNthFrame
					and spawn their entity						
			*/
			//var found = JSON.parse(searchEC( stageNthFrame ))
						
			if( stageEnded === true || paused === true){
				// PAUSE, THEN STOP EVERYTHING
				cancelAnimationFrame(myReq)
				return false			
			}
			
			sprites.some(function(obj){obj.metObstacle = false})
			balls.some(function(obj){obj.metObstacle = false})
			/**/
		

		
	
		
		if( 
			displayAngel == true
			|| stageEnded == false
		){	
			/*
			paddle.rotation = 0
			paddle.rotating = 0
			*/
			if (currentTime >= lastTime + 100)  {// every 10th of second
					
					var entityCannonsNow = searchEC( timeUnit )
					
					if( typeof( entityCannonsNow) !== 'undefined' ){
						//var found = JSON.parse( entityCannonsNow )
						var found = entityCannonsNow
					}
					
					if( found.length > 0 ){			
						//////////////alert('spawn time:\r\n'+JSON.stringify(found))
						triggerEntityCannons( found )
					}			
					timeUnit++ 
					lastTime = currentTime;	


					if( timer > 0){
						timer --					
						document.querySelector('#timer').innerText = timer
						if( timer == 0 ){
							checkAllObjectivesComplete()
						}
					}
					
					
				/* 
				ONLY APPLICABLE FOR Angel Squad Editor
				*/
				if ( 
					window.location !== window.parent.location 
					&& window.parent.document.querySelector('#gameTestFrm') != null			
				){	
					//alert(window.parent.document.querySelector('#currentTime'))
					window.parent.document.querySelector('#currentTime_').innerHTML = currentTime
					window.parent.document.querySelector('#lastTime_').innerHTML = lastTime
					window.parent.document.querySelector('#timeUnit_').innerHTML = timeUnit
					window.parent.document.querySelector('#stageNthFrame_').innerHTML = stageNthFrame
				}		
				
			}
			
			/*
				BOW SHOOTS ARROWS				
				|| ANGEL PORTAL SPAWNS ANGELS				
			*/
			// SHOOT ARROWS EVERY 1 SECONDS
			
			//electricArc()
			
			if( 
				typeof search('angel-portal.ent',balls) !== 'undefined' 
				|| paddle.weapon.indexOf('bow') != -1
			){
				if(currentTimeArrow >= lastTimeArrow){
					currentTimeArrow += 10// rate of fire
				}				
			}			
			
			if( paddle.weapon.indexOf('bow') != -1 ){
						
				if(currentTimeArrow >= lastTimeArrow + 100){// the lower the faster the shooting rate
					var Location = {	
						 x: parseInt(paddleX) + paddleWidth/2,
						 y: parseInt(paddleY)-5	
					} 
					spawnEntityFromJson('arrow.ent',Location)
				
				if(paddle.WED > 100){
					var Location = {	
						 x: parseInt(paddleX),
						 y: parseInt(paddleY)-5,
						 dx: -2						 
					} 
					spawnEntityFromJson('arrow.ent',Location)			
					
					var Location = {	
						 x: parseInt(paddleX) + paddleWidth,
						 y: parseInt(paddleY)-5,
						 dx: 2						
					} 
					spawnEntityFromJson('arrow.ent',Location)			
				}
				
				
					
				lastTimeArrow = currentTimeArrow;
				}
			}
			
			/*
				IF THERES IS AN ACTIVE ANGEL PORTAL, SPAWN An ANGEL
			*/
			if( typeof search('angel-portal.ent',balls) !== 'undefined' ){
			
				var T = 140 - parseInt(profile.character.charisma) * 5
			
				if(currentTimeArrow >= lastTimeArrow + parseInt(T) ){// the lower the faster the shooting rate
					var Location = {	
						 x: parseInt(paddleX) + paddleWidth/2,
						 y: parseInt(paddleY)-50,
						 dx: getRandomArbitrary(-3, 3)
					} 
					spawnEntityFromJson('angel.ball.ent',Location) 
					sounds[0].play()
					lastTimeArrow = currentTimeArrow;
				}
			}
			
			
		 }
			/*
				MOVE PADDLE WITH ARROW KEYS
			*/
			let paddleSpeed = 5	// SHOULD BE CUSTOMIZABLE
			
			let x = parseInt(paddleX)
			let y = parseInt(paddleY)
			paddleX = x + parseInt(paddle.dx) * paddleSpeed	
			paddleY = y + parseInt(paddle.dy) * paddleSpeed
			paddle.x = paddleX
			paddle.y = paddleY
			
			draw();	
			
			/*
				THE GAME ANIMATION HAS STARTED,
				IT STOPS TO GIVE TIME TO THE INTRODUCTION #modal TO SCROLL IN
			*/
			if( playOnce === true && stageNthFrame > 1 ){
				// PAUSE, THEN STOP EVERYTHING
				cancelAnimationFrame(myReq)
				return false			
			}
			
			/*
				IF PADDLE IS INVINCIBLE
					ANIMATE THE FORCE FIELD AROUND IT
					-- begin
			*/			
			let invincibility = paddle.invincibility
			if( invincibility > 0 ){
				
				var forceField = search( 'force-field-50x50.sprt', spriteFrames )
					forceField.x = ( paddleX + parseInt(paddle.width)/2 ) - parseInt(forceField.width)/2,// center horiz
					forceField.y = ( paddleY + parseInt(paddle.height)/2 ) - parseInt(forceField.height)/2,// center vert					 
					
					frameTicker = parseInt(paddle.forceField.frameTicker),
					nextFrameAt = parseInt(paddle.forceField.nextFrameAt),
					forceFieldFrame = parseInt(paddle.forceField.frame)
					frameTicker ++
						
					if( frameTicker == nextFrameAt ){
						
						forceFieldFrame ++						
						
						if ( forceFieldFrame == parseInt(forceField.frameMax) ){
							 forceFieldFrame = 0
							 nextFrameAt ++ // LOWER THE FORCE FIELD ANIMATION FRAME RATE							 
						}
						
						paddle.forceField.frame = forceFieldFrame
						paddle.forceField.nextFrameAt = nextFrameAt						
						frameTicker = 0
					}					
					paddle.forceField.frameTicker = parseInt(frameTicker)					
					forceField.drawOnCanvas = search('sky',ctxs)
					forceField.draw( forceFieldFrame, forceField.x, forceField.y, forceField.drawOnCanvas);
				
				// paddle is invincible, decrease invincibility
				invincibility --
				paddle.invincibility = parseInt(invincibility)				
			}
			/*
				IF PADDLE IS INVINCIBLE
					ANIMATE THE FORCE FIELD AROUND IT
					-- end
			*/
			
			stageNthFrame++;
			
			/*
				IF AN ENEMY WAS COMBOED AND KILLED
				MAKE SURE THE COMBO APPEARS
			*/			
			 var lastHitAt = Number(paddle.lastHitAt)		 
			 var currentCombo = parseInt(paddle.currentCombo)		 
			 if( timeUnit - lastHitAt > comboInterval ){		 
				 if ( currentCombo > 1 ){ 		 
					var p = {
						 x:paddleX,
						 y:paddleY-110,
						 w:paddleWidth,
						 h:paddleHeight
					 }
					 p.x = p.x - p.w/2
					 p.y = p.y - p.h/2	
					 p.txt = currentCombo
					 ////////////alert( p.txt )
					 if( p.x < 100 ){ p.x = 100 }
					 if( p.x > 260 ){ p.x = 260 }
					 if( p.y < 100 ){ p.y = 100 }
					 if( p.y > 600 ){ p.y = 600 }
			 	
					/*spawnEntityFromJson('combo-star-100x500.ent',p)*/
					
					var cbo = {
						x:p.x,
						y:p.y,
						spikes: 8,
						outerRadius: 50, 
						innerRadius: 35, 
						strokeStyle: 'bold #000', 
						fillStyle: 'rgba(255,255,0,0.8)', 
						txt: p.txt,
						duration: 60,
						rot:0
					}	
					
					//drawComboStar('comboStar', p.x, p.y, 20, 55, 40, '#000', '#ff0', p.txt)
															
					//ctx.ctx.fillText(currentCombo, textX, textY);
					
					combosObjects.push(cbo)		
						
					checkRelevantObjectiveCompletion( 'minCombos' )
						
					paddle.currentCombo = 0
				}
			 }
			
			/*
				IF paddle IS EQUIPED WITH A WEAPON 
				&& WEAPON IS NOT PERMANENT (-2)
				   AND DOES NOT LAST FOR THE WHOLE LEVEL (-1)
				
			*/
			if( paddle.weapon != '' 				
				&& paddle.weaponEquippedDuration > 0
				&& paddle.noMorePowerUpsFx !== true
				/*&& currentTime >= lastTime + 100*/
			){								
				paddle.weaponEquippedDuration--				
				////console.clear()
				//console.log(paddle.weaponEquippedDuration)
				
				if( parseInt(paddle.weaponEquippedDuration) <= 0){
					
					
					// Clearing the electricArc canvas
					ctx.clearRect(0,0,can.width,can.height);
					
					// RESET paddle DEFAULT
					paddle.weaponEquippedDuration = 0
					//setPaddleSprite('angel-M.angelo-fly.sprt') // change the paddle sprite     angel-flying.sprt
					//setPaddleSprite('angel-G-ARROW-fly.sprt') // change the paddle sprite     angel-flying.sprt
					//setPaddleSprite('angel-GABRIELLE-fly.sprt') // change the paddle sprite     angel-GABRIELLE-fly.sprt
					
					setPaddleSprite(charactersActionsSprites[profile.character.charId].flying)
					
					paddle.weapon = ''
					paddle.strength = profile.character.strength								
					paddle.resistance = profile.character.resistance
				}else{	
					// draw sprite weapon duration level					
					context = search('sky', ctxs);					
					
					let X = paddle.x + paddle.width / 2
					let Y = paddle.y + paddle.height / 2
					
					let percent = paddle.weaponEquippedDuration / paddle.weaponEquippedDefaultDuration * 100
					
					let x = 50 * 100 / paddle.weaponEquippedDefaultDuration
						x2 = 50 * 100 / paddle.weaponEquippedDuration
						//x3 = 100 / -1 * paddle.weaponEquippedDuration							
						//let diff = paddle.weaponEquippedDefaultDuration - (paddle.weaponEquippedDefaultDuration - paddle.weaponEquippedDuration)
						let diff = x - (x - x2)
						let x3 = paddle.weaponEquippedDuration * 20 / 100
					
					let paddlePowerUpdated = false
					if( 
						typeof paddle.PR !== 'undefined' 
						&& typeof paddle.STR !== 'undefined' 
						&& typeof paddle.WED !== 'undefined' 
					){
						paddlePowerUpdated = true						
					}

					if( percent < 80 
						|| paddlePowerUpdated === true
					){
						
						let fillStyle = 'rgba(254,254,254,0.2)'
						
						if( paddle.STR > 30 ){
							fillStyle = 'rgba(254,0,0,0.2)'
						}					
						else if( paddle.STR > 20 ){							
							fillStyle = 'rgba(254,128,200,0.2)'
						}					
						else if( paddle.STR > 10 ){
							fillStyle = 'rgba(0,254,0,0.2)'
						}						
						
						if(paddlePowerUpdated === true){
							maxLength = percent * 0.75
							frame();
						}
						
						
						//drawStar(context.ctx, X, Y, 20, paddle.weaponEquippedDuration/2, diff, 'rgba(254,254,254,0.2)',' rgba(254,254,254,0.2)');
						
						
						// DRAW SHRINKING FORCE FIELD SHOWING HOW LONG THE WEAPON STAYS EQUIPPED
							context.ctx.beginPath();
							context.ctx.arc(X, Y, x3, 0, 2 * Math.PI, false);
							context.ctx.fillStyle = fillStyle;
							context.ctx.fill();
							context.ctx.lineWidth = 1;
							context.ctx.strokeStyle = 'rgba(254,254,254,0.2)';
							context.ctx.stroke();						
						
						//drawStar(context.ctx, X, Y, 20, x3+5, x3, '#fff',' rgba(254,254,0,0.5');						
					}
					// STAR TO SHOW WEAPON EQUIPPED
					else {						
						/* DRAW A STAR THAT WILL DIMINISH */
						drawStar(context.ctx, X, Y, 20, paddle.weaponEquippedDuration/2, diff, 'rgba(254,254,254,0.2)',' rgba(254,254,254,0.2)');
					}
					
										
				}
			}
			
			
			// DISPLAY COMBO OBJECTS IF ANY IN combosObjects[]
			displayCombosObjects()
			
			//frame();
			
			//myReq = requestAnimationFrame( main );
			
			
			
			
			
			
			update(currentTime)
		};
	//
	//	rAF - end
	//

	/*    
	
		ELECTRIC ARC FUNCTION -- begin
	
	*/
	
	// Function making one frame
		window.frame = function(){
			var now,elapsed;
			
			// Calculating the time between now and the previous frame
			now = Date.now();
			if(!lastFrame){ 	
				elapsed = 0;
			}			
			else{
				elapsed = (now - lastFrame) / 1000;
			}

			lastFrame = now;
			
			// Clearing the electricArc canvas
			ctx.clearRect(0,0,can.width,can.height);
						
			var i,touchX,touchY,j,r,x,y;
			
			// Effect for each touch
			for(i = 0 ; i < 1 ; i++){				
				
				touchX = paddleX + parseInt(paddle.width/2);
				touchY = paddleY + parseInt(paddle.height/2);
				
				ctx.save();
				ctx.translate(touchX,touchY);
				ctx.rotate(rotation); // General effect rotation
				
				// For each touch, we draw effectsPerTouch electric effects
				for(j = 0,r = 0 ; j < effectsPerTouch ; j++, r = j * Math.PI * 2 / effectsPerTouch){
					ctx.save();
					ctx.rotate(r);
					
					// One electric effect is composed of several lines
					// Here comes the magic
					ctx.beginPath();
					ctx.moveTo(0,0);
					for(x = 0, y = 0 ; x < maxLength ; x += 20 + Math.random() * 60, y += Math.random() * 60){
						ctx.lineTo(x,y);
					}
					ctx.stroke();
					
					ctx.restore();
				}
				
				ctx.restore();
			}
			
			// Updating the general rotation
			rotation += elapsed * rotationSpeed;
		}
		
		window.startAnimation = function(){
			animated = true;
			(function(){
				if(animated){
					animationId = frame();
					requestAnimationFrame(arguments.callee);
				}
			})();
		}
		
		window.stopAnimation = function(){
			animated = false;
			frame(); // clearing the canvas
			cancelAnimationFrame(animationId);
		}
		/*
		// Actually handling events
		can.addEventListener('touchstart',function(e){
			e.preventDefault();
			
			// We only need to start the animation at the first touch
			if(touches.length == 0){
				startAnimation();
			}
			
			touches = e.touches;
		});
		can.addEventListener('touchmove',function(e){
			e.preventDefault();
			touches = e.touches;
		});
		can.addEventListener('touchend',function(e){
			touches = e.touches;
			
			// Again, we stop the animation only if the user has removed all 
			// of his fingers.
			if(touches.length == 0){
				stopAnimation();
			}
		});
		
		// For computers, we need to "fake" the touch events
		can.addEventListener('mousedown',function(e){
			touches = [e]; // Faking the use of touch events
			startAnimation();
		});
		can.addEventListener('mousemove',function(e){
			touches = [e];
		});
		can.addEventListener('mouseup',function(){
			touches = [];
			stopAnimation();
		});*/
		
		// At the start, we call stopAnimation() to clear the canvas
		//stopAnimation();
	
	/*    
	
		ELECTRIC ARC FUNCTION -- end
	
	*/


	function displayCombosObjects(){				
		if( combosObjects.length > 0 ){
			combosObjects.some(function(cbo, idx){
				let duration = cbo.duration
				if(cbo.duration < 1){
					combosObjects.splice(idx,1)
				}else{
					let Type = 'comboStar';// type of drawing to generate
					let addRot = cbo.rot
						addRot++
					if(addRot >= 359){addRot = 0}
						cbo.rot = addRot
					duration --// decrease the lifespan of this cbo
									
					if( typeof cbo.type !=='undefined' ){Type = cbo.type}
					if(Type != 'msg'){
						drawComboStar('comboStar', cbo.x, cbo.y, cbo.spikes, cbo.outerRadius, cbo.innerRadius, cbo.strokeStyle, cbo.fillStyle, cbo.txt, cbo.duration, cbo.rot)
					}
					else{
						/*
						let isAlreadySparkled = combosObjects.filter(obj => {
							  return obj.iDx === cbo.iDx
						})
						if( isAlreadySparkled.length === 0 ){*/
						
							displayMsg({x:cbo.x,y:cbo.y,txt:cbo.txt})
						
						}				
					}
					
					cbo.duration = duration
				/*}			*/			
				
			})
		}else{
			return
		}
	}	

	// params 
	window.displayMsg = function(paramsObj){					
		// DISPLAY A MSG INSTEAD OF A STAR					
		var textX = parseInt(paramsObj.x)/*+ getRandomArbitrary(-30, 30)*/,
			textY = parseInt(paramsObj.y)/*+ getRandomArbitrary(-30, 30)*/
		var ctx = search('comboStar',ctxs)
			ctx.ctx.font = "15px Century Gothic bold";
			ctx.ctx.textAlign = "center";
			ctx.ctx.textBaseline = "middle";							
			ctx.ctx.fillStyle = "#ffff00";					
			ctx.ctx.fillText(paramsObj.txt, textX, textY - 5);
	}

//
//
// ANIMATION MANAGEMENT --end
//
//

/*
	function drawStar(ctx, cx, cy, spikes, outerRadius, innerRadius, strokeStyle, fillStyle)
	
	DOES:
		DRAWS A STAR
	
	PARAMS:
		ctx, cx, cy, spikes, outerRadius, innerRadius, strokeStyle, fillStyle
		ALL REQUIRED
	
	USE: drawStar(175, 200, 20, 30, 25, "#000", "#000");
*/
function drawStar(ctx, cx, cy, spikes, outerRadius, innerRadius, strokeStyle, fillStyle) {
	
	let addRot = 0
	// OPTIONNAL ARGUMENT rot ie rotation
	if( arguments.length == 9 ){
		addRot = arguments[8]
	}	
    var rot = Math.PI / 2 * 3;
		
	ctx.save()
	
    var x = cx;
    var y = cy;
		
	// move the origin to the canvas' center
	ctx.translate(x, y); //let's translate
	// add addRot degrees rotation
	ctx.rotate(Math.PI / 180 * addRot+5); //increment the angle and rotate the image 

	ctx.translate( -x, -y ); //let's translate
		
    var step = Math.PI / spikes;
		
    ctx.strokeSyle = strokeStyle;
    ctx.beginPath();
	
    ctx.moveTo(cx, cy - outerRadius)
    for (i = 0; i < spikes; i++) {
        x = cx + Math.cos(rot) * outerRadius;
        y = cy + Math.sin(rot) * outerRadius;
        ctx.lineTo(x, y)
        rot += step  

        x = cx + Math.cos(rot) * innerRadius;
        y = cy + Math.sin(rot) * innerRadius;
        ctx.lineTo(x, y)
        rot += step
    }
		
    ctx.lineTo(cx, cy - outerRadius)
    ctx.closePath();
    ctx.lineWidth = 1;
    ctx.strokeStyle = strokeStyle;
    ctx.stroke();
    ctx.fillStyle = fillStyle;
    ctx.fill();
	
	ctx.restore()
}

/*
	function drawComboStar(ctx, cx, cy, spikes, outerRadius, innerRadius, strokeStyle, fillStyle)
	
	DOES:
		DRAWS A STAR
	
	PARAMS:
		ctx, cx, cy, spikes, outerRadius, innerRadius, strokeStyle, fillStyle
		ALL REQUIRED
	
	USE: drawStar(175, 200, 20, 30, 25, "#000", "#000");
*/

function drawComboStar(Canvas, x, y, spikes, outerRadius, innerRadius, strokeStyle, fillStyle, txt, rot){
	var ctx = search(Canvas,ctxs)
	drawStar(ctx.ctx, x, y, spikes, outerRadius, innerRadius, strokeStyle, fillStyle, rot)
	
	/*
		drawComboStar() can be used to draw collision, txt is set to false in this case 
	*/
	if(txt !== false){
		var textX = parseInt(x)
			textY = parseInt(y)
		
		ctx.ctx.font = "20px Century Gothic";
		ctx.ctx.textAlign = "center";
		ctx.ctx.textBaseline = "middle";
		
		ctx.ctx.fillStyle = "#000000";					
		ctx.ctx.fillText(txt, textX, textY - 5);
		
		ctx.ctx.font = "15px Arial";
		ctx.ctx.fillText('HITS !', textX, textY + 20);
	}
}
//
//
//  BALLS MANAGEMENT -- begin
//
//
	   function lose_one_ball( ball_idx ){
		   
		   //console.log('4955 - lose_one_ball: ')
		   	
			// get ball's entityName 
			var entityName = balls[ball_idx].name
			
			if( entityName == 'arrow.ent' ){
				return
			}
			// deregister this ball from balls
			//balls.splice(ball_idx, 1)
			
			// REMOVE THE BALL FROM balls
			
			let ball = balls[ball_idx]
			
			removeObjectByItsIdxValue(balls,'iDx',ball.iDx)		
			
			if(stageEnded === true
				|| stage.ingame === false	){
					return true
			}
						
			/*
				if ball's entityName is in spawnBalls[]
				COUNT IT AS A CASUALTY
				LOSE A LIFE
					IF LIVES LEFT
					SPAWN A NEW ONE 
			*/
			if( spawnBalls.indexOf( entityName ) != -1
				&& stageEnded === false
				&& stage.ingame === true
				&& document.querySelector('#modal').classList.contains('UI-animation-down') === false
			) {
				
				var entity = search( entityName, entities)
				
				stage.casualties ++
				
				/*
					IF maxCasualties is set
					AND player has lives remaining
					display WARNING MESSAGE
				*/
				if( typeof maxCasualties !== 'undefined'){
					if( 
						stage.casualties <= maxCasualties 
					){					
						let msg = 
						'<span class="csl">Warning:</span><br/><span class="csl">Casualties: '
						+stage.casualties+'/'+maxCasualties+'</span>'
						
						writeCasualties();// INGAME UI UPDATE lives FIELD
						
						modal( 'miniModalCasualties',msg , 'bounceLeft', 3000, 'warning')//UI-animation-down
					}
				}
				
				// if count entityName in balls < 1
				if( 
					search( entity.name, balls) === undefined 
					|| isEscorteeInObjectives(entity.name) === true 
					|| entity.name == spawnBalls.find((o) => o == entity.name)
					
				){					
					//
					//	IF NO BALLS OF THIS TYPE LEFT, LOSE A LIFE
					//
					  lives --;// remove one life 					
					 if( lives < 0 ) {
						lives = 0						 
					 }
					 
					// UPDATE DB.character.lives  						
					db.character.lives = db.character.where({profileId:1}).modify({lives:lives}) 
					.then(()=>{
						
					  if( lives < 1 ) {						  
						lives = 0						
					  }	
						
					  writeLives();// INGAME UI UPDATE lives FIELD
					  //drawLives(); // draw lives
					  
					  if( 
						maxCasualties != '' 
						&& parseInt(stage.casualties) > maxCasualties 
					  ){							
							var message = 
							'Mission failed!'
							+'<br/>'
							+'Too many innocents casualties!'
							
							// IF RAF LOOPING, THEN EXIT IT 				
							stageEnded = true
							
							paddle.noMorePowerUpsFx = true
							
							modal('modal', message,'UI-animation-down',4000 )
							
							// Clearing the electricArc canvas
							ctx.clearRect(0,0,can.width,can.height);
							
							teleport_back(2000)
							//displayAngel = false	
							setTimeout(
								function(){
									// PAUSE, THEN STOP EVERYTHING
									cancelAnimationFrame(myReq)
									// STOP ALL PLAYING SOUNDS
									stopAllPlayingSounds()				
									// IF RAF LOOPING, THEN EXIT IT 				
									stageEnded = true
									//stage.ingame = false	
									
									endStage({
										status: 'failure',
										reason: 'noLivesLeft'
									})
								}
							,2000)	
							return
					  }
					  else{
						  
							stopAllPlayingSounds()
							
							if( lives < 1 ){
								
								stagePayToContinueSpawn()
								if(
								search( entity.name, balls) === 'undefined' 
								|| entity.name == spawnBalls.find((o) => o == entity.name)
								|| isEscorteeInObjectives(entity.name) === true
								){
									spawnABall( entity.name )					
									// WILL BE CHANGED
									paddle.drawOnCanvas = 'sky'
									var canvas = document.getElementById(paddle.drawOnCanvas)					
									paddleX = (canvas.width-paddleWidth)/2;
									paddleY = (canvas.height-30);					
									return
								}			
							}
							else if(
								search( entity.name, balls) === 'undefined' 
								|| entity.name == spawnBalls.find((o) => o == entity.name)
								|| isEscorteeInObjectives(entity.name) === true
							){
								spawnABall( entity.name )					
								// WILL BE CHANGED
								paddle.drawOnCanvas = 'sky'
								var canvas = document.getElementById(paddle.drawOnCanvas)					
								paddleX = (canvas.width-paddleWidth)/2;
								paddleY = (canvas.height-30);					
								return
							}
						
						}

						
					})// then()
					
				}//if( search( entity ,sprites) !== 'undefined' ){		
			}// //if ball's entityName is in spawnBalls[]
		 }	// lose_one_ball( ball_idx ){
			 
			 
			 
			 
		window.stagePayToContinueSpawn = function(){											
			//
			//	OFFER PLAYER TO PAY GOLD 
			//	TO CONTINUE PLAYING THE STAGE
			//	IF THEY PAY 
			//		CONTINUE
			//	ELSE	
			//		PROCEED TO $endStage
			//	ENDIF												
			//
			//
			//	If #modal IS DISPLAYING 
			//		DO NOT DISPLAY #stagePayToContinue
			//		PLAYER CANNOT CONTINUE
			//
			if( document.querySelector('#modal').classList.value.indexOf('fullScreenPage') != -1 ){
				return false
			}		
			
			if(			
				stageEnded !== false
				|| stage.ingame !== true
				|| document.querySelector('#modal').classList.contains('UI-animation-down') === true
			)
			{
				return false
			}
		
			// IF RAF LOOPING, THEN EXIT IT 				
			stageEnded = true
		
			  // UPDATE PROFILE GOLD
			  document.querySelector('#stagePayToContinue .profileGold .gold').textContent = profile.gold	
			  // DISPLAY #stagePayToContinue											  	
			  document.querySelector('#stagePayToContinue').classList.add('UI-animation-up')												
			  showPage('stagePayToContinue')
		}	 
	   
//
//
//  BALLS MANAGEMENT -- end
//
//


//
//
//  STAGES MANAGEMENT -- begin
//
//
	/*
		1- LOAD ENTITY CANNONS
		2- LOAD BRICKWALL
	*/
	window.loadStageFromStages = function( stageName ){
		
		
		function showBriefingOrNot(){
			
			if( 
				typeof(stage.briefing) == 'undefined' 
				|| stage.briefing == ''
				)
			{
				if( document.querySelectorAll('.btnShowBriefing').length > 0 ){				
					document.querySelector('.btnShowBriefing').remove()		
				}
				return
			}
		
			if( stage.briefing != ''){
				
				if( document.querySelectorAll('.btnShowBriefing').length < 1 ){	
					let Btn = document.createElement('a')
						Btn.setAttribute('href','#')
						Btn.classList.add('btnShowBriefing')
						Btn.innerHTML = '?'							
						document.querySelector('#stageDetails').append(Btn)
				}
				
				showBriefing(5000)
			}
			/*else{	
				if( document.querySelectorAll('.btnShowBriefing').length > 0 ){				
					document.querySelector('.btnShowBriefing').remove()		
				}
			}	*/	
		}
		
		
		let Arguments = [...arguments];// arguments will be used in a Dexie Spawn() 
		 
		document.querySelector('#loadingStatusContainer').classList.remove('hiddenUIBtn');
		
		return new Promise(function(resolve, reject) {
			
			// LOAD STAGE 
			stage = search(stageName, stages)
			//alert(stage.object.briefing)	
			//console.clear()
			console.log('8604')
			console.log(stage)
			
			var description = stage.description			
			
			/*
				LOAD ENTITY CANNONS			
			*/		
			entityCannons = stage.stage_entityCannons

			/*
				LOAD BRICKWALL
			*/	
			if( stage.stage_brickwall_name != '' ){
			
				var brickwall_name = stage.stage_brickwall_name	
					brickwall.brickwall_name = brickwall_name
					brickwall.x = stage.BW_x 
					brickwall.y = stage.BW_y 
					brickwall.dx = stage.BW_dx 
					brickwall.dy = stage.BW_dy 
					brickwall.px = stage.BW_x//stage.px 
					brickwall.py = stage.BW_y //stage.py 
					brickwall.path = stage.BW_path
					brickwall.pathStep = stage.BW_pathStep 
					brickwall.pathIdx = stage.BW_pathIdx 
					brickwall.pathMode = stage.BW_pathMode	 // TO BE ADDED TO EDITOR
					brickwall.pathEnd = stage.BW_pathEnd
					brickwall.drawOnCanvas = stage.BW_drawOnCanvas
					brickwall.states = stage.BW_states
				
				/*
					BW STATES			
				*/
				brickwall.firstStateAt = stage.BW_firstStateAt		
				brickwall.currentStateIndex = -1 
				brickwall.nextStateAt = parseInt(timeUnit) + 1 + brickwall.firstStateAt 
				// LOAD BW
				//loadStageBrickWall(brickwall_name)			
			
			}else{
				brickwall.brickwall_name = ''
				console.log('no brickwall in this stage')
				console.log(JSON.stringify(brickwall))
			}
			
			/*  
				PADDLE INIT -- begin
			*/		
			paddle.drawOnCanvas = 'sky'
			
			// ANGEL NEUTRAL FLYING SPRITE
			DBprofileGetSelectedChar( 1 )
			
			try{
				var selectedSprite = charactersActionsSprites[profile.character.charId].flying			
					setPaddleSprite(selectedSprite)
			}
			catch(err){
				console.log(err)
				/*
					FIX TO DELAY THE USE OF 
					charactersActionsSprites[profile.character.charId]
					THAT IS NOT AVAILABLE NOW
					- should be changed later
				*/
				window.setTimeout(function(){
					var selectedSprite = charactersActionsSprites[profile.character.charId].flying				
						setPaddleSprite(selectedSprite)
				},1000)
			
			}
			console.log(selectedSprite)		
			
			paddle.weapon = ''
			paddle.bestStageCombo = 0		
			paddle.currentCombo = 0
			paddle.strength = profile.character.strength								
			paddle.resistance = profile.character.resistance	
			paddle.energy = profile.character.energy // REFILL ENERGY BEFORE THE NEW STAGE
			paddle.invincibility = -1		
			
			/*paddleX = 170
			paddleY = 650		*/
			
			/*  
				PADDLE INIT -- end
			*/
			
			// SPAWN A BALL -- WILL BE CHANGED
			if( stage.spawnBalls !== undefined && stage.spawnBalls != [] ){
				spawnBalls = [...stage.spawnBalls]; // COPY stage.spawnBalls TO spawnBalls[]				
			}
						
			/*
			// INIT & INSTANCIATE SCROLLING		
			scrollingScreens = stage.scrollingScreens
			
			if( typeof(stage.scrollingScreens) !== 'undefined' ){			
				scrollingScreens = stage.scrollingScreens
				if( scrollingScreens.length > 0 ){
					spawnScrollingScreens2()
				}
			}
			*/
			
			if( stage.objectives !== undefined && stage.objectives != [] ){
				
				// STAGE OBJECTIVES	
				objectives = [...stage.objectives]; // COPY stage.objectives TO objectives[]
				
				var Timer = search( 'timer',objectives )
				if( typeof(Timer) !=='undefined' ){
					if( typeof(Timer.value) !=='undefined'  ){
						if( parseInt(Timer.value) > 0  ){
							timer = parseInt(Timer.value)					
						}
					}
				}
			}
			/*
				LIST STAGE OBJECTIVES INTO stageDetails
			*/		
			var stageDetails = document.getElementById('stageDetails')// container	
			var objectivesList = document.querySelector('#stageDetails .objectivesList')// ul
				objectivesList.innerHTML= ''
				
			function Description(li, objective){
				return new Promise(function (resolve, fail){
					var description = document.createElement('span')
						description.classList = 'description'
						description.textContent = objective.description							
						li.append(description)
						resolve()
				})
			}
			
			// HIDE & EMPTY ALL #bricks,#targets,#timer,#combos
				document.querySelector('#bricks').classList.add('hidden')
				document.querySelector('#bricks').innerHTML = ''	
				document.querySelector('#combos').classList.add('hidden')
				document.querySelector('#combos').innerHTML = ''			
				document.querySelector('#timer').classList.add('hidden')
				document.querySelector('#timer').innerHTML = ''
				document.querySelector('#targets').classList.add('hidden')
				document.querySelector('#targets').innerHTML = ''
				document.querySelector('#escortees').classList.add('hidden')
				document.querySelector('#escortees').innerHTML = ''

			Array.prototype.some.call(objectives, function(objective){			
				// APPEND <span class="description">[description]</span> TO li			
				if( objective.description != "" ){
					var li = document.createElement('li')
					
					switch(objective.name ){
						
						case 'timer':
						
							// INIT INGAME INTERFACE FIELD			
							document.querySelector('#timer')
							.classList.remove('hidden')           
							document.querySelector('#timer')
							.innerHtml = objective.value 
							
							li.innerHTML = "<span class='sprite ui-stage-timer-icon-30x36'></span>"
										  +"<span class='description'>"+objective.value+"</span>"
						break;
						case 'minCombos':
						// CREATE THUMB						
							
							// INIT INGAME INTERFACE FIELD			
							document.querySelector('#combos')
							.classList.remove('hidden')
							
							document.querySelector('#combos').innerHTML = objective.value 
							
							
							
							li.innerHTML ="<span class='sprite ui-stage-minCombos'></span><span class='valueHolder'>"+objective.value+"</span>"
							Description(li, objective)		
						break;
						case 'destroyBW':
						
							// INIT INGAME INTERFACE FIELD
							document.querySelector('#bricks')
							.classList.remove('hidden')          
							document.querySelector('#bricks')
							.innerHtml = bricksTotal 
						
							// GET BRICKWALL NAME
							var BWName = stage.stage_brickwall_name// CREATE THUMB
							var thumb = document.createElement('img')
								thumb.src = 'game_assets/thumbnails/'+BWName+'.png'
								li.append(thumb)
							Description(li, objective)
						break;
						case 'targets':
						
						// INIT INGAME INTERFACE FIELD
						document.querySelector('#targets')
						.classList.remove('hidden')
						
						/*
							GENERATE AS MANY TARGET FIELDS AS THERE ARE TARGETS:
							#target
								#targetName
									.targetName
									count
						*/
						objective.value.some(function(item,idx){
							
							console.log(item.name)
							
							let container = document.createElement('div')
								var classes = item.name.split('.')
								var className = classes[0]
									container.setAttribute('id',className)
									
							let icon = document.createElement('img')						
								
							var spriteName = entities.find( ({ name }) 	=> name === item.name ).DEFAULT
							
							src = spriteName							
							   
								icon.src = 'game_assets/thumbnails/'+src+'.png'  

								icon.classList.add(className)
								container.append(icon)
								container.append(item.count)

							document.querySelector('#UI_wrapper #targets').append(container)
						})
						/* END OF TARGET FIELDS GENERATION */
						
						
						var ul = document.createElement('ul')
							li.append(ul)
							ul = li.querySelector('ul')
							objective.value.some(function(obj, idx){  
								var tLi = document.createElement('li')
								var spriteName = entities.find( ({ name }) => name === obj.name ).DEFAULT 
								var count = objective.value.find( ({ name }) => name === obj.name).count
								var spanValue = document.createElement('span')
									spanValue.classList = 'valueHolder'
									spanValue.textContent = count
								// CREATE THUMB
								var thumb = document.createElement('img')
								thumb.src = 'game_assets/thumbnails/'+spriteName+'.png'     
								tLi.append(thumb)    
								tLi.append(spanValue) 
								ul.append(tLi)   
							})
							Description(li, objective)
						break;

						case 'escortees':
						
						// INIT INGAME INTERFACE FIELD
						document.querySelector('#escortees')
						.classList.remove('hidden')
						
						/*
							GENERATE AS MANY TARGET FIELDS AS THERE ARE TARGETS:
							#target
								#targetName
									.targetName
									count
						*/
						objective.value.some(function(item,idx){
							
							console.log(item.name)
							
							let container = document.createElement('div')
								var classes = item.name.split('.')
								var className = classes[0]
									container.setAttribute('id',className)
									
							let icon = document.createElement('img')						
							
								
								console.log("9224 item: "+item)
							var spriteName = entities.find( ({ name }) 	=> name === item.name ).DEFAULT
							
							src = spriteName
														   
								icon.src = 'game_assets/thumbnails/'+src+'.png'  

								icon.classList.add(className)
								container.append(icon)
								container.append(item.count)

							document.querySelector('#UI_wrapper #escortees').append(container)
						})
						/* END OF TARGET FIELDS GENERATION */
											
						var ul = document.createElement('ul')
							li.append(ul)
							ul = li.querySelector('ul')
							objective.value.some(function(obj, idx){  
								var tLi = document.createElement('li')
								var spriteName = entities.find( ({ name }) => name === obj.name ).DEFAULT 
								var count = objective.value.find( ({ name }) => name === obj.name).count
								var spanValue = document.createElement('span')
									spanValue.classList = 'valueHolder'
									spanValue.textContent = count
								// CREATE THUMB
								var thumb = document.createElement('img')
								thumb.src = 'game_assets/thumbnails/'+spriteName+'.png'     
								tLi.append(thumb)    
								tLi.append(spanValue) 
								ul.append(tLi)   
							})
							
							Description(li, objective)
							.then(function(){
								
								if( typeof maxCasualties !== 'undefined' ){		
									if( maxCasualties !='' ){								
										let mc = document.createElement('span')
											mc.classList.add('maxCasualties')
										let mcn = document.createElement('span')
											mcn.classList.add('maxCasualtiesNumber')
											mcn.innerHTML = maxCasualties										
										mc.append(mcn)
										document.querySelector('#stageDetails .escortees')
										.append(mc)									
									}
								}
								
							})
							
						break;

					}
					
					
					li.classList = objective.name					
					objectivesList.append(li)				
				}			
			})
			
			let objectivesHaveEscortees = objectives.find((e)=>{
				return e.name == 'escortees'
			})
			
			/*
				IF THERE IS NO escortees OBJECTIVE
					IF maxCasualties is defined
					Display maxCasualties in the objectives	-- bhegin		
			*/			
			if( objectivesHaveEscortees == null 
				&& maxCasualties != ''
			){
											
					let mc = document.createElement('span')
						mc.classList.add('maxCasualties')
					let mcn = document.createElement('span')
						mcn.classList.add('maxCasualtiesNumber')
						mcn.innerHTML = maxCasualties										
					mc.append(mcn)

					/*
						IF THERE IS NO OBJECTIVE LI
						ADD A LI TO display maxCasualties
					*/
					let objLis = document.querySelector('#stageDetails ul.objectivesList li')
					if(objLis === null){
						let mcLi = document.createElement('li')
							mcLi.classList.add('maxCasualtiesLi')	
							mcLi.append(mc)

							document.querySelector('#stageDetails ul.objectivesList')
							.append(mcLi)
									
					}
					else{	
						// Display maxCasualtiues in the first objectives li
						document.querySelector('#stageDetails ul.objectivesList li:first-child')
						.append(mc)
					}
					
				
				
			}
			/*
				IF THERE IS NO escortees OBJECTIVE
					IF maxCasualties is defined
					Display maxCasualties in the objectives -- end	
			*/	
			
			
			/*
				SCORE AND GOLD
			*/		
			stage.earnedGold = 0
			stage.score = 0
					
			updateScoreGoldLives('stageDetails .score-gold')
					
			/*
				STARS:
				stage.casualties // how many spawnBalls lost during the stage
			*/
			stage.casualties = 0
			stage.timesUsedWeapons = 0
			
			if( typeof stage.maxCasualties !== undefined ){
				maxCasualties = stage.maxCasualties
			}
			
			
			//alert(stage.maxCasualties+ ' ' +maxCasualties)
			
			/*
			IF EXIST, GET STAGE ACHIEVEMENTS FROM DB: stages
				DISPLAY THE NUMBER OF STARS MATCHING THE VALUE OF db.stages.stage   
			- stars // can be used for ranking players on website later 
			*/
			spawn(function* (){
				var starsHolder =	document.querySelector('#stageDetails .UI-stage-3-stars-360x160')
					starsHolder.classList.remove('s1','s2','s3')
				// GET PROFILE WHERE campaignId > 0
				var profile = yield db.profile.where('campaignId').above(0).first()
				var campaignId = profile.campaignId
				var stageName = stage.name
				var stagesStage = 
				
				yield db.stages.get({name:stageName, campaignId: campaignId})
				.then(()=>{
					document.querySelector('#loadingStatusContainer').classList.add('hiddenUIBtn');
					resolve()
				})
				.catch(()=>{
					// TRY AGAIN ONE TIME
					stagesStage = db.stages.get({name:stageName, campaignId: campaignId})
					.then(()=>{
						document.querySelector('#loadingStatusContainer').classList.add('hiddenUIBtn');	
						resolve()
					})					
				})
							
				 // THIS STAGE IS ALREADY RECORDED IN stages
				 if(stagesStage != undefined) {
				   // GET STARS AND DISPLAY THE RELEVANT SPRITE IN STARSHOLDER
				   var stars = 's'+stagesStage.stars           
				   //  sprite UI-stage-3-stars-360x160 
				   // s1 / s2 / s3
				   starsHolder.classList.add(stars) 

				   ////console.clear()
				   console.log("stagesStage: "+stagesStage)
				 }
				 else{
					 
				 }
				
				
				
				
				if(Arguments.length == 2){
					
					if(Arguments[1]=='stage_replay'){			
						/*
							SHOW STAGE DETAILS SCREEN
								AFTER IT GOT UPDATED
								AFTER USER PUSHED ON [replay] BTN
						*/
						UI_display_selected_stage_fromReplayBtn()
					}else if(Arguments[1]=='stage_next'){			
						/*
							SHOW STAGE DETAILS SCREEN
								AFTER IT GOT UPDATED
								AFTER USER PUSHED ON [next] BTN
						*/
						showBriefingOrNot()
						UI_display_selected_stage_fromNextBtn()
					} 
				 }
				 else{
					 showPage('stageDetails')
					 // STAGE DETAILS: SHOW[PLAY]
					toggleButtonsVisibility([					
						{
							selector:'#stageDetails .stageDetailsControls .stage_play',
							removeClass: 'hiddenUIBtn',
							addClass:''
						}]				
					)		
					document.querySelector('#stageDetails').classList.add('UI-animation-down')	
					
					showBriefingOrNot()
				  }	     
					
			}) // end spawn()
		
		})// new Promise
				
	}// loadStageFromStages()

window.showBriefing = function(){
	
	let closeAfter = null
	
	if( arguments.length == 1 ){
		closeAfter = arguments[0]
	}
	
	if( typeof(stage.briefing) != 'undefined' ){		
		setTimeout(function(){
			modal('modal', "Briefing",'missionBriefing',100000000 )
			
			setTimeout(initiateWritingBriefing(closeAfter),1000)
					
		
			if( document.querySelectorAll('.btnCloseBriefing').length < 1 ){	
				let Btn = document.createElement('a')
					Btn.setAttribute('href','#')
					Btn.classList.add('ui-stage-close-btn-47x47')
					Btn.classList.add('btnCloseBriefing')
					Btn.classList.add('UI-animation-down')
										
					let m = document.querySelector('#modal')
					m.parentNode.insertBefore(Btn, m);			
					//document.querySelector('#stageDetails').append(Btn)
			}
			
		},1000);	
	}
}

window.hideBriefing = function(){
	if( typeof BriefingContainerStr != 'undefined' ){	
		N = BriefingContainerStr.length;// STOP LETTER BY LETTER BRIEFING DISPLAY IF STILL ONGOING
	}
	document.querySelector('#modal').classList.remove('missionBriefing')
	document.querySelector('#modal').classList.remove('fullScreenPage')
	if( document.querySelectorAll('.btnCloseBriefing').length > 0){
		document.querySelector('.btnCloseBriefing').remove()
	}
}

window.hideHowTo = function(){	
	document.querySelector('#modal').classList.remove('howTo')
	document.querySelector('#modal').classList.remove('fullScreenPage')	
	if( document.querySelectorAll('.btnCloseHowTo').length > 0){
		document.querySelector('.btnCloseHowTo').remove()
	}
}	

window.showHowTo = function(){	
	document.querySelector('#modal').classList.add('howTo')
	setTimeout(function(){
	//let message = 'CONTROLS<br><br> MOVE:<br><ul><li><span>&uarr;</span><span>&larr;&darr;&rarr;</span><br>OR<br></li><li><span>mouse</span></li><li><br></li><li>ITEMS/WEAPONS:</li><li><br></li><li>slot 1: F</li><li>slot 2: G</li><li>slot 3: H</li></ul>'
	let message = " "
		
		
		modal('modal', message,'howTo',-1 )
		
		if( document.querySelectorAll('.btnCloseHowTo').length < 1 ){	
			let Btn = document.createElement('a')
				Btn.setAttribute('href','#')
				Btn.classList.add('ui-stage-close-btn-47x47')
				Btn.classList.add('btnCloseHowTo')
				Btn.classList.add('UI-animation-down')										
				let m = document.querySelector('#modal')
				m.parentNode.insertBefore(Btn, m);							
		}
		
	},1000)
}	
		
window.updateScoreGoldLives = function(pageSelector){	
	
	spawn(function* (){
		
		// GET DB.profile.gold, UPDATE .gold
		profile.gold = yield db.profile.where({id:1}).toArray(function(i){
		   var gld = ( isNaN( parseInt(i[0].gold) ) )?0:parseInt(i[0].gold)           
		   console.log('gld:'+gld)
		   return gld
		})
		gold = profile.gold
		console.log('gold:'+gold)
		document.querySelector('#'+pageSelector+' .gold').textContent = gold
		
		
		// GET DB.character.lives, UPDATE lives
		profile.character.lives = yield db.character.where({profileId:1}).toArray(function(i){
		   var lives = ( isNaN( parseInt(i[0].lives) ) )?0:parseInt(i[0].lives)           
		   console.log('lives:'+lives)	
		   return lives		   
		})
		lives = profile.character.lives
				
		// GET DB.profile.score, UPDATE .score
		profile.score = yield db.profile.where({id:1}).toArray(function(i){
		   var scr = ( isNaN( parseInt(i[0].score) ) )?0:parseInt(i[0].score)           
		   console.log('scr:'+scr)
		   return scr
		})
		
		score = profile.score
		
		console.log('score:'+score)		
		
		document.querySelector('#'+pageSelector+' .score').textContent = score
		document.querySelector('#stageSelection #stageSelectionHeader #totalScore').textContent = score
		
	})
	
	//document.querySelector('#'+pageSelector+' .gold').textContent = gold
	document.querySelector('#'+pageSelector+' .score').textContent = score
}

/*
	INCREASE THE SCORE 
	score += .strength * current combos
*/
function Score(sprite){
	let stageScore = parseInt(stage.score)
	 stageScore += sprite.strength * ( paddle.currentCombo > 0)
	 ?
	 parseInt(paddle.currentCombo):1
	 
	 console.log('Score - stageScore: '+stageScore)
	 
	 stage.score = parseInt(stageScore)
	 
	 writeScore() // UPDATE INGAME SCORE FIELD 
}

/*
	SPAWN GOLD COINS RANDOMLY AROUND :
			- AN ENNEMY AFTER ITS BEEN DEFEATED
			- A TARGET THAT HAS BEEN ELIMINATED	
*/
function spawnGoldCoins(sprite){
	     
		 for( let amount = sprite.strength; amount > 0; amount--){
			 
			 let 
			 x = parseInt(sprite.x) + parseInt(sprite.width/2),
			 y = parseInt(sprite.y) + parseInt(sprite.height/2),
			 dx = getRandomArbitrary(-1, 1),
			 dy = getRandomArbitrary(-1, 1)
			 
             paramsObject = {
				x:x,
				y:y,
				dx:dx,
				dy:dy
			}
			 
			 //spawnEntityFromJson('gold-coin-16x16.ent',paramsObject)
			 spawnEntityFromJson('gold-coin-12.5x13.ent',paramsObject)
		 }
	 
}


 window.setPaddleSprite = function(spriteName){
	var name = spriteName
	
	var frameObject = search(name, spriteFrames);
	////////////alert(typeof frameObject)
	if( typeof frameObject !== 'undefined' ){	
		paddle.spriteFrames = frameObject
		
		paddle.width = frameObject.width // sprite frame width
		paddle.height = frameObject.height // sprite frame
		
		paddleWidth = paddle.width
		paddleHeight = paddle.height	
		
		paddle.frame = parseInt(frameObject.frame) // default sprite frame
		paddle.frameMax = parseInt(frameObject.frameMax) // when frame == frameMax, reset sprite animation to frame 0 		
		paddle.frameTicker = parseInt(frameObject.frameTicker) // ticker for switching to next sprite  frame
		paddle.nextFrameAt = parseInt(frameObject.nextFrameAt) // when ticker == nextFrameAt, switch to next frame 				
	}

}




//
//
//  STAGES MANAGEMENT -- end
//
//



//
//
//	TOUCH EVENTS -- begin
//
//
		
		window.touchEventsInit = function() {			
		 let el = document.getElementById("combo");
			 /*  el.addEventListener("touchstart", handleStart, false);
			  el.addEventListener("touchend", handleEnd, false);			
			  el.addEventListener("touchmove", handleMove, false);*/
				el.addEventListener("touchstart", touchMove, false);
				el.addEventListener("touchmove", touchMove, false);
				el.addEventListener("touchend", touchMove, false); 
		}
		
		window.mouseEventsInit = function(){			
			  let el = document.getElementById("combo");
			  el.addEventListener('mousemove', movePaddleMouse )
		}
		
		window.mouseEventsReset = function(){			
			  let el = document.getElementById("combo");
			  el.removeEventListener("mousemove", movePaddleMouse)
			  
		}
		
		
		window.keyPressEventsInit = function(){
			  
			  function logKey(e) {
				//console.clear()
				console.log( `${e.code}` );
				console.log( JSON.stringify(e) );
				console.log( JSON.stringify(e.code) );
				////////////alert(e.code)
			  }
			  	
			  function keyToAction(e) {
				  
				if( stage.ingame == true ) {
					/*
					//console.clear()
					console.log( `${e.code}` );*/
					//var inventoryItems = document.querySelectorAll('#weaponsList li a.equip_weapon')
					var inventoryItems = document.querySelectorAll('#weaponsList li')
					var countItems = inventoryItems.length
					var tgt = null		
														
					
					switch( e.code ){						
						
						case 'ArrowUp':// UP							
							if( paddle.dy == -1 ){
								paddle.dy = 0
							}
							return							
						break;
						case 'ArrowDown':// DOWN							
							if( paddle.dy == 1 ){
								paddle.dy = 0
							}
							return
						break;
						case 'ArrowLeft':// LEFT							
							if( paddle.dx == -1 ){
								paddle.dx = 0
							}
							return
						break;
						case 'ArrowRight':// RIGHT							
							if( paddle.dx == 1 ){
								paddle.dx = 0
							}
							return
						break;												
						
						case 'KeyF':// ITEM 1
						  if( countItems > 0 ){
							 tgt = inventoryItems[0].querySelector('.equip_weapon')
						  }  			
						break;
						
						case 'KeyG':// ITEM 2
						  if( countItems > 1 ){
							 tgt = inventoryItems[1].querySelector('.equip_weapon')
						  }  			
						break;
						
						case 'KeyH':// ITEM 3
						  if( countItems > 2 ){
							 tgt = inventoryItems[2].querySelector('.equip_weapon')
						  }  
						break;
						
						case 'Space':// PAUSE
						case 'KeyP':
							// DUPLICATE OF BTN CLICK EVENT
							if( paused == false ){	
								hidePage( 'UI_wrapper' )
								pause()			
								paused = true
								// SHOW THE pauseScreen ONLY
								hideAllPagesExcept('pauseScreen')
								return
							}else{			
								paused = false			
								// HIDE ALL SCREENS EXCEPT THE MAIN STAGE
								hideAllPagesExcept('UI_wrapper')
								resume()
								return
							}							
						break;
						default:
							return
						break;
					}
					
					if( tgt !== null ){
					
						if( tgt.getAttribute('count') == 0  ){
							tgt.setAttribute('count','+')
							//////////alert('BUY ITEM')
							return
						} 
						else if( tgt.getAttribute('count') == '+'  ){
							//////////alert('BUY ITEM')
							return
						}
						else if( tgt.getAttribute('count') > 0  ){
							var paramsObject = {
								category: tgt.getAttribute('category'),
								entityName :tgt.getAttribute('entityName'),    
								duration: tgt.getAttribute('duration'),
								count: tgt.getAttribute('count')
							}		
							/* 
								EQUIP PADDLE WITH SELECTED WEAPON
									UPDATE THIS WEAPON'S COUNT IN #weaponsList					
							*/
							
							equipWeapon(paramsObject)
							return
						}
					}
				}
				else if(
					// IF CHARACTERS SELECTION SCREEN IS SHOWING....
					document.querySelector('#characterSelection').classList.contains('fullScreenPage') === true
				){
					/*
						SELECT CHARACTER WITH KEYBOARD ARROW KEYS
					*/					
					var Href = document.querySelector('#characterSelection #charList li.selected a').getAttribute('href')		
					var idx = parseInt(Href.substr(1,1))//keep the N, not the #	
					if( 
						e.code == 'ArrowRight'
					){			
						idx ++// add +1 to idx
							
					}else if( 
						e.code == 'ArrowLeft'
					){			
						idx --// add +1 to idx									
					}else if( 
						e.code == 'Space'
					){			
						/*
							CONFIRM CHARACTER SELECTION
						*/
						if(							
							document.querySelectorAll('#charDescriptions .char.selected').length > 0 
						){
							document.querySelector('#charDescriptions .char.selected a').click()							
							return // CHARACTER HAS BEEN SELECTED
						}
						return // USER PUSHED [SPACE]
					}
					else{
						return
					}
					if(idx > 2){idx = 3;}
					if(idx < 1){idx = 0;}		
					if( document.querySelectorAll('#characterSelection #charList li.selected').length > 0 ){
						document.querySelector('#characterSelection #charList li.selected').classList.remove('selected')
						document.querySelector('a[href="#'+idx+'"]').parentElement.classList.add('selected')
					}
					else if( document.querySelectorAll('#characterSelection #charList li.selected').length < 1 ){
						document.querySelectorAll('#characterSelection #charList li')[0].classList.add('selected')
					}		
					document.location.href = '#charLi'+idx;		
					if( document.querySelectorAll('#charDescriptions .char.selected').length > 0 ){
						document.querySelector('#charDescriptions .char.selected').classList.remove('selected')			
					}		
					showChar( idx )
					sounds[0].play()// hey!						
					if(document.querySelector('#charLi'+idx).classList.contains('selected') === true){		
						spitCupidHearts()
					}else{
						window.clearTimeout(spitHearts)
					}		
					return					
								
				}//else
				
				
			  }	

			  
			  document.body.addEventListener('keyup', keyToAction);
			  
			  
		}	
		
		
		window.keyDownEventsInit = function(){
			  
			  function logKey(e) {
				//console.clear()
				console.log( `${e.code}` );
				console.log( JSON.stringify(e) );
				console.log( JSON.stringify(e.code) );
				////////////alert(e.code)
			  }
			  	
			  function keyToAction(e) {
				  
				if( stage.ingame == true ) {
					/*
					//console.clear()*/
					console.log( `${e.code}` );
							
					let x = parseInt(paddleX)
					let y = parseInt(paddleY)
					
					switch( e.code ){						
						case 'ArrowUp':// UP							
							paddle.dy = -1
							
							return							
						break;
						case 'ArrowDown':// DOWN							
							paddle.dy = 1	
							//paddle.dx = 0;
							return							
						break;
						case 'ArrowLeft':// LEFT							
							paddle.dx = -1
							return							
						break;
						case 'ArrowRight':// RIGHT							
							paddle.dx = 1
							return							
						break;												
						default:							
							return
						break;
					}	
						/*
						paddleX = x + parseInt(paddle.dx)
						paddleY = y + parseInt(paddle.dy)
						paddle.x = paddleX
						paddle.y = paddleY	*/						
				}
			  }				
			  document.body.addEventListener('keydown', keyToAction);
		}	

				
				
		function movePaddleMouse(evt){
			let el = document.getElementById("combo"),			
				x = evt.clientX,
				y = evt.clientY
/*
			console.log('x: '+x+ ' - ' +'y: '+y)
			console.log('evt.clientX: '+evt.clientX+ ' - ' +'evt.clientY: '+evt.clientY)
			console.log('evt.pageX: '+evt.pageX+ ' - ' +'evt.pageY: '+evt.pageY)
	*/		
			
			paddleX = x - el.offsetLeft/* - paddleWidth/2*/
			paddleY = y - el.offsetTop - paddleHeight/2
			
			paddle.x = paddleX - el.clientX
			paddle.y = paddleY - el.clientY
			
			/*
			let relativeX = x - el.offsetLeft;
			if(relativeX > 0 && relativeX < el.width) {
				paddleX = x	- paddleWidth/2;				
			}
			let relativeY = y - el.offsetTop;
			if(relativeY > 0 && relativeY < el.height) {
				paddleY = y - paddleHeight/2 - paddleHeight;				
				paddle.x = paddleX
				paddle.y = paddleY		
			}*/
			
			if( paddle.weapon.indexOf('portal') !=-1 ){
			  var portal = search('angel-portal.ent',balls)
			  		  
			  
			  if( typeof(portal) !== 'undefined' ){
				//var portal_idx = balls.findIndex(portal)
				portal.x = parseInt(paddleX) + parseInt(paddle.width)/2 - parseInt(portal.width)/2
				portal.y = paddleY - parseInt(portal.height)*0.80
			  }	
			}
			
		}	
		
		function handleStart(evt) {
		  evt.preventDefault();				  
		  movePaddle(evt)
		}
		
		function handleMove(evt) {		 
			evt.preventDefault();
			movePaddle(evt)
		}
		
		function handleEnd(evt) {
			evt.preventDefault();
			movePaddle(evt)		 
		}		
		
		
		window.touchMove = function(event) {
			
           let l = touches.length-1,
			  x = event.touches[0].clientX,
			  y = event.touches[0].clientY	
		   /*
		   var x = event.touches[l].clientX;
		   var y = event.touches[l].clientY;
		   */
		   let el = document.getElementById("combo");		   		  
			let relativeX = x - el.offsetLeft;
			if(relativeX > 0 && relativeX <= el.width) {
				paddleX = x - paddleWidth/2;			
			}
			let relativeY = y - el.offsetTop;
			if(relativeY > 0 && relativeY <= el.height) {
				paddleY = y - paddleHeight/2 - paddleHeight;
			}
			paddle.x = paddleX
			paddle.y = paddleY	
			if( paddle.weapon == 'portal' ){
				var portal = search('angel-portal.ent',balls)
				if( typeof(portal) !== 'undefined' ){				
					portal.x = paddle.x
					portal.y = paddle.y
				}	
			}
		}
		
		/*
			ON TOUCH
			UPDATE paddleX & paddleY ON CANVAS #sky			
		*/
		function movePaddle(evt){
			let el = document.getElementById("combo");
			let touches = evt.changedTouches;
			let l = touches.length-1,
			  x = touches[l].pageX,
			  y = touches[l].pageY
			
			let relativeX = x - canvas.offsetLeft;
			if(relativeX > 0 && relativeX <= canvas.width) {
				paddleX = x - paddleWidth/2;			
			}

			let relativeY = y - canvas.offsetTop;
			if(relativeY > 0 && relativeY <= canvas.height) {
				paddleY = y - paddleHeight/2 - paddleHeight;
			}
			paddle.x = paddleX
			paddle.y = paddleY

			if( paddle.weapon == 'portal' ){
			  var portal = search('angel-portal.ent',balls)
			  if( typeof(portal) !== 'undefined' ){
				//var portal_idx = balls.findIndex(portal)
				portal.x = paddle.x
				portal.y = paddle.y
			  }	
			}
			
			
		}
		
		function log(msg) {
		/*
			let p = document.getElementById('log');
			p.innerHTML = msg + "\n" + p.innerHTML;/*/	
		}
		
//
//
//	TOUCH EVENTS --end
//
//	

//
//  DRAW PADDLE
//
		function drawPaddle() {			
			animateSprite( paddle )	
		}


		function sortFunction(a, b) {
			  if (a[0] === b[0]) {
				  return 0;
			  }
			  else {
				  return (a[0] < b[0]) ? -1 : 1;
			  }
		  }
		
		function Distance2D( x1,  y1,  x2, y2)
		  {
			var result = 0;
			var part1 = Math.pow((x2 - x1), 2);
			var part2 = Math.pow((y2 - y1), 2);
			var underRadical = part1 + part2;
			result = parseInt(Math.sqrt(underRadical));
			return result;
		  }

		

		 function collisionDetection( ball ) {
			
		
			
		var idx = 0; // to refer to wallBrickMapEnergy
			for( let c = 0; c<brickColumnCount; c++) {
				for( let r = 0; r<brickRowCount; r++) {
				  let b = bricks[c][r];
				  
				  /*
				  if(
					typeof(wallBrickMapEnergyInitial[idx]) === 'undefined'
					|| wallBrickMapEnergyInitial[idx] == undefined
				  ) {
					  continue
				  }*/
				  
				  if(b.status > -1) {
					  
					var   
					blX = ball.x,
					blY = ball.y,
					blW = ball.width,
					blH = ball.height,
					blDx = Math.abs(ball.dx),
					blDy = Math.abs(ball.dy),
					brX = b.x,
					brY = b.y,
					brW = brickWidth,
					brH = brickHeight,
					b_idx = idx
					 
					var dataObject = {
						ball:ball,
						blX:blX,
						blY:blY,
						blW:blW,
						blH:blH,
						blDx:blDx,
						blDy:blDy,
						brX:brX,						
						brY:brY,
						brW:brW,
						brH:brH,
						bounceAgainst: 'brickwall'
					} 
					
					/*
						if ballstopAllPlayingSounds() within exterior hitbox
						test collision to determine rebound
					*/
					 
					if( 
						ball.x+ball.width >= b.x && ball.x/*+ball.width*/ <= b.x+brickWidth 
					 && ball.y+ball.height >= b.y && ball.y/*+ball.height*/ <= b.y+brickHeight
					 
					 ){
						 
					var s = {
						x:ball.x,
						y:ball.y,
						w:brickWidth,
						h:brickHeight,
						entityName: 'small-collision-48x48.ent',								 
						iDx:ball.iDx
					}									
					collisionSparkle(s)	
					
					 var damage = ball.strength
					if( damage < 1){ damage = 0 }
					

					console.log( 'ball: '+ball )
					console.log( 'damage: '+damage )
					//pause()
					 /*
						ball IS A PUNCHED ENNEMY COLLIDING WITH THE BW
					 */
					 if(ball.type == 'punched'){
						 /*
							PUNCHED ENEMY COLLIDE WITH BRICKS
								ball.energy -=ball.ball.strength
						 
						 */
						 
						 
						
							
							/*
								INIT FADING OUT ENERGY POINTS
							*/
							var energyObject = {								
								color: [254,254,254],
								pointsAmount: damage,
								sign: -1,
								impactObject: ball //can be a ball or a sprite, used for its x,y,dx,dy
							}
							
							initEnergyPointFadeOut( energyObject )
							
							ball.energy -= damage
																
							//shakeCanvas(ball.drawOnCanvas)					
							shakeCanvas('ground')					
						 
						 if( ball.energy <= 0 ){
							 
							spawnGoldCoins(ball)
							//var entityName = ball.name
							
							// + ADD THIS SPRITE TO THE LIST OF SPRITES ELIMINATED
							spritesEliminated [ spritesEliminated.length ] = ball
							
							var Location = {
								 x:parseInt(ball.x),
								 y:parseInt(ball.y),	
							} 
							spawnEntityFromJson('disappear-600x100.ent',Location)						
							//balls.splice(ball.ball_idx,1)
							//balls.splice(iDx,1)
							 removeObjectByItsIdxValue(balls,'iDx',ball.iDx)		
							// CHECK IF THEE IS NO MORE TARGETS IN objectives[]
							checkRelevantObjectiveCompletion('targets')
							
						 }
					 }//  if(ball.type == 'punched'){
					
					
					// NOTE ball.ball_idx is available
					// IN THIS FUNCTION ONLY
					if( ball.collideWithBWRemove == true )	{
						//if( balls[ball.ball_idx] != undefined ){
						if( balls[ball.ball_idx] != undefined ){
							balls.splice(ball.ball_idx,1)
							 //removeObjectByItsIdxValue(balls,'iDx',ball.iDx)		
						}
				    }
					
					if( ball.collideWithBWBounce == true )	{						
						if( dataObject.ball != undefined ){
							bounceObject(dataObject)
						}
				    }
					
					  /*
						IF BRICK IS NOT INDESTRUCTIBLE:
							- brick loses energy
							- if its energy level reaches 0, it disappears
							- bricksTotal decremented, 
								if bricksTotal == 0,
									stage OVER
					  */
					  //if( wallBrickMapEnergy[idx] != 'I' ){
					  /*
						wallBrickMapEnergy[idx] == -1, brick is indestructible
					  */
					  /*
					  ////console.clear()
					  console.log('wallBrickMapEnergyInitial[idx]:'+wallBrickMapEnergyInitial[idx])
					  console.log('wallBrickMapEnergy[idx]:'+wallBrickMapEnergy[idx])
					  console.log('wallBrickMapEnergyInitial[idx] !== "undefined":'+wallBrickMapEnergyInitial[idx] !== 'undefined')
					  console.log('wallBrickMapEnergy[idx] !== "undefined":'+wallBrickMapEnergy[idx] !== 'undefined')
					  */
					  /*
					  if( wallBrickMapEnergyInitial[idx] == -1 ){
						  continue
					  }
					  */
					  
					  if( 
						wallBrickMapEnergyInitial[idx] !== 'undefined'
						&& wallBrickMapEnergyInitial[idx] != -1
					  ){
												
						 if( wallBrickMapEnergyInitial[idx] > -3/* >-1 is destructible */ ){
							
						  // ADDSCORE
						  var sprite = {strength:wallBrickMapEnergyInitial[idx]}						
						  Score(sprite)
						  
						    if( ball.name.indexOf('arrow') == -1 ){															
								// tik
								sounds[4].play();								
							}
							else{
								
								if(
									/*sprite.type.indexOf('obstacle') == -1
									&& */ball.type.indexOf('obstacle') == -1
								){ 
									// bounce1
									sounds[2].play();
								}
								
							}		
						  
							  var paramsObject = {
								 x:parseInt(ball.x),
								 y:parseInt(ball.y),
								 width:parseInt(ball.width),
								 height:parseInt(ball.height)
								}
								
								if( damage > 0){		
									hitCombo(paramsObject)
								}
						 }/* is destructible */
						 						
						  

						  // HERE
						  wallBrickMapEnergy[idx] -= ball.strength; // brick.energy -= ball.strength
						  
						  //if( wallBrickMapEnergy[idx] < 1){
						  if( wallBrickMapEnergy[idx] <= 0){
							/*
								instanciate brickObject -- begin
							*/
							/*
								brickWallSkin = color:
									for one disappearing brick, 
									make one brick of the same color, 
									then fade it away
									
								brickWallSkin = img
									
								
							*/
							var color = (brickWallSkin=='color')?colors[wallBrickMap[idx]]:'#f00'							

							var rgbColor = hexToRGB(color),
								strokeColorDefault = '#000',
								strokeColor = hexToRGB(strokeColorDefault)

							var idx = brickObjects.length
							var brickObject = {
								step: 1,
								steps: 10,
								opacity: 1,
								color: rgbColor,
								strokeColor: strokeColor,
								idx: brickObjects.length,
								b_idx: b_idx, 
								x: brX,
								y: brY,
								w: brW,
								h: brH    
							}

							brickObjects[idx] = brickObject
							
							brickObject.strength = 10
							brickObject.width = brickObject.w
							brickObject.height = brickObject.h					
							spawnGoldCoins(brickObject)
							
							/*
								instanciate brickObject -- end
							*/
						  
						  
							b.status = -1;
							bricksTotal --;	
							
							 
						  //if(score == brickRowCount*brickColumnCount) {
						  if( bricksTotal == 0 ) {
							
							/*
								IF destroyBW == true
									register OBJECTIVE AS COMPLETED
							*/
							/*var destroyBW = search('destroyBW', objectives)							
							if( typeof destroyBW !=='undefined' ){
								if( destroyBW.value == true ){
									// MARK THIS OBJECTIVE AS COMPLETE
									destroyBW.status = 'complete'
									checkAllObjectivesComplete()
									//////////////alert(destroyBW.messageSuccess)
								}
							}  
							*/
							
							var objectiveName = 'destroyBW'
							checkRelevantObjectiveCompletion( objectiveName )
							
						  }else{
							  writeBricksRemaining()
						  }

						}
						  
						 // console.log('bricksTotal: '+bricksTotal)
					  }
					  else if(typeof sprite != 'undefined') {
							 // IMPACT SOUND - no damage
							if( typeof sprite != 'undefined' ){		
								if( sprite.type.indexOf('obstacle') == -1
									&& ball.type.indexOf('obstacle') == -1){
									sounds[5].play();// missed
								}	
							}	
						 }	
					  //swapSprite(ball)					  
					  return true					  
					}
				  }
				  idx++;
				}
			}
		}// collisionDetection = function( ball )
		
		
		/*
			function checkAllObjectiveComplete()
			DOES:
				RETURN ARRAY OF OBJECTIVES NOT MARKED COMPLETE 
						
		*/
		function getRemainingObjectives(){			
			return Array.prototype.filter.call(objectives,function(objective){
				return objective//(typeof objective.status === 'undefined')				
			})
		}
		
		function teleport_back(When){
			
				// Clearing the electricArc canvas
				ctx.clearRect(0,0,can.width,can.height);
				
				if(				
					displayAngel !== false
				)
				{
			
				setTimeout(
				function(){
					
					if(				
						displayAngel !== false
					)
					{	
						var params = {
							x: paddleX,
							y: paddleY - 650
						}
						
						paddle.invincibility = -1
						
						spawnEntityFromJson('teleportation-back.ent',params)
						displayAngel = false
						
						
						// STOP BGM
						stopAllPlayingSounds()				
						
						sounds[9].play()
						return
					}
				},When)
				}// if
			
		}// function
		
		/*
			function checkAllObjectivesComplete()
			DOES	
				CHECK IF ALL OBJECTIVES HAVE BEEN COMPLETED
					IF SO
						STOP MAIN LOOP						
						DISPLAY ACHIEVEMENTS
						UNLOCK NEXT LEVEL IF NOT UNLOCKED ALREADY
		*/
		function checkAllObjectivesComplete(){
						
			if( 
				displayAngel === false
				|| stageEnded === true
				|| stage.ingame === false
			){
				return true				
			}
			
			//stage.ingame = false
			
			/* 
				IF ALL OBJECTIVES HAVE BEEN COMPLETED
					STOP MAIN LOOP
			*/			
			var remainingObjectives = getRemainingObjectives().length
			
			// TIMER IS NOT REALLY AN OBJECTIVE HENCE THIS LINE	
			// TO NOT COUNT THE TIMER AS AN OBJECTIVE		
			if ( search('timer',objectives) !== 'undefined' 
				&& timer > 0
			){
				remainingObjectives --
			}
			
			/*
			
				IF ALL OBJECTIVES COMPLETED										
					WAIT FOR 5 SECONDS THEN endstage()			
			*/
			if(
				remainingObjectives === 0
				&& stageEnded === false
				&& stage.ingame === true
				&& document.querySelector('#modal').classList.contains('UI-animation-down') === false
			)
			{
				
			/*if( remainingObjectives === 0
				&& stageEnded === false){*/
				
				var message = 
				'Mission complete!'
				+'<br/>'
				+'Congratulations!'
				
								
				modal('modal', message,'UI-animation-down',4000 )
				
				// Clearing the electricArc canvas
				ctx.clearRect(0,0,can.width,can.height);
				
				teleport_back(2000)
				
				paddle.noMorePowerUpsFx = true
				
				//displayAngel = false
				
				setTimeout(
					function(){
						// PAUSE, THEN STOP EVERYTHING
						cancelAnimationFrame(myReq)
						// STOP ALL PLAYING SOUNDS
						stopAllPlayingSounds()				
						// IF RAF LOOPING, THEN EXIT IT 				
						stageEnded = true				
						//////////////alert("YOU WIN, CONGRATS!");
						console.log('if( remainingObjectives == 0 )')
				
						endStage({
							status: 'success',
							reason: 'mission complete!'
						})
					}
				,3000)
				
				return
				// RELOAD PAGE - RESTART THE GAME - WILL BE REPLACED BY GO TO NEXT LEVEL
				//document.location.reload();
			}else{
				
				/*
					TIMEOUT -- begin
				*/
				if ( search('timer',objectives) !== undefined 				
				     && timer <= 0
					 && stageEnded === false					 
					 && stage.ingame === true
					 && document.querySelector('#modal').classList.contains('UI-animation-down') === false
				){
					
					console.log('if( timer == 0){')
					
					var message = 
					'Mission failed!'
					+'<br/>'
					+'Time out!'
					
					modal('modal', message, 'UI-animation-down',4000 )
					
					// Clearing the electricArc canvas
					ctx.clearRect(0,0,can.width,can.height);
					
					paddle.noMorePowerUpsFx = true
					
					teleport_back(2000)
					
					//displayAngel = false
				
					setTimeout(
					function(){
				
						// PAUSE, THEN STOP EVERYTHING
						cancelAnimationFrame(myReq)
						// STOP ALL PLAYING SOUNDS
						stopAllPlayingSounds()					
						
						stageEnded = true					
						endStage({
							status: 'failure',
							reason: 'timeOut'
						})
						}
					,6000)
				}
				/*
					TIMEOUT -- end
				*/				
				return
			}			
		}
		
		
		window.copyHtmlFromTo = function(from,to){
			var objectivesHTML = document.querySelector(from).innerHTML
			document.querySelector(to).innerHTML = objectivesHTML
		}
		
		
		/*
			function endStage( paramsObject )
			
			DOES:
				- DISPLAYS REND STAGE STATUS & RESULTS
				- OFFERS PLAYER TO RETRY OR PROCEED TO NEXT STAGE
			
			PARAMS:
				paramsObject {} - required
					status: 'failure' | 'success'
					reason: 'noLivesLeft' | 'timeOut' | NO REASON FOR SUCCESS 
			
			endStage({
				status: 'failure',
				reason: 'noLivesLeft'
			})						
		
		 endStage(paramsObject)
		*/
		
		 window.endStage = function( paramsObject ){
			
			/* HIDE PAUSE BTN */
			toggleButtonsVisibility([					
				{
					selector: '#pauseBtn',
					removeClass: 'visible',
					addClass:''
				}]				
			) 
			 
			document.querySelector('#casualtiesContainer').classList.add('hidden')
			document.getElementById('casualtiesContainer').classList.remove('critical')
			
			window.starsReasons = []
			
			/*
				DEACTIVATE CLICKABLE BUTTONS 
				TO GIVE TIME TO Dexie DB ACTIVITIES TO HAPPEN
			*/
			switch(paramsObject.reason){
				case 'failure':
				case 'timeOut':
				case 'noLivesLeft':								
					window.uiBtnsClickable = true			
				break;
				default:
					window.uiBtnsClickable = false			
				break;
			}
						
			/*
				IF STAGE ALREADY ENDED
				DO NOT END IT AGAIN
			*/
			if (stage.ingame == false){
				return 
			}
			
			displayAngel = false
			
			stage.ingame = false; // keypress events true | false
			
			// CLEAR CANVASES
			clearAllCanvas()
			
			////////////alert(paramsObject.status + ' \r\n' +paramsObject.reason)
						
			DBupdateWeaponsList()// UPDATE DB WEAPONS RECORDS
			/*
				//////////alert('6591: score' + stage.score +' '+score)
				//////////alert( isNaN(score) )
			*/
			if( isNaN(score) ){
				score = 0				
			}
						 
			totalStars = 1 // 1 star by default for finishing the stage 
			
			let reasonsObj = {}	
				reasonsObj.lbl = 'mission completed'
			starsReasons.push(reasonsObj)

			
			// UPDATE OBJECTIVES - COPY OBJECTIVES FROM #stageDetails
			copyHtmlFromTo('#stageDetails .objectivesList','#endStage .objectivesList')
			
			// REMOVE OBJECTIVE 'TIMER' IF PRESENT
			if( null !== document.querySelector('#endStage .objectivesList li.timer') ){
				document.querySelector('#endStage .objectivesList li.timer').remove()
			}
			
			// UPDATE MISSION - COPY MISSION FROM #stageDetails
			copyHtmlFromTo('#stageDetails .screenTitle','#endStage .screenTitle')
			
			var status = paramsObject.status,
				reason = paramsObject.reason
			
			// UPDATE UI STATUS
			document.querySelector('#endStage .status').classList.remove('success','failure')
			document.querySelector('#endStage .status').textContent = status
			document.querySelector('#endStage .status').classList.add(status)
						
			/*
				UPDATE MIN COMBOS
			*/
			var comboObjective = search('minCombos',stage.objectives)	
			
			if( typeof comboObjective !== 'undefined' ){
			  var performed = paddle.bestStageCombo				
			  var expected = comboObjective.value
			  var diff = performed - expected // difference between performed and expected
			  var diffSign = Math.sign( diff )// -1 | 1  
			  var diffHolder = document.createElement('span')
				  /*
					overbelow:
						'' = neutral
					  .over: greater +
					  .below: .lesser -
					  SHOW DIFFERENCE ONLY IF THERE IS ONE
				  */
				  var overBelow = ''  		
					if( Math.abs(diff) > 0 ){
					overBelow = ( diffSign == 1 )?'over':'below'
					if( overBelow == 'over'){
						totalStars ++ // 1 star by default for doing more combos than required
						reasonsObj = {}
						reasonsObj.lbl = 'more combos!'
						starsReasons.push(reasonsObj)						
						
					}
					diffHolder.classList.add('diffHolder')
					diffHolder.classList.add(overBelow)
					diffHolder.textContent = diff	

					document.querySelector('#endStage .objectivesList li.minCombos .valueHolder')
					.textContent = performed
					
					document.querySelector('#endStage .objectivesList li.minCombos .valueHolder')
					.append(diffHolder)
				  }
			}
			
			// ADD SUCCESS OR FAILURE MARKS
			var endStage = document.getElementById('endStage')// container				
			Array.prototype.some.call(stage.objectives, function(objective){
				// DO NOT DISPLAY THE TIMER
				if( objective.description != "" && objective.name !='timer') {
					var li = document.querySelector('#endStage .objectivesList li.'+objective.name)
					let mark = 'UI-stage-marks-39x39-failure'// OBJECTIVE FAILED BY DEFAULT
											
					if( typeof( search(objective.name, stageAchievements) ) !=='undefined' ){
						// OBJECTIVE COMPLETED
						mark = 'UI-stage-marks-39x39-success'
					}
					
                 var markEl = document.createElement('span')
					 markEl.classList.add('sprite')
					 markEl.classList.add(mark)
						 li.append(markEl)					
					 }			
			})	
			
			// COUNT && POPULATE STARS
			if( status == 'success' ){
	
				if( stage.timesUsedWeapons == 0){
					totalStars ++ // 1 star by default for not using any weapon through the whole stage
					reasonsObj = {}
					reasonsObj.lbl = 'no weapons used!'
					starsReasons.push(reasonsObj)					
				}
				
				/*
					COUNT PLAYER 's BEST COMBO	
				*/				
				var comboObjective = search('minCombos',objectives)				
				if( typeof comboObjective !== 'undefined' ){
					var performed = paddle.bestStageCombo				
					var expected = comboObjective.value
					//console.clear()
					console.log(performed+' '+expected)
				}
				/*
				// PREPARE [NEXT] BUTTON
				var stagesLi = document.querySelector('#stagesList')
				// FIND INDEX OF stageName in stagesList[]
				var idx = parseInt(stagesList.indexOf(stage.name))//stage.name'myFirstStage.stg'
				// IDX +1 : 
				idx += 1
				var a = stagesLi.querySelectorAll('ul li a')
				var nextStage = stagesLi.querySelectorAll('.stage_select')[idx]				
				//
					IF THERE IS A STAGE IN STAGES LIST AFTER THIS ONE
						SET & SHOW [NEXT] THAT LEADS TO IT
				//
				if( typeof(nextStage) !=='undefined' ){					
					var href = nextStage.getAttribute('href')
					// SET [NEXT] HREF
					document.querySelector('.stageDetailsControls .stage_next').setAttribute('href',href)
				}
				*/
				
				//console.log(nextStage)
				
				// SUCCESS: SHOW[NEXT] , HIDE [RETRY], SHOW [REPLAY]
				toggleButtonsVisibility([
					{
						selector:'#stageDetails .stageDetailsControls .stage_play',
						removeClass: '',
						addClass:'hiddenUIBtn'
					},
					{
						selector:'#endStage .stageDetailsControls .stage_replay.ui-stage-buttons-retry',
						removeClass: '',
						addClass:'hiddenUIBtn'
					},
					{
						selector:'#endStage .stageDetailsControls .stage_replay.ui-stage-buttons-replay',
						removeClass: 'hiddenUIBtn',
						addClass: ''
					},
					{
						selector:'#endStage .stageDetailsControls .stage_next',
						removeClass: 'hiddenUIBtn',
						addClass: ''
					}]				
				)
				
			}
			else if( status == 'failure' ){
				// FAIL: SHOW[RETRY] , HIDE [NEXT]
				toggleButtonsVisibility([
					{
						selector:'#endStage .stageDetailsControls .stage_replay.ui-stage-buttons-retry',
						removeClass: 'hiddenUIBtn',
						addClass:''
					},
					{
						selector:'#endStage .stageDetailsControls .stage_next',
						removeClass: '',
						addClass: 'hiddenUIBtn'
					},
					{
						selector:'#stageDetails .stageDetailsControls .stage_play',
						removeClass: '',
						addClass:'hiddenUIBtn'
					},
					{
						selector:'#endStage .stageDetailsControls .stage_replay.ui-stage-buttons-replay',
						removeClass: '',
						addClass: 'hiddenUIBtn'
					}					]				
				)	
			}
			// SHOW #endStage ONLY			
			hideAllPagesExcept('endStage')
			
			if( document.querySelector('#stageDetails').classList.contains('UI-animation-down')){
			  document.querySelector('#stageDetails').classList.remove('UI-animation-down')
			}
			// SLIDE #endStage DOWN
			document.querySelector('#endStage').classList.add('UI-animation-down')
						
			var goldHolder = document.querySelector('#endStage .score-gold .gold')
				goldHolder.textContent = gold			
			
			////////////alert('6763: score' + score)
			var scoreHolder = document.querySelector('#endStage .score-gold .score')		  
				scoreHolder.textContent = score
				
			if( status == 'success' ){
				
				if (parseInt(stage.casualties) == 0){
					totalStars++ // 1 more star for no casualty
					reasonsObj = {}
					reasonsObj.lbl = 'no casualty!'
					starsReasons.push(reasonsObj)
				}
				
				/*
					1-STARS
					2-SCORE
					3-GOLD				
				*/
				setTimeout(function(){
						
						updateStarsHolder()
				},1000)// 3 seconds
			}else{
				/*
				
					FAILURE
				
					1-SCORE
					2-GOLD				
				*/
				/*// UPDATE STAGE SELECT BTN's stars
				
				paramsObject = {
					stageName: stage.name,
					starClass: ''//'s'+totalStars
				}
				updateStageSelectBtnStars(paramsObject)*/
				totalStars = 0
				setTimeout(function(){
					// GET CURRENT VALUE OF score IN DB						
					spawn(function* (){
						try{
							profile.score = yield db.profile.where({id:1}).toArray(function(i){								
								var scr = ( isNaN( i[0].score ) )?0:parseInt(i[0].score) 
								console.log('scr:'+scr)
								return scr
							})
						}
						finally{
							score = parseInt(profile.score)
							console.log('score:'+score)
							document.querySelector('#endStage .score').textContent = score
							incrementScore()							
						}
						
					})
					
					
					// REMOVE #weaponsList IF EXISTS
					var i = document.querySelector('#weaponsSelector #weaponsList') 
					if ( i !== null){
						i.remove()
					}	
					
				},1000)					
			}// end else mission failed
			
			
			
				/*
				   SAVE STAGE ACHIEVEMENTS TO DB: stages
				   DB indexes:
					- name
					- #campaignId
				   Achievements:
					- stars // can be used for ranking players on website later 
					- score // can be used for ranking players on website later     	         	
				*/

				spawn(function* (){
						
					/*
						GET DB.profile's FK #campaignId
					  GET stage.name
					  
					  BE THE DATA OBJECT:
						data = {          
							score: score,
						  stars: stars,
						  // name & campaignId USED FOR NEW INSERTION NOT UPDATE
						  [name: stage.name,
						  campaignId:campaignId]
						}
					  
							IF DB.stages.stage WITH name == stage.name 
								&& campaignId == profile.campaignId            
							GET DB.stages.stage's id
							UPDATE IT WITH data
						  ELSE
							INSERT data in stages
						  ENDIF
					*/
						
					 // GET STARSHOLDER SPRITE TO SAVE IT TO stage.stars
					//var stars = document.querySelector('#starsHolder').getAttribute('class')
					
					  var Gold = stage.earnedGold	// GET gold
					  var score = stage.score// GET score
					
					// GET PROFILE WHERE campaignId > 0
					  var profile = yield db.profile.where('campaignId').above(0).first()    
					  var campaignId = profile.campaignId
					  var stageName  = stage.name
					
					 var data = {          
						  score: score,
						  gold: Gold,
						  stars: totalStars,
						  bestCombo: paddle.bestStageCombo
						}
					  
					 var stagesStage = yield db.stages.get({name:stageName, campaignId: campaignId})
					 
					 // THIS STAGE IS NOT RECORDED IN stages YET
					 if(stagesStage == undefined) {
						// name & campaignId USED FOR NEW INSERTION NOT UPDATE
						data.name = stage.name
						data.campaignId = campaignId        
						var stageId = yield db.stages.add(data) // RECORD stage in stages      
					 }
					 else{
					   var stageId = yield db.stages.update(stagesStage.id,data)
					 }
					 console.log(stageId)
					 
					 
					 /*
						UPDATE DB: stageList
					 */
					 var stagesListStage = 
					 yield db.stagesList.get({name:stage.name, campaignId: campaignId})
						   .catch((error) => {})
							
					 
					 var stageId = 
						 yield db.stagesList
						 .update(stagesListStage.id,data)
						 
						 .catch((error) => {
							// Error handled and transaction will not abort.							
							// TRY AGAIN TO RECORD		
							 db.stagesList
							 .update(stagesListStage.id,data)
							 .catch((error) => {})							
						 });
					 
					 
				if(status == 'success') {					
					/*
						GET NEXT STAGE NAME -- begin
					*/					
					var nextSibling = 
					document
					.querySelector('#stageSelection #stagesList ul li a.stage_select[href="'+stage.name+'"]')
					.parentNode
					.nextSibling
					.childNodes[0]
					.href
					
					console.log('stage.name: '+stage.name)
					console.log('nextSibling: '+nextSibling)
					
					nextSiblingHrefArray = nextSibling.split('/')
					console.log(nextSiblingHrefArray[nextSiblingHrefArray.length-1])
					nextStageName = nextSiblingHrefArray[nextSiblingHrefArray.length-1]
					
					
					console.log('nextStageName: '+nextStageName)
					
					/*
						GET NEXT STAGE NAME -- end
					*/
					
					// UNLOCK NEXT STAGE ON THE MENU LIST
					yield db.stagesList
					.where("name")
					.equals(nextStageName)
					.modify({'unlocked':true})
					.then(function(){					
						// UNLOCK THE NEXT STAGE IN THE MENU LIST
						stageLockUnlock() 
					})


					/*
						IF THERE IS A STAGE IN STAGES LIST AFTER THIS ONE
					*/
					if( typeof(nextStageName) !=='undefined' ){
						// SET [NEXT] HREF
						document.querySelector('#endStage .stageDetailsControls .stage_next').setAttribute('href',nextSibling)
						//window.uiBtnsClickable = true
					}
							//SET & SHOW [NEXT] THAT LEADS TO IT
					
					
				}

				// UPDATE STAGE SELECT BTN's stars
				paramsObject = {
					stageName: stage.name,
					starClass: 's'+totalStars
				}
					
				updateStageSelectBtnStars(paramsObject)
					 
				}) // end spawn()
				
				
			    
			// COULD GIVE SOME TIPS OR PROPOSE SOME EQUIPEMENT TO BUY...
			//if( typeof reason !== 'undefined' ){}	

		}
		
		
		/*
			MAKE A DIALOG APPEAR DISPLAY A MESSAGE AND DISAPPEAR							
		
		window.modal = function( message, animation, duration){			
		  // POPULATE #modal
		  document.querySelector('#modal .message').innerHTML = message	
		  // ANIMATE #modal WITH CSS											  	
		  document.querySelector('#modal').classList.add(animation)												
		  showPage('modal')
		  
		  setTimeout(function(){
			  document.querySelector('#modal').classList.remove(animation)
			  //document.querySelector('#modal').classList.add('UI-animation-down')										  
			  hidePage('modal')
			  document.querySelector('#modal .message').innerHTML = ''
		  },duration)
		  
		}*/	
		
		/*
			MAKE A DIALOG APPEAR DISPLAY A MESSAGE AND DISAPPEAR							
		*/
		window.modal = function( modalId, message, animation, duration){
		  
		  // REMOVE ALL CLASSES FROM modal
		  //document.querySelector('#'+modalId).classList = ''
		  
		  if( message !=''){
			  // POPULATE #modal
			  document.querySelector('#'+modalId+' .message').innerHTML = message	
		  }
		  // ANIMATE #modal WITH CSS											  	
		  document.querySelector('#'+modalId).classList.add(animation)												
		  showPage(modalId)
		  
		  let additionalMessageClass = ''
		  if(arguments.length == 5){
			  additionalMessageClass = arguments[4];//.starReason to change minimodal message color and bg color
		  }
		  
		  if(additionalMessageClass != ''){
			  document.querySelector('#'+modalId+' .message').classList.add(additionalMessageClass)
		  }
		  		  
		  /*
			REMOVE AFTER duration
		  */
		  if(duration != -1){
			  setTimeout(function(){
				  document.querySelector('#'+modalId).classList.remove(animation)
				  //document.querySelector('#modal').classList.add('UI-animation-down')										  
				  hidePage(modalId)
				  document.querySelector('#'+modalId+' .message').innerHTML = ''
				  // REMOVE ADDITIONNAL CLASS IF PREVIOUSLY ADDED
				  if(document.querySelector('#'+modalId+' .message').classList.contains(additionalMessageClass)){
					  document.querySelector('#'+modalId+' .message').classList.remove(additionalMessageClass)
				  }	
			  },duration)
		  }
		}	
		
		/*
			MAKE A DIALOG APPEAR DISPLAY A MESSAGE AND DISAPPEAR
				WHEN AN OBJECTIVE HAS JUST BEEN COMPLETED
		*/
		window.notifyObjectiveComplete = function(objective){
			var Text = objective.description;
				/*Text += '\r\n'			
				Text += objective.messageSuccess */   
			modal( 'miniModal', Text, 'bounceInLeft', 3000)    
		}
		
		
		/*
			UPDATE #stageSelection selections buttons stars
			paramsObject = {
				stageName:,
				starClass:
			}
			updateStageSelectBtnStars(paramsObject)
		*/		
		function updateStageSelectBtnStars(paramsObject){	
			
			console.log(paramsObject)
			var stageName = paramsObject.stageName
			var btn = document.querySelectorAll('#stageSelection #stagesList ul li a.stage_select[href="'+stageName+'"]')
			var starsClass = paramsObject.starClass			
			var stars = btn[0].children[2]
			stars.classList.remove('s1','s2','s3')
		    stars.classList.add(starsClass)
			
			window.uiBtnsClickable = true
			
		}

		
		/*
			function checkRelevantObjectiveCompletion( objectiveName )
			DOES 
		
			IF THERE IS AN OBJECTIVE MATCHING THIS FEATURE
				CHECK IF IT IS COMPLETED THEN MARK IT AS COMPLETED
				CHECK IF ALL OBJECTIVES HAVE BEEN COMPLETED
					IF SO, STOP MAIN LOOP
						   DISPLAY ACHIEVEMENTS
						   UNLOCK NEXT STAGE TO UNLOCK

			PARAMS:
					objectiveName: type of objective
								   'destroyBW' | 'targets' | 'minCombos' | 'time' -- required						   
		*/
		 function checkRelevantObjectiveCompletion( objectiveName ){
			var objective = search( objectiveName, objectives)							
			if( typeof objective !=='undefined' ){				
				
				switch( objectiveName ){
					case 'destroyBW':
							// MARK THIS OBJECTIVE AS COMPLETE
								document.getElementById('bricks').innerHTML = '&check;'							
							
						if( objective.value == "true" || objective.value == true){
							
							// ADD THIS OBJECTIVE TO stageAchievements[]
								stageAchievements[ stageAchievements.length ] = objective
						
							// REMOVE THIS OBJECTIVE FROM objectives[]
								removeArrayItemByName('destroyBW', objectives)
							
							// NOTIFY PLAYER THIS OBJECTIVE IS COMPLETE							
							notifyObjectiveComplete(objective)
														
							// CHECK IF ALL OBJECTIVES HAVE BEEN COMPLETED...
								checkAllObjectivesComplete()									
						}
					break;
					case 'minCombos':
						if( parseInt(paddle.bestStageCombo) >= objective.value ){
							// MARK THIS OBJECTIVE AS COMPLETE														
								document.getElementById('combos').innerHTML = '&check;'
							
							// ADD THIS OBJECTIVE TO stageAchievements[]
								stageAchievements[ stageAchievements.length ] = objective
								
							// REMOVE THIS OBJECTIVE FROM objectives[]
								removeArrayItemByName('minCombos', objectives)
							
							// NOTIFY PLAYER THIS OBJECTIVE IS COMPLETE							
							notifyObjectiveComplete(objective)
														
							// CHECK IF ALL OBJECTIVES HAVE BEEN COMPLETED...
								checkAllObjectivesComplete()								
						}
					break;	
					case 'targets':					
						
						Array.prototype.some.call( objective.value, function( target ){
							
							var targetCount = target.count,						
								spriteName = target.name
							
							var eliminated = 
							Array.prototype.filter.call( spritesEliminated, function( sprite ){
								return ( sprite.name == spriteName)								
							}).length
							
							/* UPDATE REMAINING TARGETS COUNT IN INGAME UI -- BEGIN */
							
							// GET THE ID OF THE TARGET FIELD 
							if( spriteName.indexOf('.') !== -1){
								var spriteNameArray = spriteName.split('.')							
								var sprtNme	= spriteNameArray[0]// get the spriteName without .ent ...
							}
							else{
								var sprtNme	= spriteName
							}
							
							// REPLACE THE TEXT NODE NEXT TO THE IMG IN THE TARGET FIELD
							//document.getElementById(sprtNme).textContent = eliminated							
							var textnode = document.createTextNode(targetCount - eliminated);
							
							console.log('spriteName: '+ spriteName)
							console.log('sprtNme: '+ sprtNme)
							console.log('textnode: '+ textnode)
							
							
							var item = document.getElementById(sprtNme)
								item.replaceChild(textnode, item.childNodes[1]);// 0 = img, 1 = txt
							console.log('item: '+ item)
							/* UPDATE REMAINING TARGETS COUNT IN INGAME UI -- END */
							
							if( eliminated >= targetCount ){
							// MARK THIS OBJECTIVE AS COMPLETE	
								/*								
								var spriteNameArray = spriteName.split('.')
								var sprtNme = spriteNameArray[0]	*/	
								
								//document.getElementById(sprtNme).innerHTML = '&check;'
								var textnode = document.createTextNode('');
								item.replaceChild(textnode, item.childNodes[1]);// 0 = img, 1 = txt
								item.innerHTML +='&check;'
								////////////alert('target'+ sprtNme+' completed')	
							// REMOVE THIS target FROM THE TARGET ATTRIBUTE COLLECTION 'objective.value'
								removeArrayItemByName(target.name, objective.value)
								if( objective.value.length < 1 ){
									// OBJECTIVE COMPLETE
									// ADD THIS OBJECTIVE TO stageAchievements[]
									stageAchievements[ stageAchievements.length ] = objective								
									// REMOVE THIS OBJECTIVE FROM objectives[]
										removeArrayItemByName('targets', objectives)															
									
									// NOTIFY PLAYER THIS OBJECTIVE IS COMPLETE							
									notifyObjectiveComplete(objective)
																
									// CHECK IF ALL OBJECTIVES HAVE BEEN COMPLETED...
										checkAllObjectivesComplete()								
								}
							}
							/*
								WORKS FOR TYPE OF TARGETS
							if( eliminated >= targetCount ){
								// OBJECTIVE COMPLETE
								// ADD THIS OBJECTIVE TO stageAchievements[]
								stageAchievements[ stageAchievements.length ] = objective								
								// REMOVE THIS OBJECTIVE FROM objectives[]
									removeArrayItemByName('targets', objectives)															
								// CHECK IF ALL OBJECTIVES HAVE BEEN COMPLETED...
								checkAllObjectivesComplete()
							}*/

						})
						
					break;
					case 'escortees':					
						
						Array.prototype.some.call( objective.value, function( target ){
							
							var targetCount = target.count,						
								spriteName = target.name
							
							var eliminated = 
							Array.prototype.filter.call( escorteesSaved, function( sprite ){
								return ( sprite.name == spriteName)								
							}).length
							
							//////////alert(eliminated)
							
							/* UPDATE REMAINING TARGETS COUNT IN INGAME UI -- BEGIN */
							
							// GET THE ID OF THE TARGET FIELD 
							if( spriteName.indexOf('.') !== -1){
								var spriteNameArray = spriteName.split('.')							
								var sprtNme	= spriteNameArray[0]// get the spriteName without .ent ...
							}
							else{
								var sprtNme	= spriteName
							}
							
							// REPLACE THE TEXT NODE NEXT TO THE IMG IN THE TARGET FIELD
							//document.getElementById(sprtNme).textContent = eliminated							
							var textnode = document.createTextNode(targetCount - eliminated);
							
							console.log('spriteName: '+ spriteName)
							console.log('sprtNme: '+ sprtNme)
							console.log('textnode: '+ textnode)
							
							
							var item = document.getElementById(sprtNme)
								item.replaceChild(textnode, item.childNodes[1]);// 0 = img, 1 = txt
							console.log('item: '+ item)
							/* UPDATE REMAINING TARGETS COUNT IN INGAME UI -- END */
							
							if( eliminated >= targetCount ){
							// MARK THIS OBJECTIVE AS COMPLETE	
								/*								
								var spriteNameArray = spriteName.split('.')
								var sprtNme = spriteNameArray[0]	*/	
								
								//document.getElementById(sprtNme).innerHTML = '&check;'
								var textnode = document.createTextNode('');
								item.replaceChild(textnode, item.childNodes[1]);// 0 = img, 1 = txt
								item.innerHTML +='&check;'
								////////////alert('target'+ sprtNme+' completed')	
							// REMOVE THIS target FROM THE TARGET ATTRIBUTE COLLECTION 'objective.value'
								removeArrayItemByName(target.name, objective.value)
								if( objective.value.length < 1 ){
									// OBJECTIVE COMPLETE
									// ADD THIS OBJECTIVE TO stageAchievements[]
									stageAchievements[ stageAchievements.length ] = objective								
									// REMOVE THIS OBJECTIVE FROM objectives[]
										removeArrayItemByName('escortees', objectives)															
									
									// NOTIFY PLAYER THIS OBJECTIVE IS COMPLETE							
									notifyObjectiveComplete(objective)
																
									// CHECK IF ALL OBJECTIVES HAVE BEEN COMPLETED...
										checkAllObjectivesComplete()								
								}
							}
							/*
								WORKS FOR TYPE OF TARGETS
							if( eliminated >= targetCount ){
								// OBJECTIVE COMPLETE
								// ADD THIS OBJECTIVE TO stageAchievements[]
								stageAchievements[ stageAchievements.length ] = objective								
								// REMOVE THIS OBJECTIVE FROM objectives[]
									removeArrayItemByName('targets', objectives)															
								// CHECK IF ALL OBJECTIVES HAVE BEEN COMPLETED...
								checkAllObjectivesComplete()
							}*/

						})
						
					break;


					
				}
				
			}    
			 
		  }// end checkRelevantObjectiveCompletion()
		
		
		
		
		
		/*
			bounce an object 'bl' against a rectangle 'br'
		*/
		function bounceObject(dataObject){ 
						
			var   
				ball = dataObject.ball,
				blX = parseInt(dataObject.blX),
				blY = parseInt(dataObject.blY),
				blW = parseInt(dataObject.blW),
				blH = parseInt(dataObject.blH),
				blDx = parseInt(dataObject.blDx),
				blDy = parseInt(dataObject.blDy),
				brX = parseInt(dataObject.brX),
				brY = parseInt(dataObject.brY),
				brW = parseInt(dataObject.brW),
				brH = parseInt(dataObject.brH),
				bounceAgainst = dataObject.bounceAgainst
				
				
				let xSpeed = ( Math.abs(blDx) > 0)?Math.abs(blDx):1,
					ySpeed = ( Math.abs(blDy) > 0)?Math.abs(blDy):1
				console.log(Math.abs(blDx)+' '+Math.abs(blDy))
				/*
					let xSpeed = 5,
						ySpeed = 5
					*/	
				
				if( blDx == 0){ blDx = 1}
				if( blDy == 0){ blDy = 1}
			
				blDx = Math.abs(blDx)
				blDy = Math.abs(blDy)
			
				
			/*	
			//document.querySelector('#log').innerHTML =
			 'blX:'+blX+'\r\n'
			+'blY:'+blY+'\r\n'
			+'blW:'+blW+'\r\n'
			+'blH:'+blH+'\r\n'
			+'blDx:'+blDx+'\r\n'
			+'blDy:'+blDy+'\r\n'
			+'brX:'+brX+'\r\n'
			+'brY:'+brY+'\r\n'
			+'brW:'+brW+'\r\n'
			+'brH:'+brH+'\r\n'
			*/
			/*
				A   B   C   D   E
				
				P               F 
				
				O       		G
								
				N				H
								
				M	L	K	J	I
			*/
			
			var corners = [					
				['A',brX, brY], // A 0,0	
				['B',brX+brW/4, brY], // B 25,0	
				['C',brX+brW/2, brY], // B 25,0	
				['D',brX+3*(brW/4), brY], // B 25,0
				['E',brX+brW, brY], // C 50,0								
				['F',brX+brW, brY+brH/4], //D 50,25	
				['G',brX+brW, brY+brH/2], //D 50,25	
				['H',brX+brW, brY+3*(brH/4)], //D 50,25								
				['I',brX+brW, brY+brH], // E 50,50	
				['J',brX+3*(brW/4), brY+brH], // B 25,0
				['K',brX+brW/2, brY+brH], // F 25,50	
				['L',brX+brW/4, brY+brH], // G 0,50		
				['M',brX, brY+brH], // G 0,50	
				['N',brX, brY+3*(brH/4)], // G 0,50	
				['O',brX, brY+brH/2], // H 0,25	
				['P',brX, brY+brH/4] // H 0,25								
			  ],
			  dist = [[],[],[],[],[],[],[],[],[],[],[],[],[],[],[],[]]

			  for( n = 0; n < corners.length; n++ ){  
				
				dist[n][0] = Distance2D( corners[n][1], corners[n][2],  blX+blW/2, blY+blH/2)
				dist[n][1] = corners[n][0]
				dist[n][2] = corners[n][1]
				dist[n][3] = corners[n][2]
				//console.log(n+' '+dist[n])
			  }
			  
			  dist.sort(sortFunction);
			  
			  // blDx,blDy	
			  // THE CLOSEST CORNER IS THE FIRST ITEM OF dist[]
			  if( dist[0][1] == 'A' ){
				// DO SITUATION A
				ball.dx = -1//-blDx
				ball.dy = -1//-blDy// * blDy
				
			  }else 
			  if( dist[0][1] == 'B' ){
				// DO SITUATION B
				ball.dx = -1//-blDx
				ball.dy = -1//-blDy// * blDy
				
			  }else 
			  if( dist[0][1] == 'C' ){
				// DO SITUATION C
				ball.dx = 0
				ball.dy = -1//-blDy// * blDy				
				
			  }else 
			  if( dist[0][1] == 'D' ){
				// DO SITUATION D
				ball.dx = 1//blDx// * blDx
				ball.dy = -1//-blDy// * blDy
				
			  }	
			  else 
			  if( dist[0][1] == 'E' ){
				// DO SITUATION E
				ball.dx = 1//-blDx// * blDx
				ball.dy = -1//-blDy// * blDy
				
			  }else 
			  if( dist[0][1] == 'F' ){
				// DO SITUATION F
				ball.dx = 1//blDx
				ball.dy = -1//blDy// * blDy
				
			  }else 
			  if( dist[0][1] == 'G' ){
				// DO SITUATION G
				ball.dx = 1//blDx// * blDx
				ball.dy = 0
							
			  }else 
			  if( dist[0][1] == 'H' ){
				// DO SITUATION H
				ball.dx = 1//blDx// * blDx
				ball.dy = 1//blDy
				
			  }
			  else 
			  if( dist[0][1] == 'I' ){
				// DO SITUATION H
				ball.dx = 1//blDx //* blDx
				ball.dy = 1//blDy
				
			  }else 
			  if( dist[0][1] == 'J' ){
				// DO SITUATION H
				ball.dx = 1//blDx// * blDx
				ball.dy = 1//blDy
				
			  }else 
			  if( dist[0][1] == 'K' ){
				// DO SITUATION H
				ball.dx = 0
				ball.dy = 1//blDy				
				
			  }else 
			  if( dist[0][1] == 'L' ){
				// DO SITUATION H
				ball.dx = -1//-blDx
				ball.dy = 1//blDy
				
			  }else 
			  if( dist[0][1] == 'M' ){
				// DO SITUATION H
				ball.dx = -1//-blDx
				ball.dy = 1//blDy
				
			  }else 
			  if( dist[0][1] == 'N' ){
				// DO SITUATION H
				ball.dx = -1//-blDx
				ball.dy = 1//blDy
				
			  }else 
			  if( dist[0][1] == 'O' ){
				// DO SITUATION H
				ball.dx = -1//-blDx
				ball.dy = 0//-blDy
						
			  }else 
			  if( dist[0][1] == 'P' ){
				// DO SITUATION H
				ball.dx = -1//-blDx
				ball.dy = -1
				
			  }
			  
			  ball.dx *= xSpeed
			  ball.dy *= ySpeed
			  
			  if ( bounceAgainst == 'paddle' ){				  
			  /* 
				IF THE BALL IS A PUNCHED ENNEMY, KEEP ITS VELOCITY HIGH
				BUT NOT TOO HIGH
			  */
				   if( ball.type == 'punched' ){
					   //ball.dx = Math.sign(ball.dx)*3
					   //ball.dy = Math.sign(ball.dy)*3

					   ball.dx = Math.sign(ball.dx)
					   ball.dy = Math.sign(ball.dy)
					   
				   }
			  }			  
			  /*
			  ball.dx *= xSpeed
			  ball.dy *= ySpeed
			  */
			  ball.x += ball.dx// * blW*0.1
			  ball.y += ball.dy// * blH*0.1
			  
				// CHANGE THE bounced object's animation
			  swapSprite(ball)	
		}
		
		//
		//	BRICKWALL CONSTRUCTION -- begin
		//
		
		//
		//	MAKE THE BRICK WALL WITHOUT DRAWING IT
		//
		window.initBrickWall =function(){
			bricks = [];
			for(let c=0; c<brickColumnCount; c++) {
			  bricks[c] = [];
			  for(let r=0; r<brickRowCount; r++) {
				bricks[c][r] = { x: 0, y: 0, status: -1 };
			  }
			}
		}
		
		//	select one tile by its index in array tiles
		//	mapRows
		//	mapColumns
		//	tc: tile column
		//	tr: tile row
		 window.populate_tiles = function(){
			let n = 0
			for(let tc=0; tc<mapColumns; tc++) {	  
			  for(let tr=0; tr<mapRows; tr++) {
				tiles[n] = { x: parseInt(tr) , y: parseInt(tc), status: 0 };
				n++
			  }
			}			
		}
		
		
		//
		//  DRAW BRICKS AT THE RIGHT COORDINATES ON CANVAS
		//		
		 window.drawBricks4 = function() {
			
				let ingame = false;
				// if ingame == true, do not check level for brick[c][r].status
				if ( arguments[0] ){	
					ingame = arguments[0]; 
				}
				
				//////////////alert(arguments[0]+' '+ingame)// OK
				
				if ( ingame === false  ){
					
				  populate_tiles()

				  initBrickWall();
				  
				}
				let b_idx = 0
				
				var t = '', ct = 0
				
				for(let c=0; c<brickColumnCount; c++) {
					for(let r=0; r<brickRowCount; r++) {					
						// DRAW THE WALL BRICK FROM wallBrickMap[]	 
						if (ingame == false){		
							bricks[c][r].status = wallBrickMap[b_idx]
						/*
						////////////alert("wallBrickMapEnergy[idx] != 'I': "+ wallBrickMapEnergy[b_idx] != 'I')
						////////////alert("typeof : "+typeof  wallBrickMapEnergy[b_idx])	
						*/	
							if(bricks[c][r].status > -1) {
								/*////////////alert(parseInt(wallBrickMap[b_idx]) > 0)
								////////////alert(parseInt(wallBrickMap[b_idx]))*/
								//if ( wallBrickMapEnergy[b_idx] > 0/* && wallBrickMapEnergy[b_idx] != "I"*/) {
								//////////////alert(wallBrickMapEnergy[b_idx]+" " +parseInt(wallBrickMap[b_idx]) > -1)
								wallBrickMapEnergyInitial[b_idx] = wallBrickMapEnergy[b_idx]
								if ( wallBrickMap[b_idx] != -1 && wallBrickMapEnergy[b_idx] != -1 ) {								  
								  bricksTotal++
								}
								ct++
							}
							t 
							+= 'bricks[c][r].status:'+bricks[c][r].status+ '--- '
							+ 'wallBrickMapEnergy[b_idx]:'+wallBrickMapEnergy[b_idx]+ ' --- bricksTotal:'+bricksTotal+ ' ---- ct:'+ct
							+'\r\n'
							
						}
						
						if( bricks[c][r].status > -1) {
							// object {x,y} tile to display
							let tile = tiles[wallBrickMap[b_idx]]	
							let brickX = (r*(parseInt(brickWidth)+parseInt(brickPadding)))+parseInt(brickOffsetLeft);
							let brickY = (c*(parseInt(brickHeight)+parseInt(brickPadding)))+parseInt(brickOffsetTop);
							bricks[c][r].x = brickX;
							bricks[c][r].y = brickY;


							//brickwall.drawOnCanvas = 'ground'
							var ctx = search(brickwall.drawOnCanvas,ctxs)
							//console.log('3279: '+ctx.ctx)

							if( brickWallSkin == 'img' ){
								ctx.ctx.drawImage(
									img,
									tile.x*brickWidth,
									tile.y*brickHeight,
									brickWidth,
									brickHeight,
									brickX, 
									brickY,
									brickWidth,
									brickHeight
								 );
							}
							else if( brickWallSkin == 'color' )
							{
								// MUCH FASTER THAN DRAW IMAGE
								ctx.ctx.beginPath();
								ctx.ctx.rect(brickX, brickY, brickWidth, brickHeight);
								ctx.ctx.strokeStyle = '#000'															
								ctx.ctx.fillStyle = colors[wallBrickMap[b_idx]];
								ctx.ctx.fill();
								ctx.ctx.strokeRect(brickX, brickY, brickWidth, brickHeight);	
								ctx.ctx.closePath();
							}
							
							/*
								DISPLAY BRICK DAMAGE IF IT LOST ENERGY SINCE THE BEGINING OF THE SGE
							*/
							if( 
							   wallBrickMap[b_idx] > -1
							&& wallBrickMapEnergy[b_idx] < wallBrickMapEnergyInitial[b_idx]
							){		
								//////////////alert(wallBrickMapEnergy[b_idx] +' / '+ wallBrickMapEnergyInitial[b_idx])
								var total = wallBrickMapEnergyInitial[b_idx] // 10
								var cur = wallBrickMapEnergy[b_idx] // 5
								var percent =  cur/total*100								
								var X = 0//percent*500/100
								
								X = ( percent < 100 )?0:0
								X = ( percent <= 90 )?50:X
								X = ( percent <= 80 )?100:X
								X = ( percent <= 70 )?150:X
								X = ( percent <= 60 )?200:X
								X = ( percent <= 50 )?250:X
								X = ( percent <= 40 )?300:X
								X = ( percent <= 30 )?350:X
								X = ( percent <= 20 )?400:X
								X = ( percent <= 10 )?450:X
								
								ctx.ctx.drawImage(
									cracks,
									X, 
									0,
									50,
									25,									
									brickX,
									brickY,
									50,
									25
								 );
								/*var Value =	percent							
								
								var Value = wallBrickMapEnergy[b_idx]			
								ctx.font = 0.2*tileWidth+"px Comic Sans MS";
								ctx.fillStyle = (wallBrickMapEnergy[b_idx] == 'I')?"crimson":"black";
								ctx.textAlign = "right";	
								ctx.fillText(wallBrickMapEnergyInitial[b_idx], brickX+(brickWidth/2), brickY+(brickHeight/2)+0.2*tileWidth);	
								ctx.fillText(Value, brickX+(brickWidth/2), brickY+(brickHeight/2)+0.4*tileWidth);	
								*/
							}
							 
							// DEACTIVATED FOR PERFORMANCE 
							/*
							 THE WORKS THIN FOR PERFORMANCE
							 ctx.shadowColor = '#000';
							 ctx.shadowBlur = 1; 
							 ctx.shadowOffsetX = 1;
							 ctx.shadowOffsetY = 1;		
							//
							//if(bricksFillStyle != 'transparent'){
							//	ctx.beginPath();
							//	ctx.rect(brickX, brickY, brickWidth, brickHeight);		
							//	ctx.fillStyle = bricksFillStyle;
							//	ctx.fill();
							//	ctx.closePath();
							//}
							*/
						} // if(bricks[c][r].status > -1) {
				  b_idx++
					  
				}// for r
			
			}// for c
			//////////////alert(t)
			
			/*
				WILL BE USED TO DISPLAY TOTAL ON #endStage screen
			*/
			if( ingame === false ){
				brickwall.bricksTotal = bricksTotal
			}
			
		}//drawBricks4 = function() {
//
//	BRICKWALL CONSTRUCTION -- end
//

	
	
	show_paths = function(e){
		e.preventDefault()
				
		var paths = ['abs-longest-sofar','rel-square-mountains']//['abs-left-right','abs-left-right-bis']
		var n = 0
		
		while( n < paths.length ){
			////////////alert(path[n]['name']+'\r\n'+path[n])			
			var pathObject = search(paths[n], path)							
			
			n++
		}
		
	}
	
	//document.addEventlistener("DOMContentLoaded", initGlobals)
	
	
	start_game = function(stageName){
		/*
		touchEventsInit(); // INIT TOUCH EVENTS (MOBILE)		
		mouseEventsInit() // INIT MOUSE EVENTS (PC)
		*/
		console.log('9269: stage\r\n'+stage)
		
		hideAllPagesExcept('UI_wrapper')
			
		
		
		// REMOVE #weaponsList IF EXISTS
			var i = document.querySelector('#weaponsSelector #weaponsList') 
			if ( i != null ){
				i.remove()
			}
					
			generateWeaponsSelectUI()
						
			// ANGEL NEUTRAL FLYING SPRITE
			DBprofileGetSelectedChar( 1 )
			//setPaddleSprite(charactersActionsSprites[profile.character.charId].flying)
		
		/*
			SHOW:
				TIMER
				PAUSE BUTTON
				TOP AD BANNER (LATER)
		*/
		
		//showPage(  )
		//playStageMusic()
				
		//myReq = requestAnimationFrame( main );	// works	
		/*
		if( typeof(stage.scrollingScreens) !== 'undefined' ){			
			scrollingScreens = stage.scrollingScreens
			if( scrollingScreens.length > 0 ){
				spawnScrollingScreens2()
			}
		}*/
		// SPAWN A BALL -- WILL BE CHANGED
		//spawnABall()
		
		
		//selectedWeaponsPopulate()
		
		// LOAD BW
		if( stage.stage_brickwall_name != '' ){
			loadStageBrickWall(stage.stage_brickwall_name)
		}
		// PLAY BGM
		//playStageMusic()		
		// DRAW BW, BALL, ANGEL, SCROLLINGS...
		
		resetStars()// EMPTY ALL END STAGE STARS
		//clearAllCanvas()
		//setPaddleSprite(charactersActionsSprites[profile.character.charId].flying)
		
		
		
		try{
			var selectedSprite = charactersActionsSprites[profile.character.charId].flying			
				setPaddleSprite(selectedSprite)
		}
		catch(err){
			console.log(err)
			/*
				FIX TO DELAY THE USE OF 
				charactersActionsSprites[profile.character.charId]
				THAT IS NOT AVAILABLE NOW
				- should be changed later
			*/
			window.setTimeout(function(){
				var selectedSprite = charactersActionsSprites[profile.character.charId].flying				
					setPaddleSprite(selectedSprite)
			},1000)
		
		}
		
		
		
		writeLives() // UPDATE INGAME LIVES STOCK
		
		
		document.getElementById('casualtiesContainer').classList.remove('critical')
		document.querySelector('#casualtiesContainer').classList.add('hidden')
		
		if(typeof maxCasualties !== 'undefined'){			
			if( maxCasualties != ''){
				writeCasualties()
				document.querySelector('#casualtiesContainer').classList.remove('hidden')
			}
		}
		
		
		
		writeBricksRemaining() // UPDATE INGAME bricksTotal
		writeScore() // POPULATE INGAME SCORE FIELD WITH 0
		
		playOnce = true
		
		mouseEventsReset()// DISABLE MOUSE MOVES CAPTURE
		
		main()
		
		setTimeout(function(){
			
			// DISPLAY stage.description
			var Html = '';
			if(stage.description !== undefined){
				Html += '<div class="stageDescription">'
					 + stage.description
					 + '</div>'
			}
			Html +=
			document.querySelector('#stageDetails .objectivesList').innerHTML
			/*
			if( typeof(maxCasualties) !== 'undefined' ){
				
				if(maxCasualties!=''){
					Html += 
					'<span class="objCsl">Max casualties: '
					+maxCasualties
					+'</span>'
				}
				
			}*/
			
			modal('modal', Html,'UI-animation-down',4000)
			// DISPLAY stage.description -- end
		},100)
		
		/* 
			ONLY APPLICABLE FOR APPP< NOT FOR itch.io
		*/
		if ( window.location !== window.parent.location ) {	  
			// The page is in an iframe	
			
			//launch_stage()
			
			mouseEventsInit(); // INIT MOUSE EVENTS (PC)	
			
			playOnce = false
			
			/*
			sounds[9].play()			
			spawnEntityFromJson('teleportation.ent')
			*/
			
			stage.ingame = true;
			
			playStageMusic()
			
			displayAngel = true		
						
			// START MAIN LOOP	
			myReq = requestAnimationFrame( main );	// works
			
		} else {	
		
			// The page is not in an iframe	
			setTimeout(function(){			
				playOnce = false
				
				/*
					IF THE DETECTED PLATFORM IS A BROWSER
					WE  SUPPOSE IT IS ON A DESKTOP
				*/
				if( window.platform == 'browser' ){
					mouseEventsInit(); // INIT MOUSE EVENTS (PC)	
				}else{
					// ... OTHERWISE A TOUCH DEVICE (mobile or tablet)
					touchEventsInit(); // INIT TOUCH EVENTS (MOBILE)	
				}
				
				launch_stage()
			},4000)	
			
		}
		
		
		
		
	}// start_game()
	
	
	window.launch_stage = function(){
		
		if( stageEnded === true){ return }		
		
		
		sounds[9].play()
		spawnEntityFromJson('teleportation.ent')
				
		// START MAIN LOOP	
		myReq = requestAnimationFrame( main );	// works
		
		/* 
			keypress events true = active | false = inactive
			SPACEBAR, F, G, H
			ARROW KEYS
		*/
		stage.ingame = true; 
		
		//alert(stage.maxCasualties)
		
		// PLAY BGM 
		// SHOW PAUSE BTN
		// AFTER THE ANGEL TELEPORTED
		setTimeout(function(){
			
			/* SHOW PAUSE BTN */
			toggleButtonsVisibility([					
				{
					selector: '#pauseBtn',
					removeClass: '',
					addClass:'visible'
				}]				
			)	
			
			playStageMusic()
			displayAngel = true			
		},1000)	
		
	}
	
	
	
	 window.resetStageVars = function(){
		/*
			RESET STAGES VARS
		*/		
		stageEnded = false
		myReq = 0
		playOnce = false
		displayAngel = false
		stage.timesUsedWeapons = 0
		paddle.noMorePowerUpsFx = false; // show power-up FX or not 
		maxCasualties = 0
		
		/*
			BRICKWALL
		*/
		bricks = []
		brickRowCount = 0
		brickColumnCount = 0
		bricksTotal = 0
		wallBrickMap = []
		wallBrickMapEnergy = []
		wallBrickMapEnergyInitial = []
		brickwall = {}
		brickObjects = []		
		mapRows = 0
		mapColumns = 0
		sourceWidth = 0
		sourceHeight = 0
		tiles = []
		
		
		// SPRITES & ENTITIES
		
		spawnBalls = ['angel.ball.ent']//'ball.entity',// DEFAULT BALLS THAT TRIGGER lives-- + respawn
		
		stageNthFrame = 0
		lastTime = 0
		lastTimeArrow = 0
		timeUnit = 0		
		
		updateId = 0,
		previousDelta = 0		
		
		entityCannons = []	
		sprites = []
		energyObjects = [] 
		
		
		// PADDLE		
		paddle.currentCombo = 0		
		paddle.bestStageCombo = 0		
		paddle.lastHitAt = timeUnit
		
		paddleX = 130
		paddleY = 600	
		
		paddle.x = 130
		paddle.y = 600
		
		paddle.dx = 0
		paddle.dy = 0
				
		// BALLS
		balls = []
		ball = {}
		ball_idx = 0
		
		// SCROLLING
		stageScrolling = []  
		scrollingScreens = []
		screensToScroll = []
		stageScrolling = []
		screensScrollSpeed = []
		
		// OBJECTIVES		
		objectives = []
		stageAchievements = []// objectives completed
		spritesEliminated = []// minCombos
		escorteesSaved = []
		timer = -1 // timer IS SET BY timer FROM stage.json : timer = timer, -1 = no timer | N sets timer to N (10ths of seconds)
		
		// RESET ALL CANVASES 
		for( var n = 0 ; n < canvases.length; n++ ){
			canvases[n].screensToScroll = false
			var ctx = search(canvases[n].name,ctxs)
			ctx.ctx.clearRect(0, 0, canvases[n].width, canvases[n].height);
		}
		
		writeLives();// INGAME UI UPDATE lives FIELD
	}
	
	
	// deviceready triggers app_wrapper
	// app_wrapper triggers initGlobals automatically
	
	
	//loadDB()
	
	
	

    
	
	 /*
		function takeDamage()
		
		DOES:			
			REDUCES T's energy PERTAINING A's strength
		
		T: target
		A: attacker
		T loses energy only if A.strength > T.resistance
		
		if T.resistance < A.strength
			T.energy = A.strength - T.resistance
		
		PARAMS :
			paramsObject{
				attacker: sprite | ball,
				target: sprite | ball | ?brick				
			}
		RETURN :
			T.energy
     */
	function takeDamage( paramsObject ){
		
		let attacker = paramsObject.attacker,
			target = paramsObject.target,
			attackerStrength = parseInt(attacker.strength),
			targetResistance = parseInt(target.resistance),
			targetEnergy = parseInt(target.energy)
		
			if( attackerStrength > targetResistance ){
				var damage = attackerStrength - targetResistance
					targetEnergy -= damage
			}
			return targetEnergy
	}
	
	
	
	
	/*
		DEXIE INDEXED DB		
	
	const Dexie = window.Dexie,
		  async = Dexie.async,
		  spawn = Dexie.spawn,
		  db = new Dexie('ASDB')
	*/
	/*
		LOAD Dexie INDEXED DB 'ASDB'
	*/
	function createDexieDB(){
		db.version(1).stores({
			profile: '++id,creationDate,campaignId,characterId', // 
			  character: '++,profileId,name,strength,resistance,charisma',
			  characterAttributes: '++,profileId,characterId,id,cost,max,description',// id is the name of the attribute
				weapons: '++id,profileId,name,entityName,slot', // boxing-gloves.ent  
			  campaigns: '++id,profileId,name',// name : name.cmp
				 stages: '++id,campaignId,name', // name : name.stg
				 stagesList: '++id,*campaignId,name,description', // name : name.stg, description, gold, score, combos
				 assets: '++id,campaignId,campaignName,name,description,collection,object'
				 /*
					asset contains all json objects listed in campaign.exp.json
					object: the json data of the object.xxx.json
					collection: where each object will be stored,i.e.:
							sprites|entities|brickwalls|paths|sounds 
					
				*/
		});		
	}
	/*
		WHEN DB IS OPENED
			IF NO PROFILE WITH campaignId > 0
				CREATE PROFILE
				SET profile.campaignId DEFAULT (e.g.: 'myFirstCampaign.cmp.json' )
				initGlobals2()
			ELSE:
				GET profile.campaignId
					SET campaign to campaign WHICH id IS profile.campaignId
				initGlobals2()
	*/
	//createDexieDB()
	
	// OPEN DB	
	//db.open()
/*
	ERASE DATABASE
	START THE GAME
*/	
 window.newGame = function(){
	
	/*db.delete().then(() => {		
		var el = document.querySelector('#stageSelection #stagesList')
		
		if(typeof el !=='undefined'){
			el.remove()
		}
		
		listCampaigns()
		
		//startGame()
	})*/

	listCampaigns()
	
}




/*
    - GET THE LIST OF CAMPAIGNS FROM CAMPAIGNS.LST.JSON
    - MAKE A CAMPAIGN SELECT MENU
*/
window.listCampaigns = function(){
    
    console.clear()
    promises = []
    totalPromises = 0
    solvedPromises = 0

    let campaigns =[]// ['myFirstCampaign.cmp.json','shortCmp.cmp.json']
    let cont = document.querySelector('#campaignSelectionList ul')
        cont.innerHTML = ''// empty ul
   
    load('campaigns.lst.json',function(json){
        
        // DISPLAY THE CAMPAIGN SELECTION PAGE
        hideAllPagesExcept('campaignSelection')
        
        let campaigns = JSON.parse(json)
        console.log(campaigns)
        campaigns.some((o,i)=>{
            console.log(o+' '+i)
            let li = document.createElement('li')
            let a = document.createElement('a')
                a.setAttribute('href','#'+o.name)
                a.innerHTML  = "<span class='cmpTitle'>"+o.title+"</span>"
				a.innerHTML  += "<span class='cmpDescription'>"+o.description+"</span>"
                a.classList.add('campaign_select')
                li.append(a)
                cont.append(li)        
            })//foreach
        })// function    
}






/*
	START THE GAME
		CREATE DATABASE
		OPEN DATABASE
		CREATE PROFILE IF IT DOES NOT EXISTS
		OR LOAD EXISTING PROFILE
		...
*/
window.startGame = function(){
		
	createDexieDB()
	db.open()
	
	let campaignName = campaign
	
	if(arguments.length == 1){
		campaignName = arguments[0]		
	}

	createProfile(campaignName)
	
}	

	
window.createProfile = function(){
	
	if(arguments.length > 0){
		campaign = arguments[0];//'myFirstCampaign.cmp.json'
	}
	
	db.on("ready", function(){ 
	
		spawn(function*(){
		
		  // GET PROFILE WHERE campaignId > 0
		  var profile = yield db.profile.where('campaignId').above(0).first()
		  
		  /*
				IF THERE IS NO EXISTING PROFILE -- begin
					- SET STORAGE PERSISTENT
					- SET A DEFAULT CAMPAIGN (select campaign.exp.json)
					- POPULATE Dexie 'assets' from campaign.exp.json
					- CREATE BLANK PROFILE
					- CREATE CAMPAIGN, get idCampaign
					- UPDATE BLANK PROFILE WITH idCampaign
					- LOAD THE stages-menu-select-XXXXXXXX.cmp.json 
					- Populate DB: stagesList with default values
					EXIT Function
				ENDIF	
		  */		  
		  if( typeof profile === 'undefined'){			  
			  
			  /*
				SET STORAGE AS PERSISTENT IF POSSIBLE
				different platforms will apply it differently
			  */			  
			  initStoragePersistence()  
			  
			  // SET A DEFAULT CAMPAIGN
			 //campaign = 'myFirstCampaign.cmp.json'	
			 //campaign = 'shortCmp.cmp.json'
			  
			 /* CREATE BLANK PROFILE -- begin */
			  var idProfile = yield db.profile.add({			
				creationDate: Date.now(),
				gold: 0
			  })
			  console.log ("PROFILE CREATED !");		
			  /* CREATE BLANK PROFILE -- end */
			  
			 /* CREATE CAMPAIGN -- begin */ 
			  yield db.campaigns.add({			
				name: campaign			
			  })		
			  .then(function( idCampaign ){
				  /* UPDATE BLANK PROFILE WITH idCampaign -- begin */ 	
				  db.profile.update(idProfile, {campaignId: idCampaign})
					.then(function (updated) {
					if (updated) {
						console.log ("PROFILE WAS UPDATED !");					
						initGlobals3()
					}
				  })
				  /* UPDATE BLANK PROFILE WITH idCampaign -- end */ 	
				return idCampaign 
			  })/* CREATE CAMPAIGN -- end */ 
			  
			.then(function( idCampaign ){  
			 
			/*
				LOAD THE stages-menu-select-XXXXXXXX.cmp.json
					- populate DB: stagesList
					DB: stagesList is used to generate stages selectors UI

				WORKS WITH BROWSER
				DOES NOT WORK WITH PHONE		
						 
			  fetch('stages-menu-select-'+campaign)
			  .then(response => {
				if (!response.ok) {
				  throw new Error('No stagesList .json file found!');
				}
				return response.json();
			  })
			  .then( response => { 				 
				 //
				//	Populate DB: stagesList with default values -- begin
				//				 stagesList will record all stages achievements along 
				//				 gold, score, bestCombo
				//				 
				//				 unlocked will be set to true when previous strage achieved
				 //								 
				 response.stages.some(function(stage,idx){
					 stage.campaignId = idCampaign
					 stage.gold = 0
					 stage.score = 0
					 stage.bestCombo = 0
					 stage.unlocked = false					 
				 })
				 
				 spawn(function* (){					 
					yield db.stagesList.bulkPut( response.stages )	
					.then(function(lastKey){						
						////////////alert(lastKey)
					})// then
				 })				 				 
			  })// then
			  .catch(error => {
				console.error('There has been a problem with your fetch operation:', error);
			  });
			  
				Populate DB:  with default values -- end
			  */
			  
			  
			  /*
				LOAD THE stages-menu-select-XXXXXXXX.cmp.json
					- populate DB: stagesList
					DB: stagesList is used to generate stages selectors UI	
				
				- WORKS WITH PHONE
			*/

			  /*
					Populate DB: stagesList with default values -- begin
							 stagesList will record all stages achievements along 
							 gold, score, bestCombo
							 
							 unlocked will be set to true when previous strage achieved
			  */		

			console.log('campaign:'+campaign)
			console.log('idCampaign:'+idCampaign)

			  load('stages-menu-select-'+campaign,function(response0){
				  
				  let response = JSON.parse(response0)
				  
				  console.log('response:'+response)
				  
				  if (typeof response == 'undefined') {
					  throw new Error('No stagesList .json file found!');
				  }else{
					 
					 /*let response2 = response.json()
					  console.log('response2:'+response2)	*/				 
					 response.stages.some(function(stage,idx){
						 stage.campaignId = idCampaign
						 stage.gold = 0
						 stage.score = 0
						 stage.bestCombo = 0
						 stage.unlocked = false					 
					 })
				 
					 spawn(function* (){					 
						yield db.stagesList.bulkPut( response.stages )	
						.then(function(lastKey){						
							////////////alert(lastKey)
						})// then
					 })				 				 
				   }// else
									  
			  })// load
			  
			  /*
				Populate DB:  with default values -- end
			  */
					  
			}) // then
			  
			return   
		  }// if( typeof profile === 'undefined'){
			  
		  /*
				IF THERE IS NO EXISTING PROFILE -- end				
		  */		  
		  
		  
		  /*
				IF THERE IS AN EXISTING PROFILE -- begin				
					- GET THE CURRENT campaignId(currentCmpID) FROM profile
					- GET THE CAMPAIGN WITH id == currentCmpID
					- initGlobals3()
		  */
		  
		  // GET THE CURRENT campaignId FROM profile
		  var currentCmpID = profile.campaignId
		  
		  // GET campaign WHERE id == currentCmpID
		  var campaignId = yield db.campaigns.where('id').equals(currentCmpID).first()
		  
		  .then( (campaignId) => {		   
					console.log(campaignId)		   
			  if( campaignId.name !='' ){				
				/*
					CURRENT CAMPAIGN FOUND
						LOAD IT
				*/
				campaign = campaignId.name
				initGlobals3();            
				console.log(campaignId.name+' loaded')
				return false
			  }
			}) // then        
		 		
		})
	   /*.catch(function(e) {
		   //
		   // If any error occur in DB or plain exceptions, you
		   // may catch them here.
		   //
		////console.clear()
		
		  console.error("Failed: " + e);	   
		   //console.log("ASDB loaded, selecting default campaign...");	    
		 
		})// end spawn / catch*/
		
	})// end on ready
	
}// createProfile()
	
	//createProfile()
/*
	function checkCampaignExists(campaignName)
	
	PARAM:
		campaignName - string, e.g.: 'shortCmp.cmp.json'
	
	DOES:
		use existing campaign id if campaign already exists
		otherwise
		record campaign, then use new campaign id
	
*/	
window.checkCampaignExists = function(campaignName){
 let cmpIsRecorded = false
    spawn(function* (){
	   cmpIsRecorded = yield db.campaigns.where('name').equals(campaignName).toArray()
		.then(function(o){
			//alert('CMP ALREADY RECORDED! '+campaignName)
			 /* 
				CMP IS ALREADY RECORDED IN CAMPAIGNS
				ONLY RELOAD THE CAMPAIGN
				& REGENERATE THE STAGE MENU
			*/
            console.log(cmpIsRecorded.name)
            console.log(cmpIsRecorded.id)
			// GET THE CURRENT campaignId FROM profile
			  var currentCmpID = cmpIsRecorded.id
			  
			  // GET campaign WHERE id == currentCmpID
			  //var campaignId = yield db.campaigns.where('id').equals(currentCmpID).first()	

				/*
					RESET COLLECTION ARRAYS
				*/
				sprites = []
				entities = []
				brickwalls = []
				path = []
				stages = []
				sounds = []
				spriteFrames = []		
				
				/*	REGISTER SOUNDS THAT WILL NOT BE POPULATED FROM JSON -- begin */
				 sounds = []
				 registerSoundFx()
				/*	REGISTER SOUNDS THAT WILL NOT BE POPULATED FROM JSON -- end */	
				populateAssetsCollectionsFromDexieAssets()
		})
		.catch(function(error){ 
		//alert('CMP NOT RECORDED YET')		
           /*
				CMP IS NOT RECORDED IN CAMPAIGNS
					ADD CMP TO Dexie
			*/
           campaign = campaignName
			
		   addCampaignToDexie()            
        })
/*
        if(cmpIsRecorded === false){
			
        }
        else{
           
							
        }
*/		
	})// spawn
}



window.addCampaignToDexie = function(){
		//alert('ADDING CMP!')

	let idProfile = 1
		
	spawn(function*(){
		/* CREATE CAMPAIGN -- begin */ 
			  yield db.campaigns.add({			
				name: campaign			
			  })		
			  .then(function( idCampaign ){
				  /* UPDATE BLANK PROFILE WITH idCampaign -- begin */ 	
				  db.profile.update(idProfile, {campaignId: idCampaign})
					.then(function (updated) {
					if (updated) {
						console.log ("PROFILE WAS UPDATED !");					
						initGlobals3()
					}
				  })
				  /* UPDATE BLANK PROFILE WITH idCampaign -- end */ 	
				return idCampaign 
			  })/* CREATE CAMPAIGN -- end */ 
			  
			.then(function( idCampaign ){  
			 
			/*
				LOAD THE stages-menu-select-XXXXXXXX.cmp.json
					- populate DB: stagesList
					DB: stagesList is used to generate stages selectors UI					
			*/			 
			  fetch('stages-menu-select-'+campaign)
			  .then(response => {
				if (!response.ok) {
				  throw new Error('No stagesList .json file found!');
				}
				return response.json();
			  })
			  .then( response => { 				 
				 /*
					Populate DB: stagesList with default values -- begin
								 stagesList will record all stages achievements along 
								 gold, score, bestCombo
								 
								 unlocked will be set to true when previous strage achieved
				 */								 
				 response.stages.some(function(stage,idx){
					 stage.campaignId = idCampaign
					 stage.gold = 0
					 stage.score = 0
					 stage.bestCombo = 0
					 stage.unlocked = false					 
				 })
				 
				 spawn(function* (){					 
					yield db.stagesList.bulkPut( response.stages )	
					.then(function(lastKey){						
						////////////alert(lastKey)
					})// then
				 })				 				 
			  })// then
			  .catch(error => {
				console.error('There has been a problem with your fetch operation:', error);
			  });
			  /*
				Populate DB:  with default values -- end
			  */
			  
			  
			}) // then
			  
			return
	})// spawn
	
}

	
	startGame()
	
}//app_wrapper() -- end


/*
	REMOVE .unselectable FROM ALL STAGE SELECTORS
*/
window.allStagesSelectable = function(){
	document.querySelectorAll('.unselectable').forEach(function(o,i){
		o.classList.remove('unselectable')
	})
}



//
//
//  DB FUNCTIONS -- begin
//
//
/*
		function DBprofileSetSelectedChar()
    
    DOES: 
    	POPULATES db.character WITH SELECTED character
      LINKS character TO profile WITH FK profileId
      NOTE: SO FAR: 1 profile = 1 character
      POSSIBLE IMPROVEMENT  SEVERAL PROFILES AND CHARCATERS CAN BE SAVED TO db

		PARAMS:
    	var charId = 3
			var char = characters[charId-1];// charId matches character's id attribute
			var profileId = 1
*/

function DBprofileSetSelectedChar(paramsObject){
  let char = paramsObject.char,
  
	  //charId = parseInt(paramsObject.charId),
	  charId = paramsObject.charId,
	  profileId = paramsObject.profileId
		/*
		var imgSrc = characters[charId].imgSrc
		document.querySelector('#characterDetails .header .charImg')
		.setAttribute('src',imgSrc)
		
		document.querySelector('#inventory .header .charImg')
		.setAttribute('src',imgSrc)	
	*/	
  spawn (function*(){  
    /*
      SO FAR ONLY ONE CHARACTER IS SELECTED PER PROFILE
      SO DELETE ALL POTENTIALLY EXISTING CHARACTERS 
      BEFORE CREATING ONE IN characters    
    */
    yield db.character.toCollection().delete()	
	yield db.characterAttributes.toCollection().delete()
	
    // CREATE CHARACTER IN db.characters
    var characterId = yield db.character.put({
      name: char.name,
      strength: char.strength,
      resistance: char.resistance,
      charisma: char.charisma,
	  energy: char.energy,
	  lives: char.lives,
	  charId: charId,
      profileId: profileId
    },1) // FORCE PRIMARY KEY TO ALWAYS BE 1
	
	// CREATE characterAttributes IN db.characterAttributes
/*var id = ( charId == 2 ||  charId == 4)?1:0  	
	var data = characterAttributes[id]*/
	var data = characterAttributes[charId]
	
	data.some(function(charAttribute){
		charAttribute.profileId = profileId
		charAttribute.characterId = characterId
	})
	
	yield db.characterAttributes.bulkAdd(data)
	
    // UPDATE profile TO LINK character TO IT (FK: #characterId)
       var profileID = yield db.profile.update(profileId,{      
        characterId: characterId
      })
      .then((profileID) => {
        console.log('profile with id:'+profileID+' updated')
		
		// REDIRECT TO STAGE SELECTION
		hideAllPagesExcept('stageSelection')
		
      })
		// UPDATE AVATAR
		setCharAvatar(charId)
		
  })// end spawn

}

/*
		function DBprofileSetSelectedChar()
    
    DOES: 
    	GET THE character THAT HAS profileId == profileId
      POPULATE GLOBAL OBJECT profile (used to set paddle before each stage starts)
      
		PARAMS:    	
			var profileId : FK: profile.id, e.g.: 1 - required
			
			var profileId = 1
			DBprofileGetSelectedChar(profileId)
*/
//console.clear()
/*
function DBprofileGetSelectedChar( profileId ){

  spawn(function*(){  
    //      
    //GET THE character THAT HAS profileId == profileId
    //
	
  // GET profile
  var Profile = yield db.profile.where('id').equals(1).toArray()
  
  if( typeof Profile != 'undefined'){  
  
	  // GET gold FROM profile
	  gold = parseInt(Profile[0].gold)	
  }
  
    var selectedChar = yield db.character.where('profileId').equals(profileId).toArray()
   
    // UPDATE GLOBAL OBJECT profile
    profile = {
     character:{
		  name:selectedChar[0].name,
		  strength:selectedChar[0].strength,
		  resistance:selectedChar[0].resistance,
		  energy:selectedChar[0].energy,
		  charisma:selectedChar[0].charisma,
		  lives:selectedChar[0].lives,
		  charId:selectedChar[0].charId
		},
		gold:gold	
	   }
    
	  lives = selectedChar[0].lives
		
	  setCharAvatar(profile.character.charId) 	
		
  })// end spawn
	
}*/


 window.DBprofileGetSelectedChar = function( profileId ){

  spawn(function*(){  
    /*      
      GET THE character THAT HAS profileId == profileId
    */
	
	// GET profile
	let Profile = yield db.profile.where('id').equals(1).toArray()
	

	  if( typeof Profile != 'undefined'){  
	  
		  // GET gold FROM profile
		  gold = parseInt(Profile[0].gold)	
	  }
	
  
	let selectedChar = yield db.character.where('profileId').equals(profileId).toArray()
	
	console.log(selectedChar)
	
		if( typeof selectedChar != 'undefined'){
			// UPDATE GLOBAL OBJECT profile
			profile = {
				character:{
				  name:selectedChar[0].name,
				  strength:selectedChar[0].strength,
				  resistance:selectedChar[0].resistance,
				  energy:selectedChar[0].energy,
				  charisma:selectedChar[0].charisma,
				  lives:selectedChar[0].lives,
				  charId:selectedChar[0].charId
				},
				gold:gold	
			   }

			lives = selectedChar[0].lives
				
			setCharAvatar(profile.character.charId) 	
		}
		else{
			document.setTimeout(DBprofileGetSelectedChar( profileId ),100)
		}
		
	
  })// end spawn
	
}



function setCharAvatar(charId){

var imgSrc = characters[charId].imgSrc+'?time='+Date.now()
    document.querySelector('#characterDetails .header .charImg')
    .setAttribute('src',imgSrc)
    document.querySelector('#inventory .header .charImg')
    .setAttribute('src',imgSrc)	
}




//
//
//  DB FUNCTIONS -- end
//
//


//
//
//  CHARACTER SELECTION FUNCTION -- begin
//
//
/*
	function attributeLevelsDisplay( paramsObject )
	DOES :
		DISPLAY N ITEMS OF A CLASS OR ANOTHER THAT SHOW THE LEVEL
		OF A CHARACTER ATTRIBUTE SUCH AS strength, resistance, charisma, energy, lives
		
		paramsObject = {
				id: LI's id,
				max: this attribute's maximum ,
				amount: this attribute's current amount,
				[itemName]: - optional - if set, it will hilight the last rectangle filled up (after increase)
		}		
		
*/
function attributeLevelsDisplay( paramsObject ){
		
		var amount = parseInt(paramsObject.amount),
			id = paramsObject.id,
			max = parseInt(paramsObject.max),
			n = 0	
		var stars = document.createElement('div')
		
		if( amount >= max*0.75 ){
			colorClass = 'c4'
		}
		else if( amount >= max*0.5 ){
			colorClass = 'c3'
		}
		else if( amount >= max*0.25 ){
			colorClass = 'c2'
		}
		else if( amount < max*0.25 ){
			colorClass = 'c1'
		}	
		
		while( n < max ){			
			var star = document.createElement('span')				
			if( amount > 0 ){
				star.classList.add('fullRectangle',colorClass);//  c1,c2,c3,c4    //fullStar
				amount --
				/*
					SHAKE THE LAST BAR( THE LAST ONE ADDED )
				*/
				if( amount == 0 ){
					if( typeof paramsObject.itemName !== 'undefined' 
						&& id == paramsObject.itemName){  				
						star.classList.add('zoomInOutShake')
						sounds[7].play()
						
						 var li = document.querySelector('#characterDetails #charAttributesList #'+paramsObject.itemName)
						
						// NOTIFY OF PURCHASE WITH AN ANIMATION
						li.classList.add('glow')

						setTimeout(function(){
						if( li.classList.contains('glow')){
							li.classList.remove('glow')
						}},500)	
					}
				}			
			}else{				
				star.classList.add('emptyRectangle')//emptyStar
			}
			
			stars.append( star )
			n++
		}		
	
		var el = document.querySelector('#'+id)
				el.append(stars)
	
		//document.getElementById(id).innerHTML += stars

	
		
	}

function insertCharactersAttributes(){
	
	characters.some(function(item, id){
	
		var strengthContainer = document.createElement('span')
			  strengthContainer.setAttribute('id','strength'+id)
			  strengthContainer.setAttribute('data-title','strength')

		var resistanceContainer = document.createElement('span')
			  resistanceContainer.setAttribute('id','resistance'+id)	
			  resistanceContainer.setAttribute('data-title','resistance')	

		var charismaContainer = document.createElement('span')
				charismaContainer.setAttribute('id','charisma'+id) 
				charismaContainer.setAttribute('data-title','charisma')
				
		var energyContainer = document.createElement('span')
				energyContainer.setAttribute('id','energy'+id) 
				energyContainer.setAttribute('data-title','energy')

	//var li = document.querySelectorAll('#charList li')[id]
	var li = document.querySelectorAll('#charList li')[id]
		li.setAttribute('id','charLi'+id)

	var charAttrContainer = document.createElement('div')
		charAttrContainer.classList.add('charAttrContainer')
			
		charAttrContainer.append(strengthContainer)
		charAttrContainer.append(resistanceContainer)
		charAttrContainer.append(charismaContainer)
		charAttrContainer.append(energyContainer)
			
		li.append(charAttrContainer)

		//li.appendChild( document.createElement('b') )
	/*
		li.append(strengthContainer)
		li.append(resistanceContainer)
		li.append(charismaContainer)
		li.append(energyContainer)
	*/	
		
	/*
		characterAttributes[0]: settings for M. Angelo & G. Arrow (1 & 3)
		characterAttributes[1]: settings for Gabrielle & Cupid (2 & 4)
	*/
	//var Id = ( item.id == 2 || item.id == 4)?1:0  
	var Id = item.id  
		
		var maxS = characterAttributes[Id][0].max,
			maxR = characterAttributes[Id][1].max,
			maxC = characterAttributes[Id][2].max,
			maxE = characterAttributes[Id][3].max
			
		attributeLevelsDisplay({ amount:item.strength, id:'strength'+id, max:maxS})
		attributeLevelsDisplay({ amount:item.resistance, id:'resistance'+id, max:maxR})
		attributeLevelsDisplay({ amount:item.charisma, id:'charisma'+id, max:maxC})
		attributeLevelsDisplay({ amount:item.energy, id:'energy'+id, max:maxE})
					
	})
	
}
/*
	function generateCharacterSelectUI()
	
		GENERATE CHAR SELECTION UI
			- 3 COLUMNS + 1
			- CLICK ON  COLUMN -> SELECT  CHAR
			- CONFIRM SELECTION WITH SELECT BTN
*/

function generateCharacterSelectUI(){
	hideNavigationBtnsWhenInit()
	// START PLAYING ANGEL UI AMBIENT BGM
	playSound('heavenly_music-loop')
	
	// REMOVE 1ST CHILDREN EXCEPT HEADER AND FOOTER AND CHARSCROLLPAGING
	var divs = document.querySelectorAll('#characterSelection>*');	
	divs.forEach(function(item) {
	    var id = item.getAttribute('id')
		if( id !== 'characterSelectionHeader' 
		&& id !== 'characterSelectionFooter'
		&& id !== 'charSelectPaging'
		){			
			item.remove()
		}
	});
	
	var charList = document.createElement('ul')
		  charList.setAttribute('id','charList')
	
	var charDescriptions = document.createElement('div')
		  charDescriptions.setAttribute('id','charDescriptions')
	
	characters.some(function(item, idx){
		
		
		var img = document.createElement('img')
			img.src = item.imgSrc		
			img.classList.add('charImg')
			
		// create char select btn
		var detailsBtn = document.createElement('a')
			detailsBtn.setAttribute('href','#'+item.id)
			detailsBtn.classList.add('characterDetails')
			//detailsBtn.textContent = 'Details'
			detailsBtn.append(img)
		  
		var li = document.createElement('li')				
		
		// SELECT 1ST CHARACTER BY DEFAULT
		if(idx == 0){
			li.classList.add('selected')			
		}
		
		
		var div = document.createElement('div')				
		    div.append(item.name)
				div.classList.add('charName')
		
				li.append(div)				
				//li.append(item.description)			
				li.append(detailsBtn)
				
		    charList.append(li)
				
		
		// create 'select' btn
		var selectBtn = document.createElement('a')
			selectBtn.setAttribute('href','#select-'+item.id)
			selectBtn.classList.add('characterSelect')
			selectBtn.textContent = 'select'
		
		// <div class='charDesc'>...
		var charDesc = document.createElement('div')
			charDesc.classList.add('charDesc')			
			charDesc.textContent = item.description // output description in the div <div class='charDesc'>
		
		// <div id='0'>...
		var div = document.createElement('div')
			div.setAttribute('id',item.id)	
			div.classList.add('char')
			if( idx == 0 ){
				div.classList.add('selected')
			}
			
			//div.textContent = item.description // output in the div
				
			div.append(charDesc) // insert the description holder
			  
		    div.append(selectBtn) // insert the select btn
		
				charDescriptions.append(div)
		
	})
	
	var characterSelection = document.getElementById('characterSelection')
	var characterSelectionFooter = document.getElementById('characterSelectionFooter')	
	characterSelection.insertBefore(charList, characterSelectionFooter)	
	characterSelection.insertBefore(charDescriptions, characterSelectionFooter)	
	
  insertCharactersAttributes()
}

//
//
//  CHARACTER SELECTION FUNCTION -- end
//
//






//
//
//	CANVAS RELATED FUNCTIONS -- begin
//
//

	/*
		 REMOVE ALL CANVASES FROM DOM
		 REMOVE AND DEREFERENCE THEIR CORRESPONDING CONTEXTS FROM ctxs
	*/
	function removeCanvases(){
		for (var n = 0; n < canvases.length;n++){	
			var canvasObject = canvases[n]
				
				// remove the canvas from the DOM
				// remove and dereference its corresponding context
			   removeOneCanvas(canvasObject)			
		}
	}

	/*
		REMOVE ONE CANVAS FROM DOM
	*/
	function removeOneCanvas(canvasObject){
		 canvasId = canvasObject.name
		if( document.getElementById(canvasObject.name) !== null ){

			// get context object
			var ctx = search(canvasObject.name,ctxs)
			// remove it from txs[]
			ctxs.splice(ctx,1)
			  
			document.getElementById(canvasObject.name).remove() 
			console.log(canvasId+' removed !')       
		}
	}


	/* 
		INJECT ONE CANVAS TO THE DOM,
		CREATE ITS CONTEXT
		REFERENCE CONTEXT AND MAKE IT ACCESSIBLE FOR FURTHER USE VIA
		ctxs[]
		one item: {name:canvasObject.name, ctx:ctx} 
	*/
	function injectCanvasToDOM(canvasObject){
		var canvas = document.createElement('canvas');
			canvas.setAttribute('id',canvasObject.name)  
			canvas.style.zIndex = canvasObject.zIndex
			canvas.style.position = 'absolute'
			canvas.style.left = canvasObject.x
			canvas.style.top = canvasObject.y
			canvas.width = canvasObject.width
			canvas.height = canvasObject.height
			//canvas.style.background = 'rgba(254,0,128,0.8)'

		// add canvas to DOM
		  document.body.appendChild(canvas)
		// create corresponding context, reference it, & make it accessible for further use
		  var ctx = canvas.getContext('2d');
		  ctxs [ctxs.length] = {name:canvasObject.name, ctx:ctx}
	}


	/*	
		INJECT CANVASES TO DOM
		
		function injectCanvasesToDOM( canvasList )
		PARAMS:
			canvasList - string - optional		
					e.g.: injectCanvasesToDOM('ground')
		NO PARAMS: 
			INJECT ALL CANVASES FROM canvases[] TO DOM
		
	*/
	function injectCanvasesToDOM(){
		removeCanvases() //REMOVE ALL CANVASES LISTED IN canvases[] FROM DOM IF THEY ARE FOUND IN IT
		
		/*
			IF PARAM canvasList, i.e.: "canvas1,canvas2,canvasN,..." -- all canvases are referecned in canvases[]
			 is USED:
		*/
		if( arguments.length > 0){
			var canvasList = arguments[0];		
			// split canvasList to get each canvas name
			var canvas_arr = canvasList.split(',')
			for( var n = 0; n < canvas_arr.length; n++ ){
				// get context object
				var canvasObject = search(canvas_arr[n], canvases)   
				injectCanvasToDOM(canvasObject)			
			}		
		}
		else{
		// NO canvasList PARAM, INJECT ALL CANVASES FROM canvases[] TO DOM
			for (var n = 0; n < canvases.length;n++){	
				var canvasObject = canvases[n]
				injectCanvasToDOM(canvasObject)
			}
		}
		
	}
	
	
	/*
		CLEAR ALL CANVASES
	*/
	window.clearAllCanvas = function(){
		for (var n = 0; n < canvases.length;n++){	
			var canvasObject = canvases[n]
			console.log(canvasObject)
			var canvas = document.getElementById(canvasObject.name);
			var context = canvas.getContext('2d');
			context.clearRect(0,0,360,700)
		}
	}

	

/*
	ANIMATE THE STAGE SCROLLING
 */
 function scrolling() {

	  ////console.clear()
	 
	  // GET THE CANVAS CONTEXT	
	  //var ctx = search('ground',ctxs)
	 
	if( stageScrolling.length > 0 && screensToScroll > 0){  
	  for (var n = 0; n < stageScrolling.length; n++){
		  
		  if( stageScrolling.length < 1){
			break
		  }
		  
		  var removeOneScreen = false
		  	//if( typeof ( stageScrolling[n]) === 'undefined')	{continue}   
		  var ctx = search( stageScrolling[n].drawOnCanvas,ctxs )
		  
		  

		  // ANIMATION
		  if( stageScrolling[n].sprite.frameTicker == stageScrolling[n].sprite.nextFrameAt ){ 
			  stageScrolling[n].sprite.frameTicker = 0;
			  stageScrolling[n].sprite.frame++;
			  // IF ITERATED AFTER LAST FRAME, SWITCH TO FIRST FRAME
			  if( stageScrolling[n].sprite.frame > stageScrolling[n].sprite.frameMax ){
				  stageScrolling[n].sprite.frame = 0;
			  }	
			   		
		  }
			stageScrolling[n].sprite.frameTicker++
			
			// DRAW ONLY IF IN THE STAGE BOUNDARIES
			if ( 
				  stageScrolling[n].y >= 0 - parseInt(stageScrolling[n].sprite.height)
			){			
				stageScrolling[n].sprite.draw( stageScrolling[n].sprite.frame, 0, stageScrolling[n].y, ctx);// draw sprite - sprite frame index, left, top
			 }	
				if (stageScrolling[n].y > 700) {
				 
				 // 0: DO NOT LOOP
				 if( stageScrolling[n].loop == 0 ){						
						removeOneScreen = true
				 }else if( stageScrolling[n].loop > 0 ){
					 // this will one will loop one less time
					 stageScrolling[n].loop = parseInt(stageScrolling[n].loop) - 1
				 }
				 // loop == -1, just replace it at the top, above all other screens 
				 					 
										
					screensToScroll -- // 1 screen less to scroll
					if( screensToScroll < 1 ){
						 //stageScrolling = []
						 //////////////alert('SCROLLING END')
						 //break	
					}
					
					if ( removeOneScreen == true ){
						/* 
						  remove this one							
						*/
						stageScrolling.splice(n,1)// remove it
						continue// skip to next in the for loop
					}

					/*
						PLACE IT ABOVE THE SCREEN THAT HAS THE SMALLEST Y
					*/				 
					var smallestY = findMinMax(stageScrolling)[0]
					var screen = searchSmallestY(smallestY, stageScrolling )					
					stageScrolling[n].y = screen.y - parseInt(stageScrolling[n].sprite.height)//-699					
				}
		 
		  stageScrolling[n].y = parseInt( stageScrolling[n].y ) + 1;
		  
	  }// end for	
	}// end if stageScrolling.length > 0
}

function stopScrolling(){
	console.log('screensToScroll: '+screensToScroll)
	if (screensToScroll < 1){
		return true
	}
return false	
}


/*  
	function spawnScrollingScreens() 
	
	DOES:
		iterate scrollingScreens[]  
		to instanciate screens 
		and place them at their default coordinates

	//formula: y = -1 * height * position
	 e.g.:
		  0 : y = -1 * 700 * 0 = 0		  		  
		  1 : y = -1 * 700 * 1 = -700	  
		  2 : y = -1 * 700 * 2 = -1400
*/
function spawnScrollingScreens(){	
//console.clear()
	for (var n = 0; n < scrollingScreens.length; n++){
		
		var spriteName = scrollingScreens[n].spriteName,
			sprite = search(spriteName, spriteFrames),
			drawOnCanvas = scrollingScreens[n].drawOnCanvas,
			loop = scrollingScreens[n].loop
		
		var height = parseInt(sprite.height)
		
	    if ( n == 0 ){
			var position = height
		}else{
			var position = stageScrolling[ stageScrolling.length -1 ].y
		}		
		
		var y = parseInt(position) - parseInt(height)
				
		var screen = {
			y: y,			
			height: height,
			spriteName: spriteName,
			sprite: sprite,
			drawOnCanvas: drawOnCanvas,
			loop: loop
		}
		stageScrolling[ stageScrolling.length ] = screen
		console.log(/*SON.stringify(stageScrolling)*/stageScrolling[n].y)
	
	}// end for
} 


window.spawnScrollingScreens2 = function(){	

	//console.clear()
		
	//stageScrolling = [[],[],[]]
	stageScrolling = []

	/* 
		IF scrollingScreens IS UNDEFINED, SKIP spawnScrollingScreens2()
	*/		
	if( typeof scrollingScreens === 'undefined' ){return}
	if( scrollingScreens.length < 1 ){return}
		
	return new Promise(function(resolve, reject) {
	/*
		IF scrollingScreens[] has not been completely loaded
		load it again 2 seconds later
		SHOULD BE EVENTUALLY REPLACED BY A PROMISE...
	*/
	if( typeof scrollingScreens[0][0].screensToScroll == 'undefined' 
		|| typeof scrollingScreens[0][0].screensScrollSpeed == 'undefined'){		
		console.clear()
		console.log('RELOADING SCREENS')
		setTimeout(loadScrollings,1000)
			
	return
	}
		for (var m = 0; m < scrollingScreens.length; m++){
			  /*
				screensToScroll = [10,10,10]
				screensScrollSpeed = [1,1,1]
			  */	  
			screensToScroll.push(scrollingScreens[m][0].screensToScroll)  
			screensScrollSpeed.push(scrollingScreens[m][0].screensScrollSpeed)  
			
			// REMOVE THE FIRST ITEM OF THE ARRAY, i.e.: 
			// {screensToScroll:screensToScroll, screensScrollSpeed: screensScrollSpeed}	
			scrollingScreens[m].splice(0,1)		
			
			stageScrolling[m] = []
			
			for (var n = 0; n < scrollingScreens[m].length; n++){
				
				stageScrolling[m][n] = []				
				
				let spriteName = scrollingScreens[m][n].spriteName
				let sprite = search(spriteName, spriteFrames)
				let drawOnCanvas = scrollingScreens[m][n].drawOnCanvas
				let loop = parseInt(scrollingScreens[m][n].loop)		
				let height = parseInt(sprite.height)
				
			  if ( n == 0 ){
					var position = height
				}else if ( typeof stageScrolling[m][ n -1] !== 'undefined' ){
					var position = parseInt(stageScrolling[m][ n - 1].y)
				}else {
					var position = height
				}		
				
				var y = parseInt(position) - parseInt(height)
				
				var screen = {
					y: y,			
					height: height,
					spriteName: spriteName,
					sprite: sprite,
					drawOnCanvas: drawOnCanvas,
					loop: loop
				}
				
				//console.log(screen)
			
			// GET THE CANVAS, set its screensToScroll attribute
			var canvas = search( screen.drawOnCanvas, canvases )    
				canvas.screensToScroll = true
				
				stageScrolling[m][n] = screen
			
				//console.log(/*SON.stringify(stageScrolling)*/stageScrolling[m][n].y)
			
				if(
					   m == scrollingScreens.length-1
					&& n == scrollingScreens[m].length-1
				){
					console.log(JSON.stringify(scrollingScreens))
					console.log(JSON.stringify(screensToScroll))
					console.log(JSON.stringify(screensScrollSpeed))
					console.log(JSON.stringify(stageScrolling))
					
					resolve()
				}
			
			}// end for n  
			
		}// end for m 
		
		 
	})// new PROMISE
} 




	/*
		ANIMATE THE STAGE SCROLLING
	 */
	  window.scrolling2 = function() {
		
		for (var m = 0; m < stageScrolling.length; m++){  
		 
		if( stageScrolling[m].length > 0){  
		  for (var n = 0; n < stageScrolling[m].length; n++){			  
			  if( stageScrolling[m][n].length < 1){	
				 //break
					continue
			  }
			  var removeOneScreen = false
				//if( typeof ( stageScrolling[n]) === 'undefined')	{continue}   
			  var ctx = search( stageScrolling[m][n].drawOnCanvas,ctxs )
			  
			  // ANIMATION
			  if( stageScrolling[m][n].sprite.frameTicker == stageScrolling[m][n].sprite.nextFrameAt ){ 
				  stageScrolling[m][n].sprite.frameTicker = 0;
				  stageScrolling[m][n].sprite.frame++;
				  // IF ITERATED AFTER LAST FRAME, SWITCH TO FIRST FRAME
				  if( stageScrolling[m][n].sprite.frame > stageScrolling[m][n].sprite.frameMax ){
					  stageScrolling[m][n].sprite.frame = 0;
				  }		
			  }
			  
			  stageScrolling[m][n].sprite.frameTicker++				
			  // DRAW ONLY IF IN THE STAGE BOUNDARIES
				if ( 
					stageScrolling[m][n].y >= 0 - parseInt(stageScrolling[m][n].sprite.height)
				){			
					stageScrolling[m][n].sprite.draw( stageScrolling[m][n].sprite.frame, 0, stageScrolling[m][n].y, ctx);// draw sprite - sprite frame index, left, top
				}

				 
				if (stageScrolling[m][n].y > 700) {					 
					 // 0: DO NOT LOOP
					 if( stageScrolling[m][n].loop == 0 ){						
							removeOneScreen = true
					 }else if( stageScrolling[m][n].loop > 0 ){
						 // this will one will loop one less time
						 stageScrolling[m][n].loop = parseInt(stageScrolling[m][n].loop) - 1
					 }
					 // loop == -1, just replace it at the top, above all other screens 										 
										
					screensToScroll[m] -- // 1 screen less to scroll
					if( screensToScroll[m] < 1 ){
						// GET THE CANVAS, set its screensToScroll attribute
						var canvas = search( stageScrolling[m][n].drawOnCanvas, canvases )    
						canvas.screensToScroll = false						
					}
					
					if ( removeOneScreen == true ){
						/* 
						  remove this one							
						*/
						stageScrolling[m].splice(n,1)// remove it
						continue// skip to next in the for loop
					}

					/*
						PLACE IT ABOVE THE SCREEN THAT HAS THE SMALLEST Y
					*/				 
					var smallestY = findMinMax(stageScrolling[m])[0]
					var screen = searchSmallestY(smallestY, stageScrolling[m] )					
					stageScrolling[m][n].y = parseInt(screen.y) - parseInt(stageScrolling[m][n].sprite.height)//-699					
				}
		 
		  stageScrolling[m][n].y = parseInt( stageScrolling[m][n].y ) + parseInt(screensScrollSpeed[m]);			  
		  }// end for n				
		}// end if stageScrolling.length > 0		
	 }// end for m
	}// end function

//
//
//	CANVAS RELATED FUNCTIONS -- end
//
//


//
//
//	SOUND RELATED FUNCTIONS -- begin
//
//
	
	function registerSounds(soundsList){
		/*
			WILL BE CHANGED
			SHOUL:D BE LOADED FROM A 
			campaign assets json file
			or a campaign.json file
		*/
		/*var soundsList = [
			'bgm_4-loop.mp3',
			'bgm_3-loop.mp3'
			"game_assets/sounds/bgm_4-loop.mp3",
			"game_assets/sounds/bgm_3-loop.mp3",
			"game_assets/sounds/bgm_10-loop.mp3"
		]*/
		
		Array.prototype.some.call(soundsList,function(sound){
			/*
				THE NAME OF SOUND ASSETS IN campaign.json
				IS TRUNCATED, i.e.: 
				no game_assets/sounds/
				no .mp3
			*/
			var sound0 = "game_assets/sounds/"+sound+".mp3"			
			registerSound(sound0)
		})
		
	}

	/*
		USE THE SOUND SRC TO REFISTER THE SOUND
		IT WILL BE REFRENCED BY IT's NAME WITHOUT .extension
		e.g.: 
		registerSound('bgm_4-loop.mp3')
		
		call this sound:
		var name = 'bgm_4-loop'
		playSound(name)
	*/
	/*var name = 'bgm_4-loop.mp3'		
	registerSound(name)*/
	
	window.registerSound = function(src){
		
		var nameArr = src.split('/')
			name = nameArr[nameArr.length-1]
		
		var soundNameArr = name.split('.')
			soundNameArr.pop()
			soundName = soundNameArr[soundNameArr.length-1]			
		var newSound = {
			name:soundName			
		}		
		var Sound = new Howl({
		  src: [src],
		  autoplay: false,
		  loop: true,
		  volume: 0.1
		})		
		newSound.sound = Sound		
		sounds.push(newSound)
	}
		
	window.playSound =  function( name ){

		/*
				IMPLEMENT THIS TO AVOID PLYING THE SAME SOUND SEVERAL TIMES AT THE SAME TIME
			
			
			var ambSound = new Howl({
				src: [ 'game_assets/sounds/bgm_1-loop.mp3' ],
				loop: true,
				volume: 0.5
			});
			window.ambSoundId = ambSound.play();


			setTimeout(function(){
				var isPlaying = ambSound.playing( ambSoundId );
				console.log(isPlaying)
				console.log(ambSoundId)
			},1000)
			
			// FOR MUSIC
			console.log(sounds[12].sound.playing(soundsPlaying[1] ));
						
			// FOR SOUND FX
			console.log(sounds[12].sound.playing(soundsPlaying[1] ));
		*/

		
		//console.log('sound name:'+name)		
		//playing([id])
		
		// GET THE SOUND FROM THE SOUNDS COLLECTION sounds[]
		var sound = search(name, sounds)
		
		/*
			IF sound IS ALREADY PLAYING 
				SKIP
			ELSE 
				ADD sound TO soundsPlaying[]
				PLAY sound
			ENDIF
		*/
		
		/*
			SKIP THE SOUND IF IT'S ALREADY BEING PLAYED 
			ONLY IF IT IS NOT A LOOP (BGM)
		*/
		if( soundsPlaying.indexOf(sound) != -1 && sound.indexOf('loop') == -1){
			return
		}
		
		if( typeof(sound) !== 'undefined'){			
			if( typeof(sound.sound) !== 'undefined'){						
				var soundPlaying = sound.sound.play()
				//console.log(sound.sound) no
			}			
		}
		
		
	}
	
	function pauseSound( name ){		
		var sound = search(name, sounds)
		if( typeof( sound.sound )!=='undefined' ){					
				sound.sound.pause()				
		}
	}
	
	function stopSound( name ){		
		var sound = search(name, sounds)
		if( typeof( sound.sound ) !== 'undefined' ){		
			sound.sound.stop()		
		}
	}
	
	function stopAllPlayingSounds(){
		Array.prototype.some.call(sounds,function(sound, idx){
			stopSound(sound.name)
		})		
	}
	
	function pauseAllPlayingSounds(){
		Array.prototype.some.call(sounds,function(sound, idx){
			pauseSound(sound.name)
		})		
	}
	
	function resumeAllPlayingSounds(){
		/*Array.prototype.some.call(sounds,function(sound, idx){
			playSound(sound.name)
			
		})	*/		
		if( stage.music !=='' ){
			
			// GET THE BGM ID		
			var nameArr = stage.music.split('/'),
				nameWithExt = nameArr[nameArr.length-1].split('.'),
				name = nameWithExt[0]				
				/*//console.clear()
				console.log(name)	*/			
			// PLAY THE BGM
				playSound(name)
		}
	}
	
	window.pause = function(){
		paused = true		
		pauseAllPlayingSounds()		
		cancelAnimationFrame(myReq)
		return true		
	}

	window.resume = function(){
		paused = false		
		resumeAllPlayingSounds()		
		//requestAnimationFrame(main)
		//update(stageNthFrame-1)		
		update(stageNthFrame, false)
			
		return true			
	}
  
	
//
//
//	SOUND RELATED FUNCTIONS -- end
//
//

/*
	function createStageList()
	DOES:
		GENERATE A LIST OF BUTTONS TO START STAGES
	USE IT FOR TESTING - LOADS ALL STAGES FROM campaign.cmp.json AT ONCE
*/
function createStageList( collection ){
  var menuContainer = document.createElement('div');
      menuContainer.setAttribute('id','menu')
	 
    // add menuContainer to DOM
      document.body.appendChild(menuContainer)
	  for (n in collection ){
		var a = document.createElement('a')    
			  a.setAttribute('href',collection[n].name)
			  a.classList.add('stage_select')
			  a.innerText = collection[n].name 
			  menuContainer.appendChild(a)
	  }
}

/*
	function createStageList2()
	DOES:
		GENERATE A LIST OF BUTTONS TO START STAGES
		WITHOUT LOADING THE STAGES
		EACH STAGE WILL LOAD IF NOT LOADED ON CLICK OF ITS RESPECTIVE BUTTON
*/
function createStageList2( collection ){
  var menuContainer = document.createElement('div');
      menuContainer.setAttribute('id','stagesList')
	  menuContainer.classList.add('page')
	  //menuContainer.classList.add('fullScreenPage')// display the stages list fullscreen
	  
    // add menuContainer to DOM
      document.body.appendChild(menuContainer)	  
	  var ul = document.createElement('ul')	
	  
	  for (n in collection ){		  
		var a = document.createElement('a')    
			  a.setAttribute('href',collection[n])
			  a.classList.add('stage_select')
			  //a.innerText = collection[n]
			  a.innerHTML = 
			   '<span class="missionId">'+(parseInt(n)+1)+'</span>'
			  +'<span class="title">'+collection[n]+'</span>'
			  +'<span class="stars"></span>'
			  
		var li = document.createElement('li')
		    li.appendChild(a)
			ul.appendChild(li) 	 
	  }
	  
	  menuContainer.appendChild(ul)

	  document.querySelector('#stageSelection').appendChild(menuContainer)
	  
	  
	/*
			IF EXIST, GET STAGE ACHIEVEMENTS FROM DB: stages
				DISPLAY THE NUMBER OF STARS MATCHING THE VALUE OF db.stages.stage   
			- stars // can be used for ranking players on website later 
	*/
	spawn(function* (){
		  
			// GET PROFILE WHERE campaignId > 0
			var profile = yield db.profile.where('campaignId').above(0).first()
			var campaignId = profile.campaignId
			var btns = document.querySelectorAll('#stageSelection #stagesList li a.stage_select')
			console.log(btns)  
			for( let n = 0; n < btns.length; n++ ){
			  var btn =	 btns[n]
			  var stageName = btns[n].getAttribute('href')  			
					var stagesStage = yield db.stages.get({name:stageName, campaignId: campaignId})
			  if( stagesStage != undefined ){
							var starsClass = 's'+stagesStage.stars
							//btn.textContent = stagesStage.stars
				  var span = btn.childNodes[2]
				  span.classList.remove('s1','s2','s3')
				  span.classList.add(starsClass)
			  }
			}
			 
	}) // end spawn() 
	  
}



/*
		GET LIST REGISTERED stages FROM db.stages
			STORE THEM IN stagesRecords[]
			
		CREATE LIST OF STAGE SELECTION BTNS FROM collection
			FOREACH BTN BEING CREATED,
				IF stage.name IS IN stageRecords
					ADD RELEVANT starClass TO BTN'S childNode(2)
				ENDIF
			
*/

function createStageList3( collection ){
			
		var menuContainer = document.createElement('div');
			menuContainer.setAttribute('id','stagesList')
			menuContainer.classList.add('page')	
		 // add menuContainer to DOM
		document.body.appendChild(menuContainer)	  
		var ul = document.createElement('ul')
		
	spawn(function* (){
		  
			/*
					GET LIST REGISTERED stages FROM db.stages
						STORE THEM IN stagesRecords[]
			*/
			var profile = yield db.profile.where('campaignId').above(0).first()
			var campaignId = profile.campaignId
			var stagesRecords = yield db.stages.where({campaignId: campaignId}).toArray() 
			
			 /* if( typeof stagesRecords != undefined ){
					console.log(stagesRecords[0].name)
					//var starsClass = 's'+stagesStage.stars
			  }*/
			/*
				CREATE LIST OF STAGE SELECTION BTNS FROM collection			
			*/		
		
			console.log(JSON.stringify(stagesRecords))
				console.log(JSON.stringify(stage))
			collection.some(function( stage, idx ){
				
				
				console.log('idx: '+idx)
				
				var a = document.createElement('a')    
			  		a.setAttribute('href',stage)
			  		a.classList.add('stage_select')
			  		
				var starsClass = ''
								
				var sc = search(stage,stagesRecords)
				
				console.log('typeof sc:'+typeof sc)
				
				
				console.log('typeof sc == "object":'+typeof sc === "object")
				
				if( typeof sc === "object" ){
					console.log('sc:'+JSON.stringify(sc))
					console.log('sc.stars:'+sc.stars)
					starsClass = 's'+sc.stars
				}
				
				a.innerHTML = 
				 '<span class="missionId">'+(parseInt(idx)+1)+'</span>'
				+'<span class="title">'+stage+'</span>'
				+'<span class="stars '+starsClass+'"></span>'
			  
				var li = document.createElement('li')
						li.appendChild(a)
						ul.appendChild(li) 	 
			})
	
	   menuContainer.appendChild(ul)
	   document.querySelector('#stageSelection').appendChild(menuContainer)
		 addStagesDescriptions()
	}) // end spawn() 

console.log(stages)
}

/*
	ADD THE stage.description to stage select buttons .title
*/
function addStagesDescriptions(){
    stagesList.some(function(e,i){
        fetch(e+'.json')
      .then(response => {
        if (!response.ok) {
          throw new Error('Network response was not ok');
        }
        return response.json();
      })
      .then( response => { 
         if( typeof response.description != 'undefined'){
            console.log(response.description);
            document.querySelectorAll('#stageSelection #stagesList .title')[i].textContent
            =  response.description
         }
      })
      .catch(error => {
        console.error('There has been a problem with your fetch operation:', error);
      });
    })
}

function toggleMenuBackgroundScrolling(){

	if(arguments.length > 0){
		var onoff = arguments[0]
		switch(onoff){
			case 'on':
				MBG.classList.add('sliding-background')
			break;
			case 'off':
				if(MBG.classList.contains('sliding-background')){
					MBG.classList.remove('sliding-background')
				}
			break;
		}
	}
	else
	{
		if(MBG.classList.contains('sliding-background')){
			MBG.classList.remove('sliding-background')
		}else{
			MBG.classList.add('sliding-background')
		}
	}
}

window.createStageList4 = function(){
			
		var menuContainer = document.createElement('div');
			menuContainer.setAttribute('id','stagesList')
			menuContainer.classList.add('page')	
		 // add menuContainer to DOM
		document.body.appendChild(menuContainer)
		
		let ul = document.createElement('ul')
		
		menuContainer.appendChild(ul)			
		document.querySelector('#stageSelection').appendChild(menuContainer)
		
		ul = document.querySelector('#stagesList ul')
		
	spawn(function* (){
		  
			/*
					GET LIST REGISTERED stages FROM db.stages
						STORE THEM IN stagesRecords[]
			*/
			//var profile = yield db.profile.where('campaignId').above(0).first()
			
			var profile = yield db.profile.where('campaignId').above(0).first()
			
			var campaignId = profile.campaignId
			var stagesRecords = yield db.stages.where({campaignId: campaignId}).toArray() 
			
			/*
				CREATE LIST OF STAGE SELECTION BTNS FROM collection			
			*/		
		
			/*console.log(JSON.stringify(stagesRecords))
			console.log(JSON.stringify(stage))*/
			
			/*
				GET THE LIST OF STAGES 				
				IN DESCENDING ID ORDER
			*/
			var stagesList = 
			yield db.stagesList.where({campaignId: campaignId}).toArray() //.reverse() before .toArray()
			
			
			stagesList.some(function( stage, idx ){
				
				console.log('idx: '+idx)
				
				var a = document.createElement('a')    
			  		a.setAttribute('href',stage.name)
			  		a.classList.add('stage_select')
			  		
				var starsClass = ''
								
				var sc = search(stage,stagesRecords)
				
				console.log('typeof sc:'+typeof sc)
								
				console.log('typeof sc == "object":'+typeof sc === "object")
				
				if( typeof sc === "object" ){
					console.log('sc:'+JSON.stringify(sc))
					console.log('sc.stars:'+sc.stars)
					starsClass = 's'+sc.stars
				}
				
				a.innerHTML = 
				 '<span class="missionId">'+(parseInt(idx)+1)+'</span>'
				+'<span class="title">'+stage.description+'</span>'
				+'<span class="stars '+starsClass+'"></span>'
			  
				var li = document.createElement('li')
					li.appendChild(a)
					ul.appendChild(li)

				
			//if(idx == stagesList.length-1){//////////alert('menu created!')}
			})
			
	   stageLockUnlock()
		 //addStagesDescriptions()
	}) // end spawn() 
	
	
	
console.log(stages)
}

  
  document.addEventListener('click', function (event) {
	event.preventDefault();
	
	if (
		!event.target.matches('.pauseBtn')
	 && !event.target.matches('.navigation')
	 && !event.target.matches('.stage_select')
	 && !event.target.matches('.campaign_select')
	 && !event.target.matches('.stage_play')
	 && !event.target.matches('.stage_replay')
	 && !event.target.matches('.stage_next')
	 && !event.target.matches('.characterDetails')
	 && !event.target.matches('.characterSelect')
	 && !event.target.matches('.pay_to_continue')
	 && !event.target.matches('.end_game')	 
	 && !event.target.matches('.equip_weapon')
	 && !event.target.matches('.charEnhanceAttributeBtn')	
	 && !event.target.matches('.itemLi')
	 && !event.target.matches('.attrLi')
	 && !event.target.matches('.purchaseBtn')
	 && !event.target.matches('.slot')
	 && !event.target.matches('.newGame')
	 && !event.target.matches('.changeCharacter')
	 && !event.target.matches('.scrollTo')
	 && !event.target.matches('.btnCloseBriefing')
	 && !event.target.matches('.btnShowBriefing')
	 && !event.target.matches('.btnShowHowTo')
	 && !event.target.matches('.btnCloseHowTo')
	)
	{ return;}
	
	if( event.target.matches('.stopMusic') ){
		stopSound('heavenly_music-loop')// STOP MENU MUSIC
	}
	
	if( event.target.matches('.navigation') ){
		
		if( window.uiBtnsClickable !== true){return}
	}
	
	ctx.clearRect(0,0,can.width,can.height);
	
	/*
	// STOP MENU MUSIC
	stopSound('bgm_11_heavenly-music-loop')
	if( event.target.matches('.goldenBtn') ){
		playSound('bgm_11_heavenly-music-loop')	
	}
	*/
	/*
		REGENERATE SELECTED WEAPONS INVENTORY AND MAKE IT VISIBLE
		SO THAT PLAYER CAN SEE IF HE NEEDS TO BUY MORE ITEMS
		OR CHANGE ITEMS SELECTION
	*/
	if( event.target.matches('.navigation')
		|| event.target.matches('.shopBtn')
		|| event.target.matches('.angel')		
		/*|| event.target.matches('.stage_select')*/		
	){
				
		var href = event.target.href;
		/*var link_arr = Link.split('#')
		    href = link_arr[link_arr.length-1]	*/	
			
			if(    href.indexOf('#stageSelection') != -1
				|| href.indexOf('#homeScreen') != -1
				|| href=='#'){
				selectedWeaponsPopulate('hide')	
				randomizeHomeScreenAngel()				
			}
			else{
				//updateWeaponsUI()
				selectedWeaponsPopulate('show')
			}
			
			hideBriefing()
			hideHowTo()		
			
			if(    href.indexOf('#stageSelection') != -1){
				if( document.querySelectorAll('.btnShowBriefing').length > 0 ){				
					document.querySelector('.btnShowBriefing').remove()		
				}
			}
			
	}
	
	/*
		SHOW BRIEFING BTN -- begin
	*/
	if( 
		event.target.matches('.btnShowBriefing')
	){
		showBriefing()
		return
	}
	/*
		HIDE BRIEFING BTN -- end
	*/
	
	/*
		HIDE BRIEFING BTN -- begin
	*/
	if( 
		event.target.matches('.btnCloseBriefing')
	){
		hideBriefing()
		return
	}
	/*
		HIDE BRIEFING BTN -- end
	*/
	
	/*
		SHOW HOWTO BTN -- begin
	*/
	if( 
		event.target.matches('.btnShowHowTo')
	){
		showHowTo()
		return
	}
	/*
		SHOW HOWTO BTN -- end
	*/
	
	/*
		HIDE HOWTO BTN -- begin
	*/
	if( 
		event.target.matches('.btnCloseHowTo')
	){
		hideHowTo()
		return
	}
	/*
		HIDE HOWTO BTN -- end
	*/
	
	/*
		PAUSE BTN -- begin
	*/
	if( 
		event.target.matches('.pauseBtn')
	)
	{
		if( paused == false ){	
			hidePage( 'UI_wrapper' )
			pause()			
			paused = true
			// SHOW THE pauseScreen ONLY
			hideAllPagesExcept('pauseScreen')
			return
		}else{			
			paused = false			
			// HIDE ALL SCREENS EXCEPT THE MAIN STAGE
			hideAllPagesExcept('UI_wrapper')
			resume()
			return
		}
	}
	/*
		PAUSE BTN -- end
	*/
		
	/*
		CAMPAIGN SELECT BTN -- begin
		
		NEW WAY TO SELECT A CAMPAIGN	
			Dexie not deleted
				- records, weapons, characterics kept
			DOES NOT WORK SO FAR, can be fixed
		
		
		
	if( 
		event.target.matches('.campaign_select')		
	)
	{
		var campaignName = event.target.href;
		var name_arr = campaignName.split('#')
		    campaignName = name_arr[name_arr.length-1]		
		
		var el = document.querySelector('#stageSelection #stagesList')			
		if(typeof el !=='undefined'){
			el.remove()
		}			
		
		campaign = campaignName
		
		//db.close()
		checkCampaignExists(campaignName)
	}
	
		CAMPAIGN SELECT BTN -- end
	*/
	
	
	/*
		CAMPAIGN SELECT BTN -- begin
	*/
	if( 
		event.target.matches('.campaign_select')		
	)
	{
		var campaignName = event.target.href;
		var name_arr = campaignName.split('#')
		    campaignName = name_arr[name_arr.length-1]		
			
		/*  -- RESTORE*/
		
		db.delete().then(() => {		
			var el = document.querySelector('#stageSelection #stagesList')			
				if(typeof el != null){//'undefined'
					el.remove()
				}			
			startGame(campaignName)			
		})
		
		var el = document.querySelector('#stageSelection #stagesList')			
				if(typeof el != null){//'undefined'
					el.remove()
				}				
		
		startGame(campaignName) //-- RESTORE
		
		//db.close()
		//createProfile(campaignName)
	}
	/*
		CAMPAIGN SELECT BTN -- end
	*/
	
	
	
	/*
		STAGE SELECT BTN -- begin
	*/
	if( 
		event.target.matches('.stage_select')		
	)
	{
		// IF STAGE BTN IS LOCKED THEN ESCAPE
		if(event.target.matches('.unselectable')){return}
		
		toggleMenuBackgroundScrolling('on')
		
		if( document.querySelector('#endStage').classList.contains('UI-animation-down')){
			document.querySelector('#endStage').classList.remove('UI-animation-down')
		}
					
		// UPDATE MISSION DETAILS TITLE
		var missionId = event.target.childNodes[0].textContent // missionId
		document.querySelector('#stageDetails .screenTitle').textContent = 'Mission '+missionId
		
		//stages = []
		paused = false		
		var stageName = event.target.href;
		var name_arr = stageName.split('/')
		    stageName = name_arr[name_arr.length-1]		
		//stages = [] // EMPTY stages[]	
		
		resetStageVars() // RESET ALL STAGES VARS

		/*
			LOAD PROFILE CHARACTER
			SO FAR THERE IS ONLY 1 profile = 1 character HENCE profileID = 1
		*/
		var profileId = 1
		
		promises = []
		
		
		DBprofileGetSelectedChar(profileId)		
		
		// LOAD THE STAGE FROM .json
		//loadStageFromJson(stageName)
		// LOAD THE STAGE FROM Dexie: db.assets
		//////////alert('11787 - stageName: '+stageName)
		LoadStageFromStagesOrFromDexieAssets(stageName)
				
		/*
		Promise.all(promises).then(function(values) {			
			console.log('stage '+stageName+' loaded')
			loadStageFromStages( stageName )	
			
			// STAGE DETAILS: SHOW[PLAY]
			toggleButtonsVisibility([					
				{
					selector:'#stageDetails .stageDetailsControls .stage_play',
					removeClass: 'hiddenUIBtn',
					addClass:''
				}]				
			)
			// SLIDE #stageDetails DOWN
			document.querySelector('#stageDetails').classList.add('UI-animation-down')
			//hideAllPagesExcept('stageDetails')
			
			showPage('stageDetails')
			
			
			//setTimeout(hidePage('stageSelection'),1000)
			hidePage('stageSelection')
			
		})
		return*/
		
		// MAKE THE WEAPON SELECTOR VISIBLE
		if( document.querySelector('#weaponsSelector') != null ){
			document.querySelector('#weaponsSelector').classList.add('inmenu')		
		}
	}
	/*
		STAGE SELECT BTN -- end
	*/
	
	
	if( 
		event.target.matches('.characterDetails')
	)
	{	

		if(document.querySelectorAll('.cupidHeart').length > 0){
			document.querySelectorAll('.cupidHeart').forEach(function(o){o.remove()})
		}
		 
		window.clearTimeout(spitHearts)
		// IF CUPID IS SELECTED THEN SPIT HEARTS
		
	
		var charNameArray = event.target.href.split('#');
		var charName = charNameArray[1]				
		hideAllCharactersExcept(charName)		
		selectOneCharacter(charName)
				
		sounds[0].play()// hey!		
		
		if(document.querySelector('#charLi3').classList.contains('selected') === true){
		//if(document.querySelector('li.selected').find('img') === true){
			spitCupidHearts()
		}else{
			window.clearTimeout(spitHearts)
		}
		
		return
	}
	/*
		CHARACTER DETAILS BTN -- end
	*/
	
	/*
		BUY BTN -- begin
		>	#characterDetails
	*/
	if( 
		event.target.matches('.charEnhanceAttributeBtn')
	)
	{		
		var itemNameArray = event.target.href.split('#');
		var itemName = itemNameArray[1]				
		var cost = event.target.getAttribute('cost')
		var max = event.target.getAttribute('max')
		
		
		// REMOVE .selected FROM ALL LIST ITEMS			
		var lis = document.querySelectorAll('#characterDetails #charAttributesList li')
		Array.prototype.some.call(lis,function(li){
			console.log(li)
			li.classList.remove('selected')	
		})
		/*console.clear()
		console.log(event.target.parentNode)
		console.log(event.target.parentElement)*/

		
		lastClickedAttrBtn = event.target.parentElement
		//event.target.parentElement.classList.add('selected')
				
		
		charEnhanceAttribute(itemName,cost,max)			
		
			
		
		return
	}
	/*
		BUY BTN BTN -- end
	*/
	
	/*
		PURCHASE BTN LI PARENT -- begin
		>	#inventory
	*/
	if( 
		event.target.matches('.attrLi')
	)
	{		
		var title = event.target.getAttribute('data-title')
		var description = event.target.getAttribute('data-description')
		
		var el = document.querySelector('#characterDetails .header .description')
			el.innerHTML = 
				'<span class="title">'+title+':</span>' 
				+'<span class="details">'+description+'</span>' 
				/*+ '<br/>' 
				+ '<span class="title">duration: </span>' 
				+ '<span class="details">'+duration+'</span>' 
			*/
			// REMOVE .selected FROM ALL LIST ITEMS			
			var lis = document.querySelectorAll('#characterDetails #charAttributesList li')
			Array.prototype.some.call(lis,function(li){
				console.log(li)
				li.classList.remove('selected')	
			})
			
			// CONFIRM PURCHASE HAS BEEN DONE
			sounds[4].play();// missed
			
						
			event.target.classList.add('selected')	
			
			
			
		return
	}
	/*
		PURCHASE BTN LI PARENT  -- end
	*/
	
	/*
		PURCHASE BTN LI PARENT -- begin
		>	#inventory
	*/
	if( 
		event.target.matches('.itemLi')
	)
	{		
		var description = event.target.getAttribute('data-title')
		var duration = event.target.getAttribute('data-duration')
		
		var el = document.querySelector('#inventory .header .description')
			el.innerHTML = 
				'<span class="title">effect: </span>' 
				+'<span class="details">'+description+'</span>' 
				+ '<br/>' 
				+ '<span class="title">duration: </span>' 
				+ '<span class="details">'+duration+'</span>' 
			
			// REMOVE .selected FROM ALL LIST ITEMS			
			var lis = document.querySelectorAll('#inventory #inventoryItems li')
			Array.prototype.some.call(lis,function(li){
				console.log(li)
				li.classList.remove('selected')	
			})
			sounds[4].play()
			event.target.classList.add('selected')	
		return
	}
	/*
		PURCHASE BTN LI PARENT  -- end
	*/
	
	/*
		PURCHASE BTN  -- begin
		>	#inventory
	*/
	if( 
		event.target.matches('.purchaseBtn')
	)
	{		
		var purchaseBtnArray = event.target.href.split('#');
		var entityName = purchaseBtnArray[1]
		purchaseItem(entityName)
				
		// REMOVE .selected FROM ALL LIST ITEMS			
		var lis = document.querySelectorAll('#inventory #inventoryItems li')
		Array.prototype.some.call(lis,function(li){
			console.log(li)
			li.classList.remove('selected')	
		})
		// SELECT parent LI
		event.target.parentElement.classList.add('selected')	
		
		return
	}
	/*
		PURCHASE BTN  -- end
	*/
	
	
	/*
		SLOT SELECT BTN  -- begin		
	*/
	if( 
		event.target.matches('.slot')
	)
	{		
		var slotIdx = event.target.getAttribute('idx')
		var itemName = event.target.getAttribute('itemName')
		
		var paramsObject = {
			idx: slotIdx,
			itemName: itemName
		}
		itemSlotSelect( paramsObject )
		return
	}
	/*
		SLOT SELECT  -- end
	*/
	
	
	/*
		CHARACTER SELECT BTN -- begin
	*/
	if( 
		event.target.matches('.characterSelect')
	)
	{
		stopSound('heavenly_music-loop')
		sounds[9].play()
		var charNameArray = event.target.href.split('#');
		var charName = charNameArray[1]// e.g.:	select-3			
		var charId = charName.split('-')[1]			
		document.getElementById('charLi'+charId).classList.add('chosen')		
		
		var char = characters[charId];// charId matches character's id attribute
		var profileId = 1// SO FAR THERES IS 1 PROFILE ONLY
		
		var paramsObject = {
			char: char,
			charId: charId,
			profileId: profileId 
		}
		
		setTimeout(function(){
			// SET THE PROFILE's SELECTED CHARACTER
			DBprofileSetSelectedChar(paramsObject)
		},1000)
		
		randomizeHomeScreenAngel()
		
		return
	}
	/*
		CHARACTER SELECT BTN -- end
	*/
	/*
		STAGE EQUIP WEAPON BTN -- begin
	*/
	if( 
		event.target.matches('.scrollTo')
	)
	{
		var Href = document.querySelector('#characterSelection #charList li.selected a').getAttribute('href')
		
		var idx = parseInt(Href.substr(1,1))//keep the N, not the #	
		if( 
			event.target.matches('.right')
		){			
			idx ++// add +1 to idx
				
		}else if( 
			event.target.matches('.left')
		){			
			idx --// add +1 to idx				
		}		
		if(idx > 2){idx = 3;}
		if(idx < 1){idx = 0;}		
		if( document.querySelectorAll('#characterSelection #charList li.selected').length > 0 ){
			document.querySelector('#characterSelection #charList li.selected').classList.remove('selected')
			document.querySelector('a[href="#'+idx+'"]').parentElement.classList.add('selected')
		}
		else if( document.querySelectorAll('#characterSelection #charList li.selected').length < 1 ){
			document.querySelectorAll('#characterSelection #charList li')[0].classList.add('selected')
		}		
		document.location.href = '#charLi'+idx;		
		if( document.querySelectorAll('#charDescriptions .char.selected').length > 0 ){
			document.querySelector('#charDescriptions .char.selected').classList.remove('selected')			
		}		
		showChar( idx )
		
		if(document.querySelector('#charLi'+idx).classList.contains('selected') === true){		
			spitCupidHearts()
		}else{
			window.clearTimeout(spitHearts)
		}
		sounds[0].play()// hey!		
		return
	}
	
	/*
		STAGE EQUIP WEAPON BTN -- begin
	*/
	if( 
		event.target.matches('.equip_weapon')
	)
	{	
		if( event.target.getAttribute('count') == 0  ){
			event.target.setAttribute('count','+')
			//////////alert('BUY ITEM')
			return
		} else 
		if( event.target.getAttribute('count') == '+'  ){
			//////////alert('BUY ITEM')
		}
		else
		if( event.target.getAttribute('count') > 0  ){
			var paramsObject = {
				category: event.target.getAttribute('category'),
				entityName : event.target.getAttribute('entityName'),    
				duration: event.target.getAttribute('duration'),
				count: event.target.getAttribute('count')
			}		
			/* 
				EQUIP PADDLE WITH SELECTED WEAPON
					UPDATE THIS WEAPON'S COUNT IN #weaponsList					
			*/
			equipWeapon(paramsObject)
		}		
		return
	}
	/*
		STAGE EQUIP WEAPON BTN -- end
	*/
		
	/*
		STAGE INGAME PAY TO CONTINUE BTN -- begin
	*/
	if( 
		event.target.matches('.pay_to_continue')
	)
	{		
		useGoldToContinue()
	}
	/*
		STAGE INGAME PAY TO CONTINUE BTN -- end
	*/
	
	/*
		START A NEW GAME
			ERASE ALL DATA.
			GO TO CHARACTER SELECT
	*/
	if( 
		event.target.matches('.newGame')
	){		
		newGame()
		//document.location.href = '#charLi0'// fix for scroll		
		return 		
	}
	
	/*
		GO TO CHARACTER SELECT
	*/
	if( 
		event.target.matches('.changeCharacter')
	){
		changeCharacter()	
		return 		
	}
	
	
	/*
		STAGE INGAME END GAME BTN -- begin
	*/
	if( 
		event.target.matches('.end_game')
	)
	{
		hidePage('pauseScreen')
		hidePage('stagePayToContinue')
		toggleMenuBackgroundScrolling('on')		
		
		var message = 
		'Mission aborted!'
		+'<br/>'
		+'You will do better next time!'
		
		modal('modal', message, 'UI-animation-down',3000 )
		
		paddle.noMorePowerUpsFx = true
		
		//displayAngel = false	
		setTimeout(function(){
			stageEnded = true
			
		endStage({
			status: 'failure',
			reason: 'noLivesLeft'
		})
		},3000)
		
		/*
		// PAUSE, THEN STOP EVERYTHING
		cancelAnimationFrame(myReq)
		// STOP ALL PLAYING SOUNDS
		stopAllPlayingSounds()				
		// IF RAF LOOPING, THEN EXIT IT 				
		stageEnded = true	
		*/
		return 
		
	}
	/*
		STAGE INGAME PAY TO CONTINUE BTN -- end
	*/
	
	
	/*
		STAGE PLAY BTN -- begin
	*/
	if( 
		event.target.matches('.stage_play')
	)
	{	
/*	
		touchEventsInit(); // INIT TOUCH EVENTS (MOBILE)		
		mouseEventsInit() // INIT MOUSE EVENTS (PC)			
*/		
		hideBriefing()
		toggleMenuBackgroundScrolling('off')
		
		//spawnScrollingScreens2()	
		var stageName = stage.name	
		console.log('11544: stage'+stage)
		console.log('11544: stageName'+stageName)
		
		start_game(stageName)		
		return
	}
	/*

		STAGE PLAY BTN -- end
	*/
	
	/*
		STAGE REPLAY BTN -- begin
	*/
	if( 
		event.target.matches('.stage_replay')
	)
	{	
		hideBriefing()
		if( window.uiBtnsClickable !== true){return}
		stages = [] // EMPTY stages[]	
		paused = false		
		var stageName = stage.name//event.target.href;
		
		resetStageVars() // RESET ALL STAGE's VARS	
		
		/*loadStageFromJson(stageName)		
		Promise.all(promises).then(function(values) {			
			console.log('stage '+stageName+' loaded')*/			
			//loadStageFromStages( stageName )
			
			loadStageFromDexieAssets( stageName, 'stage_replay' )
			
			/* // STAGE DETAILS: SHOW[PLAY] , HIDE #endStage [RETRY] && [NEXT]
				toggleButtonsVisibility([
					{
						selector:'#endStage .stageDetailsControls .stage_replay',
						removeClass: '',
						addClass:'hiddenUIBtn'
					},
					{
						selector:'#endStage .stageDetailsControls .stage_next',
						removeClass: '',
						addClass: 'hiddenUIBtn'
					},
					{
						selector:'#stageDetails .stageDetailsControls .stage_play',
						removeClass: 'hiddenUIBtn',
						addClass:''
					}
					]				
				)
		if( document.querySelector('#endStage').classList.contains('UI-animation-down')){
			document.querySelector('#endStage').classList.remove('UI-animation-down')
		}
		// SLIDE #stageDetails DOWN
			document.querySelector('#stageDetails').classList.add('UI-animation-down')					
			hideAllPagesExcept('stageDetails')
		//}) */
		return		
	}
	/*
		STAGE REPLAY BTN -- end
	*/
	
	
	/*
		STAGE NEXT BTN -- begin
	*/
	if( 
		event.target.matches('.stage_next')
	){
		hideBriefing()
		if( window.uiBtnsClickable !== true){return}
		stages = [] // EMPTY stages[]			
		paused = false		
		
		resetStageVars() // RESET ALL STAGES VARS

			// UPDATE MISSION N
			var missionLabel = document.querySelector('#stageDetails .screenTitle').textContent
			var missionLblArr = missionLabel.split(' ')
			
			var num = parseInt(missionLblArr[1])
			console.log('mission accomplished:'+num)
				//num--;// stagesList is a zero index array
			
			let stageName
			spawn(function*(){
				campaignId = 1
				let stages = yield db.stagesList          
					  .toArray()
					 /* .then(function(stages){
						console.log(JSON.stringify(e))
						stageName = stages[num]
					  })*/
				stageName = stages[num].name
				
				console.log(stageName)
				
				console.log('stageName:'+stageName)
				
				loadStageFromDexieAssets( stageName, 'stage_next' )	
				
				num++
				
				console.log('next mission:'+num)
				
				document.querySelector('#stageDetails .screenTitle').textContent
				= 'Mission '+num				
				
			})

			
			
				
			//var stageName = stagesList[num].name
			
			/*
			console.log('stageName:'+stageName)
			loadStageFromDexieAssets( stageName, 'stage_next' )	
			
			num++
			
			console.log('next mission:'+num)
			
			document.querySelector('#stageDetails .screenTitle').textContent
			= 'Mission '+num*/
			
	}
	/*
		STAGE NEXT BTN -- end
	*/
	
	/*
		IF PLAYER CLICKED PAUSE > QUIT BTN
		STOP EVERYTHING RESET ALL STAGE VARS
		THEN REDIRECT THE PLAYER TO THE STAGES SELECTION MENU
	*/	
	if( 
		event.target.matches('.quit')
	){
		/* 	
			HIDE 
				TIMER
				PAUSE BUTTON
				TOP AD BANNER ( LATER )
		*/
		
		/* HIDE PAUSE BTN */
		toggleButtonsVisibility([					
			{
				selector: '#pauseBtn',
				removeClass: 'visible',
				addClass:''
			}]				
		)
		
		
		toggleMenuBackgroundScrolling('on')
		
		// IF RAF LOOPING, THEN EXIT IT 				
		stageEnded = true
		
		stage.ingame = false; // keypress events true | false
		
		// PAUSE, THEN STOP EVERYTHING
		cancelAnimationFrame(myReq)
		// STOP ALL PLAYING SOUNDS
		stopAllPlayingSounds()	
		
		// CLEAR ALL TIMEOUTS
		var id = window.setTimeout(function() {}, 0);
		while (id--) {
			window.clearTimeout(id); // will do nothing if no timeout with id is present
		}
		
		// CLEAR CANVASES
		clearAllCanvas()
		
		hidePage( 'UI_wrapper' )
	
		/*
		// REMOVE #weaponsList IF EXISTS
		var i = document.querySelector('#weaponsSelector #weaponsList') 
		if ( i !== null){
			i.remove()
		}
		*/		
		stages = []
		paused = false
		// RESET ALL STAGE VARS		
		resetStageVars()
				
		DBupdateWeaponsList()// UPDATE DB WEAPONS RECORDS
		//return
	}
	
	var profileId = 1
	
	DBprofileGetSelectedChar( profileId )
	
	/*
		NAVIGATION BTNs -- begin
	*/	
	var href = event.target.getAttribute('href')
/*
	// [ Angel ] button
	if( href == '#characterDetails' ){		
		insertCharactersEditableAttributes()
		//hideAllPagesExcept('characterDetails')		
	}
	*/
	
	/*
		HIDE WEAPONS SELECTOR
		WHEN GOING TO CERTAIN PAGES
	
	if( 
		(
		   href == '#homeScreen' 
		|| href == '#stageSelection'		
		)
		&& document.querySelector('#weaponsSelector') !== null
	){	
		if ( document.querySelector('#weaponsSelector').classList.value.indexOf('toFront')!= -1 ){
			document.querySelector('#weaponsSelector').classList.remove('toFront')
		}
	}*/
		
	var pageId = href.substr(1);// get rid of #		
		hideAllPagesExcept(pageId)

	/*
		UI NAVIGATION
			angel
			weapons
			mission
	*/
	
	
	
	switch( pageId ){
		case 'inventory':
			// REFRESH THE LIST OF WEAPONS SELECTED FOR STAGE
			insertInventoryItems()
			selectedWeaponsPopulate('show')	
		break;
		case 'characterDetails':
			// 	REFRESH CHARACTERS UI 
			insertCharactersEditableAttributes()
			// REFRESH THE LIST OF WEAPONS SELECTED FOR STAGE
			selectedWeaponsPopulate('show')	
		break;
		case 'stageDetails':
			// REFRESH THE LIST OF WEAPONS SELECTED FOR STAGE
			selectedWeaponsPopulate('show')	
		break;
	}
	
	/*
	if(
		href == '#stageSelection'
	){
		// MAKE THE WEAPON SELECTOR VISIBLE
		document.querySelector('#weaponsSelector').classList.remove('inmenu')		
	}*/
	/*
		NAVIGATION BTNs -- end
	*/
	
  }, false);	
	
	
	

 window.playStageMusic =   function(){		
		if( stage.music !== '' ){			
			// GET THE BGM ID		
			var nameArr = stage.music.split('/'),
				nameWithExt = nameArr[nameArr.length-1].split('.'),
				name = nameWithExt[0]
				
			// PLAY THE BGM
				playSound(name)
		}
	}

	app_wrapper()
   
	/*
	  APP NAVIGATION -- begin
	*/
	 window.hideAllPagesExcept = function(pageId){
	  // REMOVE .fullScreenPage FROM ALL .page
	  let pages = Array.from(document.querySelectorAll('.fullScreenPage')); 
	  for( let n = 0 ; n < pages.length; n++){      
		if ( pages[n].classList.contains('fullScreenPage') ){
		  pages[n].classList.remove('fullScreenPage')
		}
	  }
	  if( pageId != '' ){
		showPage( pageId )
	  }	  
	}

	function showPage( pageId ){
	  if ( document.getElementById(pageId) !== null ){
		document.getElementById(pageId).classList.add('fullScreenPage')
	  }	  
	}
	
	function hidePage( pageId ){
	  if ( document.getElementById(pageId) !== null ){
		document.getElementById(pageId).classList.remove('fullScreenPage')
	  }	  
	}
	
	window.selectPage = function (pageId){	  
	  hideAllPagesExcept(pageId)	
	}
	
		
	window.toggleButtonsVisibility = function( paramsObject ){
			
	  paramsObject.some(function(btn, idx){
			
			var selector = btn.selector,
				  removeClass = btn.removeClass,
				  addClass = btn.addClass
				
			var btn = document.querySelector(selector)	
      
			  if( removeClass !='' ){          
			  if ( btn.classList.contains(removeClass) ){           
					btn.classList.remove(removeClass)
			  } 
        }
      
      	if( addClass !='' ){
			btn.classList.add(addClass)
        }		
      
	  })
	  
	}
	/*
	  APP NAVIGATION -- end
	*/


	/*
		CHARACTERS SELECTION -- begin	
	*/
	
	/*
	  APP NAVIGATION -- begin
	*/
	 window.hideAllCharactersExcept = function(charId){
	  // REMOVE .fullScreenPage FROM ALL .page
	  let chars = Array.from(document.querySelectorAll('.char')); 
	  for( let n = 0; n < chars.length; n++){      
		if ( chars[n].classList.contains('selected') ){
		  chars[n].classList.remove('selected')
		}		
	  }
	  if( charId != '' ){
		showChar( charId )
		//selectOneCharacter(charId)
	  }	
	  return	  
	}
	
	
	/*
	  APP NAVIGATION -- begin
	*/
	 window.selectOneCharacter = function(charId){
		 
	  // REMOVE .fullScreenPage FROM ALL .page
	  let LIs = Array.from(document.querySelectorAll('#characterSelection #charList li')); 
	  for( let n = 0 ; n < LIs.length; n++){      
		if ( LIs[n].classList.contains('selected') ){
		  LIs[n].classList.remove('selected')
		}		
	  }
	  /*let n = 0
	  while(n < LIs.length){      
		if ( LIs[n].classList.contains('selected') ){
		  LIs[n].classList.remove('selected')
		}		
		n++
	  }
	  */
	  //if( charId != '' ){
		//document.getElementById(charId).parentElement.classList.add('selected')	
		document.querySelector('#characterSelection #charList li a[href="#'+charId+'"').parentElement.classList.add('selected')				
	  //}
	  
	}
	
	
	function showChar( charId ){
	  if ( document.getElementById(charId) !== null ){
		document.getElementById(charId).classList.add('selected')
	  }	  
	}
	
	function hideChar( charId ){
	  if ( document.getElementById(charId) !== null ){
		document.getElementById(charId).classList.remove('selected')
	  }	  
	}
	
	
	/*
		CUPID ONLY -- begin
	
	*/
	window.spitHearts = false
	window.spitCupidHearts = function(){
		
		window.clearTimeout(spitHearts)
		
		if(document.querySelectorAll('.cupidHeart').length > 0){
			document.querySelectorAll('.cupidHeart').forEach(function(o){o.remove()})
		}
		
		 if(document.querySelector('#charLi3').classList.contains('selected') === false){			
			window.clearTimeout(spitHearts)
			//return
		 }
		 else if(document.querySelector('#charLi3').classList.contains('selected') === true){
		  
			let heart = ['heart0','heart1','heart2','heart3','heart4'] 
			   
			  heart.some(function(obj,idx){ 
				spawnHeart(idx)
			  })   		  
			  //spitHearts = window.setTimeout(spitCupidHearts,4000)
			
		 }
		
	}

	function spawnHeart(idx){
		let target = document.querySelector('#charList');
		let cupidHeart 
			   = document.createElement('div')        
		   cupidHeart
		   .classList.add('cupidHeart')
		   cupidHeart
		   .classList.add('heartFloatUp')        
			cupidHeart
		   .classList.add('heart'+idx)       
		   cupidHeart.setAttribute('id','heart-'+idx)

		   let rnd =  20 + Math.floor(Math.random()*Math.floor(14))
			console.log(rnd)
		   cupidHeart.setAttribute('style','top:'+rnd.toFixed(0)+'%')
		   target.after(cupidHeart);
	}
	
	
	/*
		CUPID ONLY -- end
	
	*/
	
	
	/*
		CHARACTERS SELECTION -- end	
	*/





	/*
	  END OF STAGE STARS -- begin
	*/
	window.resetStars = function (){
		// HIDE ANIMATED STAR
			document.querySelector('.star').classList.add('hidden')  
		// REMOVE ALL STARS = SET THE SPRITE TO EMPTY STARS
			document.querySelector('#starsHolder').classList.remove('s1','s2','s3') 
		starsIdx = 0
		sClass = {}
		totalStars = 0 
	}

	window.animateStar = function(){
	  let location = sClass.location,
		  sprite = sClass.sprite
	  document.querySelector('.star')
	  .classList.remove('starx1','starx2','starx3','UI-stage-left-star','UI-stage-middle-star','UI-stage-right-star')
	  document.querySelector('.star').classList.add(sClass.sClass) 
	  document.querySelector('.star').classList.add(location) 
	  document.querySelector('.star').classList.add(sprite) 
	  document.querySelector('.star').classList.remove('hidden')
	  document.querySelector('.star').classList.add('star-animation')
	  setTimeout(function(){
		  /* PLAY GOT A STAR SOUND */
		  sounds[7].play()
		// HIDE ANIMATED STAR
		document.querySelector('.star').classList.remove('star-animation')
		document.querySelector('.star').classList.add('hidden')
		// UPDATE STARS HOLDER SPRITE
		document.querySelector('#starsHolder').classList.remove('s1','s2','s3')
		document.querySelector('#starsHolder').classList.add(sClass.sClass) 
		if( starsIdx < totalStars ){
		modal( 'miniModal', starsReasons[starsIdx].lbl, 'bounceInLeft', 1000, 'starReason')			
		  setTimeout(function(){
			//modal( 'miniModal', starsReasons[starsIdx].lbl, 'bounceInLeft', 1000, 'starReason')
			starsIdx++
			updateStarsHolder()
		  }, 1000)
		}
		
		
	  },300)    
	}


	 window.updateStarsHolder = function(){
	  if( starsIdx < totalStars ){        
		sClass = sClasses[starsIdx]  
		animateStar()
	  }else{
		setTimeout(function(){			
			incrementScore()			
		},1000)			
	  }
	}
	/*
	  END OF STAGE STARS -- end
	*/

	/*
		END OF STAGE 
		UPDATE GOLD AND SCORE -- begin
	*/
		/*
			ADD AS MANY GOLD COINS TO GLOBAL JS gold 
				AS THE PLAYER EARNED DURING THE STAGE
		*/
		window.incrementGold = function(){
			let earnedGold = parseInt(stage.earnedGold),
			    goldHolder = document.querySelector('#endStage .score-gold .gold')		  
		  earnedGold --;
		  stage.earnedGold = earnedGold  		  
		  goldHolder.textContent = parseInt(goldHolder.textContent) + 1    
		  // PLAY A SOUND EVERY TIME A COIN IS ADDED
		  sounds[7].play()  
		  
		  /*
				WHEN THE GOLD COUNT HAS FINISHED: (earnedGold < 1)
					ADD 
						THE GOLD FROM goldHolder
					    TO THE GOLD SAVED IN profile 
					TO HAVE THE TOTAL AMOUNT OF GOLD 
					UPDATE profile.gold = totalGold					
		  */
		  
		  if( earnedGold < 1 ){
			
			spawn(function* (){				
			  gold = parseInt(goldHolder.textContent)
			  profile.gold = yield db.profile.where({id:1}).toArray(function(i){				  
			   var gld = ( isNaN(i[0]) )?0:i[0].gold 
				 console.log('gld:'+gld)
				return gld
			  })
			  var totalGold = parseInt(gold) + parseInt(profile.gold)
			  db.profile.update(1,{gold:totalGold})// UPDATE DB > profile > gold
			})

			cancelAnimationFrame( incrementGold )			
		  }
		  else{
			myReq = requestAnimationFrame( incrementGold )
		  }		  
		}
		
		/*
			ADD AS MANY GOLD COINS TO GLOBAL JS gold 
				AS THE PLYER EARNED DURING THE STAGE
		*/
		window.incrementScore = function(){
			let stageScore = parseInt(stage.score),
			    scoreHolder = document.querySelector('#endStage .score-gold .score'),
				amount = 100,  // amount is counting step
				stageScoreArchive = stageScore
				
			  if( stageScore - amount <= 0 ){
				  amount = stageScore			  
			  } 			  
			  stageScore -= amount;			  
			  stage.score = stageScore 			  
			  scoreHolder.textContent = parseInt(scoreHolder.textContent) + parseInt(amount)    
			  // PLAY A SOUND EVERY TIME A COIN IS ADDED
			  sounds[4].play()  
			  if( stageScore < 1 ){				  
				  score = parseInt(scoreHolder.textContent)				  
				  /* SAVE TOTAL SCORE TO DB */
					spawn(function* (){				
					  //score = parseInt(scoreHolder.textContent)	
					  profile.score = yield db.profile.where({id:1}).toArray(function(i){				  
					   var scr = ( isNaN(i[0]) )?0:i[0].score 
						 console.log('scr:'+scr)
						return scr
					  })	
					  console.log('score: '+score)			  
					  console.log('profile.score: '+profile.score)
					  var totalScore = parseInt(score) + parseInt(profile.score)		  

					  db.profile.update(1,{score:totalScore})// UPDATE DB > profile > score
					})

				  
					cancelAnimationFrame( incrementScore )
					setTimeout(function(){
						
						// GET CURRENT VALUE OF gold IN DB
						
						spawn(function* (){
							profile.gold = yield db.profile.where({id:1}).toArray(function(i){								
							var gld = ( isNaN( parseInt(i[0].gold) ) )?0:parseInt(i[0].gold) 
						    console.log('gld:'+gld)
							
								return gld
							})
							
							var gld = profile.gold
							console.log('gld:'+gld)
							
							document.querySelector('#endStage .gold').textContent = gld
							incrementGold() 
						})
						
									
					},1000)									
			  }
			  else{
					//myReq = requestAnimationFrame( incrementScore )					
					setTimeout(function(){
						incrementScore() 			
					},0.05)	
			  }		  		
		}   

/*
	ADD GOLD TO PROFILE
	PARAM: 
		amount (of gold to add) - int
*/
window.profileAddGold = function(amount){
	spawn(function* (){			  
	  db.profile.update(1,{gold:amount})// UPDATE DB > profile > gold
	})
}


/*
	DURING STAGE - INGAME 
	WEAPON SELECTION -- begin
*/

window.generateWeaponsSelectUI = function(){
   
	  return new Promise(function(resolve, reject) {
   
		  if(document.querySelector('#weaponsSelector') !== null ){
			  document.querySelector('#weaponsSelector').remove()	  
		  }
		
		  if( selectedWeapons.length > 0 ){  
			var weapons = document.createElement('div')
				weapons.setAttribute('id','weaponsSelector')
				
			var weaponsList = document.createElement('ul')
				weaponsList.setAttribute('id','weaponsList')
				weapons.append(weaponsList)
				
			document.body.append(weapons)
			
			selectedWeapons.some(function(weapon, idx){
				var li = document.createElement('li')
				if( weapon != '' ){		
						//li.classList.add(weapon.category)
					var a = document.createElement('a')
							a.classList.add('equip_weapon')
						a.setAttribute('href','#')
						a.style.background = 'url(./game_assets/thumbnails/'+weapon.entityName+'.png) center center no-repeat'
						a.setAttribute('category',weapon.category)
						a.setAttribute('entityName',weapon.entityName)
						a.setAttribute('duration',weapon.duration)
						a.setAttribute('count',weapon.count)
						//a.textContent = weapon.entityName
					li.append(a)			
				}else{
								
				}
				document.querySelector('#weaponsSelector #weaponsList').append(li)
				
				
				if(idx == selectedWeapons.length -1 ){resolve()}
			})	// selectedWeapons.some		
		  //return true 
		  } // return function() 
	  }) //return new Promise(function(resolve, reject) {
		  
 }

// 
//		EQUIP PADDLE WITH SELECTED WEAPON
//	  UPDATE THIS WEAPON'S COUNT IN #weaponsList
//       
//    category, count, duration, entityName
//    duration:
//   		  >0    : count --  
//							decrease duration until duration == 0;
//        == -1 :	count --
//        			do not decrease duration
//        == -2 : unlimited
//             do not decrease duration
//              
//    weapon = get weapon by category     
//    UPDATE selectedWeapons.weapon
//   UPDATE paddle.attributes    
//
window.equipWeapon = function(paramsObject){
    //console.clear()
	  console.log(paramsObject) 
   
 //
 // 	EQUIP paddle WITH WEAPON
 //  
  
  paddle.weaponEquippedDefaultDuration = paramsObject.duration
  paddle.weaponEquippedDuration = paramsObject.duration
    
  paddleEquipWeapon(paramsObject.entityName)
  
  /*
		UPDATE INVENTORY STOCKS IF NECESSARY
  */
  var count = paramsObject.count
  if( paramsObject.duration == -2 ){
    // == -2 : unlimited
  } else if( paramsObject.duration == -1 ){
    // == -1 : count --
    count --
  } else if( paramsObject.duration > 0 ){
  	// >0    : count --    
    count -- 
  }
  
  
  
  // 
  //		UPDATE WEAPON IN selectedWeapons[]
  //
  var category = paramsObject.category
      console.log('category:'+category)
	  console.log('selectedWeapons:'+selectedWeapons)
  
  // GET WEAPON IN selectedWeapons[] BY category
 Array.prototype.filter.call(selectedWeapons,function(selectedWeapon, idx){
    if( selectedWeapon.category == category ){   
      selectedWeapon.count = count // UPDATE count
    }  
  })   
 
  console.log(JSON.stringify(selectedWeapons))
    
  // 
  //		UPDATE WEAPON BTN' count
  //
  // duration > -2 means not PERMANENT
  if (paramsObject.duration > -2){
	  
	if( count == 0 ){
		count = '+'
	}
	
    document.querySelectorAll('.equip_weapon[entityName="'+paramsObject.entityName+'"]')[0]
    .setAttribute('count',count)
	}   
}
/*
	WEAPON SELECTION -- end
*/

/*
	CHARACTER ATTRIBUTES MANAGEMENT -- begin
*/
/*
	function insertCharactersEditableAttributes()
	
	DOES:
			GENERATES CHAR ATTRIBUTES EDITOR
	
	PARAMS:
			GLOBAL profile.character[] // CACHED CHARACTER ATTRIBUTES
			GLOBAL characterAttributes // CHARACTER ATTRIBUTE DEFINITION
	
*/
window.insertCharactersEditableAttributes = function(){
	var e = document.querySelector('#characterDetails #charAttributesList')
	if ( e != undefined ){
		e.remove()
	}
	
	if( arguments.length > 0 ){
		var itemName = arguments[0].itemName
	}
	
	
	//
	//	LOAD PROFILE CHARACTER
	//	SO FAR THERE IS ONLY 1 profile = 1 character HENCE profileID = 1
	//
			
	// profile = {
	//	 character:{
	//		name:selectedChar[0].name,
	//		strength:selectedChar[0].strength,
	//		resistance:selectedChar[0].resistance,
	//		energy:selectedChar[0].energy,
	//		charisma:selectedChar[0].charisma
	//	 }	 
	// }	 	 	 
	
	// POPULATE ANGEL's NAME
	document.querySelector('#characterDetails .header .angelName').textContent = profile.character.name	
	
	// POPULATE PROFILE'S gold
	document.querySelector('#characterDetails .header .profileGold .gold').textContent = profile.gold	
	
	var charAttributesList = document.createElement('ul')   
			charAttributesList.setAttribute('id','charAttributesList')
		document.querySelector('#characterDetails').append(charAttributesList)
		
	charAttributesList = document.querySelector('#characterDetails #charAttributesList')
	
	//
	//	characterAttributes[0]: settings for M. Angelo & G. Arrow (1 & 3)
	//	characterAttributes[1]: settings for Gabrielle & Cupid (2 & 4)
	//
	//var id = ( profile.character.charId == 2 ||  profile.character.charId == 4)?1:0  
	var id = profile.character.charId
	
	//characterAttributes[id].some(function(attribute,idx){
  //spawn(function*(){  
   
  var dbConstraint = {
    profileId:1,
    characterId:1
  }      
  
  
 db.characterAttributes.where(dbConstraint).toArray()
 .then( (characterAttributes)=>{
  characterAttributes.some(function(attribute,idx){ 
    
	console.log(attribute.max)
	console.log(attribute.cost)
	
	// CREATE BTN THAT INCREASES AN ATTRIBUTE AND TRIGGERS PAYMENT IN GOLD
	var charEnhanceAttributeBtn = document.createElement('a')
			charEnhanceAttributeBtn.classList.add('charEnhanceAttributeBtn')
			charEnhanceAttributeBtn.setAttribute('href','#'+attribute.id)
			charEnhanceAttributeBtn.setAttribute('cost',attribute.cost)
			charEnhanceAttributeBtn.setAttribute('max',attribute.max)			
			
	/*		
	var description = document.createElement('div')
			description.classList.add('description')					
			description.setAttribute('txt',attribute.description)
	*/
	
	var li = document.createElement('li')
			li.setAttribute('id',attribute.id)
			li.classList.add('attrLi')
			li.setAttribute('data-title',attribute.lbl)
			li.setAttribute('data-description',attribute.description)
	li.append(charEnhanceAttributeBtn)				
	charAttributesList.append(li)	

    switch(attribute.lbl){
      case 'strength':
        var amount = profile.character.strength
      break;
      case 'resistance':
        var amount = profile.character.resistance
      break;
      case 'charisma':
        var amount = profile.character.charisma
      break;
      case 'energy':
        var amount = profile.character.energy
      break;
      case 'lives':
        var amount = profile.character.lives
      break;		
    }// END SWITCH 
  
	// GENERATE ATTRIBUTE COLORED RECTANGLES/BARS 
	var dataObject = { amount:amount, id:attribute.id, max:attribute.max}
	if( typeof (itemName) !== 'undefined' ){
		dataObject.itemName = itemName // FOR HILIGHTING THE LAST BAR ADDED - see below
	}  
	attributeLevelsDisplay(dataObject)
	
	
	//document.querySelector('#characterDetails #charAttributesList #'+attribute.id).append(attribute.description)
	})
	
	
	/*
		IF ONE CHAR ENHANCE BTN WAS CLICKED SELECT IT's PARENT LI
	*/	
	if( typeof lastClickedAttrBtn !== 'undefined' 
		&& lastClickedAttrBtn !== null
	){
		//document.querySelector(lastClickedAttrBtn).classList.add('selected')
		//document.querySelector('#'+lastClickedAttrBtn.id).classList.add('selected')
		//document.querySelector('#'+lastClickedAttrBtn.id).classList.add('selected')
		setTimeout(document.querySelector('#'+lastClickedAttrBtn.id).classList.add('selected'),1000)
	}
	// SELECT THE FIRST ATTRIBUTE
	else {
		document.querySelectorAll('.attrLi')[0].click()
	}
	
	
	
	
 })
 
} // end function insertCharactersEditableAttributes()

//insertCharactersEditableAttributes()







/*
function charEnhanceAttribute()

DOES:
	- INCREASE THE VALUE OF A DB.character ATTRIBUTE
  - DEDUCT DB.profile.gold FROM THE cost OF THE ATTRIBUTE 

	IF profileGold < cost
  	NOTIFY PLAYER "NOT ENOUGH GOLD!"
  ELSE
  	- INCREASE ATTRIBUTE BY 1
    - REDUCE profileGold BY cost
    - UPDATE profile.gold
    - UPDATE .profileGold .gold
    - NOTIFY PLAYER TRANSACTION COMPLETE
  */


window.charEnhanceAttribute = function(itemName,cost,max){  

  var profileGold = parseInt(profile.gold)
  var profileId = 1,
	  characterId = 1  // SO FAR ONLY ONE PROFILE ... & 1 CHARACTER PER PROFILE
  
  spawn(function* (){
		
	/*	
	  var li = document.querySelector('#characterDetails #charAttributesList #'+itemName)
						
		// NOTIFY OF PURCHASE WITH AN ANIMATION
		li.classList.add('glow')

		setTimeout(function(){
		if( li.classList.contains('glow')){
			li.classList.remove('glow')
		}},500)		
	*/

	var li = document.querySelector('#characterDetails #charAttributesList #'+itemName)
	
	
      var dataObject = {}    

      switch( itemName ){
          case 'strength':
             var amount = parseInt(profile.character.strength)  
                 amount ++ 
             dataObject.strength = amount
          break;
          case 'resistance':
               var amount = parseInt(profile.character.resistance)  
                 amount ++ 
             dataObject.resistance = amount
          break;
          case 'charisma':
           var amount = parseInt(profile.character.charisma)  
                 amount ++ 
             dataObject.charisma = amount
          break;
          case 'energy':
          var amount = parseInt(profile.character.energy)  
                 amount ++ 
             dataObject.energy = amount
          break;
          case 'lives':
           var amount = parseInt(profile.character.lives)  
                 amount ++ 
             dataObject.lives = amount
          break;
      } 
		
		
	  // document.querySelector('#'+lastClickedAttrBtn.id).classList.add('selected')	
		
       if( amount > max ){    
         var message = '<span class="charModalMsg">your character is already at maximum '+itemName+'</span>'		 
		 modal('modal', message,'UI-animation-down',4000 )
		 sounds[4].play()
		 li.classList.add('selected')
         return    
       }
		
       if( profileGold < cost ){    
          var message = 'you don\'t have enough gold !'
		  modal('modal', message,'UI-animation-down',4000 )
		  sounds[4].play()
		   li.classList.add('selected')
          return    
       }

        // UPDATE THE ATTRIBUTE IN DB.character
		// 1: ONLY ONE PROFILE & ONE CHARACTER SO FAR		
        yield db.character.update(1,dataObject)

        // UPDATE DB > profile > gold
        profileGold -= parseInt(cost);// gold -= cost

        // UPDATE #characterDetails .gold
        document.querySelector('#characterDetails .header .profileGold .gold').textContent = profileGold 

        // UPDATE #stageDetails .gold 
        document.querySelector('#stageDetails .score-gold .gold').textContent = profileGold 

        // UPDATE DB.profile.gold
        yield db.profile.update(1,{gold:profileGold})   

        var selectedChar = yield db.character.where('profileId').equals(profileId).toArray()

         // GET UPDATED GLOBAL OBJECT profile
			 profile = {
				 character:{
				  name:selectedChar[0].name,
				  strength:selectedChar[0].strength,
				  resistance:selectedChar[0].resistance,
				  energy:selectedChar[0].energy,
				  charisma:selectedChar[0].charisma,
				lives:selectedChar[0].lives
				},
				gold:profileGold	
			 }
		
		
			// RAISE cost OF ATTRIBUTE itemName (e.g.: strength) 
			// EVERY TIME AFTER AN INCREASE
			var dbConstraint = {
				id : itemName,
				profileId: profileId,
				characterId: characterId								
			}
			
			/*
				INCREASE THE COST OF THIS CHAR ATTRIBUTE BY 1.5
				EXCEPT FOR lives
			*/
			if( itemName != 'lives' ){
				var newCost = Math.floor(parseInt(cost) * 1.5)
				db.characterAttributes.where(dbConstraint).modify({cost: newCost})
				.then(() => {
					insertCharactersEditableAttributes({itemName:itemName})  // REGENERATE UI				
				})
			}
			else{
				insertCharactersEditableAttributes({itemName:itemName})  // REGENERATE UI	
			}
			
    }) // END spawn() 
    
}// END function charEnhanceAttribute()


/*


*/
/*
	function useGoldToContinue()
	
	PLAYER PUSHED [.pay_to_continue]
  	- DB.profile.gold -= amount
    - NOTIFY PLAYER GAME IS GOING TO RESUME
    - RESUME THE GAME
*/
window.useGoldToContinue = function(){ 
  let amount = document.querySelector('#stagePayToContinue .stageDetailsControls .pay_to_continue .amount').textContent
  //document.querySelector('#stagePayToContinue .stageDetailsControls .pay_to_continue .amount').textContent
  ////////////alert('9419- amount: '+amount)
  
  let el = document.querySelector('#stagePayToContinue')
  el.classList.remove('UI-animation-up')// REMOVE APPEARANCE ANIMATION
  
  spawn(function*(){
		// GET db.profile.gold
		yield db.profile.where({id:1}).toArray(function(i){
		   var gld = ( isNaN( parseInt(i[0].gold) ) )?0:parseInt(i[0].gold)           
		   console.log('gld:'+gld)
		   //return gld
		   profile.gold = gld
		   document.querySelector('#stagePayToContinue .profileGold .gold').textContent = profile.gold		   
		})

	  ////////////alert('9425- profile.gold: '+profile.gold)
      profile.gold -= parseInt(amount) // parseInt(profile.gold)
	  
	  ////////////alert('9428- profile.gold: '+profile.gold)
	  
      // UPDATE DB.profile.gold
	  yield db.profile.update(1,{gold:profile.gold})// UPDATE DB > profile > gold
      .then(function(){
        ////////////alert('GET READY TO CONTINUE!') 					
		
		// GIVE PADDLE A FORCE FIELD
		paddle.invincibility = paddleInvincibilityTime											
		paddle.forceField = {}
		paddle.forceField.frame = 0											 
		paddle.forceField.nextFrameAt = 1
		paddle.forceField.frameTicker = 0
		
		// REFILL PADDLE ENERGY LEVEL
		paddle.energy = profile.character.energy
		
		//drawLives(); // draw lives
		
		el.classList.add('UI-animation-down') // PERFORM EXIT SCREEN ANIMATION
		
		// WAIT FOR THE END OF THE ANIMATION TO RESUME GAME
		setTimeout(function(){

			invincibilityForAll()
			// IF RAF LOOPING, THEN EXIT IT 				
			stageEnded = false
			// HIDE THIS SCREEN
			hidePage('stagePayToContinue')

			// SHOW PAUSE BTN ...
            showPage('UI_wrapper')
			
			// RESUME 
			// START MAIN LOOP
			myReq = requestAnimationFrame( main );
			// PLAY BGM
			playStageMusic()
			// MAKE ALL BALLS ON STAGE INVINCIBLE
			
			el.classList.remove('UI-animation-down') 
		},1000);
		
      })// then() 
	  
  })// spawn()
}

/*
	MAKE ALL BALLS* INVINCIBLE FOR A LIMITED AMOUNT OF TIME
	
	* AMONG CERTAINS TYPES:
		- characters to escort
		- angels

	NO projectiles
*/
window.invincibilityForAll = function(){
	balls.some(function(ball){
		
		if( 
			/*ball.name == 'ball.entity'
			|| ball.name == 'angel.ball.ent'*/
			ball.name.indexOf('ball') != -1
			
		){
			ball.invincibility = spawnBallInvincibilityTime
				ball.forceField = {
					frame : 0,											 
					nextFrameAt : 1,
					frameTicker : 0	
				}
		}					
	})
	
}


/*

		INVENTORY FUNCTIONS  -- begin

*/


//
//		function insertInventoryItems()
//   DOES: 
//		    GENERATE LIST OF ITEMS TO BUY IN #inventory UI
//
window.insertInventoryItems = function(){
  
  var e = document.querySelector('#inventory #inventoryItems')
  if ( e != undefined ){
    e.remove()
  }

  if( arguments.length > 0 ){
    var itemName = arguments[0].itemName
  }

  // POPULATE PROFILE'S gold
  document.querySelector('#inventory .header .profileGold .gold').textContent = profile.gold  
  
   var dbConstraint = {
    profileId: 1,
    characterId: 1
  }      
  
   
   spawn(function* (){ 
   
      // GET items FROM DB.weapons
      let itemsInInventory = yield db.weapons.where(dbConstraint).toArray()

      var inventoryItems = document.createElement('ul')  
          inventoryItems.setAttribute('id','inventoryItems')
          document.querySelector('#inventory').append(inventoryItems)
          inventoryItems = document.querySelector('#inventory #inventoryItems')
     return itemsInInventory
  }) 
  .then(function(itemsInInventory){
     
    	items.some(function(attribute, idx){  
          console.log(attribute.cost)
          // CREATE BTN THAT INCREASES AN ATTRIBUTE AND TRIGGERS PAYMENT IN GOLD
          var purchaseBtn = document.createElement('a')
              purchaseBtn.classList.add('purchaseBtn')
              purchaseBtn.setAttribute('href','#'+attribute.name)
              purchaseBtn.setAttribute('cost',attribute.cost)

          let li = document.createElement('li')
              li.classList.add('itemLi')
              li.setAttribute('id',attribute.name)
              li.setAttribute('data-title',attribute.description)
         	  li.setAttribute('data-duration',attribute.duration)
         	  li.setAttribute('data-quantity',0)
				
			// SELECT THE FIRST ITEM
			if( idx == items.length-1){
                document.querySelectorAll('.itemLi')[0].click()
			}	
			
			
			
        	let slot = ''	
        
              var itemInInventory = search (attribute.name, itemsInInventory)
              if( itemInInventory != undefined ){
                li.setAttribute('data-quantity',itemInInventory.quantity)
                slot = itemInInventory.slot				
              }

          var imgContainer = document.createElement('span')
              imgContainer.setAttribute('id','img'+idx) 
              li.append(imgContainer)
              li.append(purchaseBtn)  
              inventoryItems.append(li) 

        ////////////alert(slot)
        
          // ADD 3 SLOT SELECTORS
          for( let n = 0; n < 3; n++ ){
              let span = document.createElement('span')
                  span.classList.add('slot')
              
                  if( slot === n){
                    span.classList.add('selected')
                  }
            
            			span.setAttribute('idx',n)
            			span.setAttribute('itemName',attribute.name)
                  li.append(span) 
          }

          // ADD ITEM ICON
          var img = document.createElement('img')
              img.onload = function(){
                imgContainer = document.querySelector('#inventory #inventoryItems li span#img'+idx)
                imgContainer.append(img)
              }
              img.src = 'game_assets/thumbnails/'+attribute.entityName+'.png' 

         })// some
	}) // then()
} // end function insertInventoryItems()

//
//	function purchaseItem (itemName)
//  	DOES: 
//    		ADD ONE INSTANCE OF ITEM (itemName)
//				DEDUCT DB.profile.gold
//    
//    PARAMS:
//    		itemName:  = entityName -- required
//        USED AS  REFERENCE TO INSERT THE ITEM INTO db.weapons
//
window.purchaseItem = function(itemName){
   
  var profileId = 1,
      characterId = 1  // SO FAR ONLY ONE PROFILE ... & 1 CHARACTER PER PROFILE
  
  var dbConstraint = {
    name : itemName,
    profileId: profileId,
    characterId: characterId 
  }
  
  // REMOVE PREVIOUS VISUAL PURCHASE NOTIFICATION CLASS
  var li = document.querySelector('#inventory #inventoryItems #'+itemName)
   if( li.classList.contains('glow')){
			li.classList.remove('glow')
   }  
  
  
  
	var slotIdx = ''
  
  
	 /*
		IF SLOT IS SELECTED THEN SET IT SO IN THE OBJECT -- begin
	 */
	 //var itemName = 'sword-shield-powerup'


document.querySelectorAll('#inventory #inventoryItems #'+itemName+' .slot').forEach(function(slot){
	console.log(slot)
	console.log(slot.classList.contains('selected'))
	
	var isEquipped = (slot.classList.contains('selected'))?true:false			
	
	console.log(isEquipped)
	
	if(isEquipped === true){
		slotIdx = parseInt(slot.getAttribute('idx'))
	}  
	
})
/*
	IF SLOT IS SELECTED THEN SET IT SO IN THE OBJECT -- end
*/
  
  
  let item = search(itemName, items) 
  spawn(function* (){    
		var dataObject = item
		

			dataObject.profileId = profileId
			dataObject.characterId = characterId
			dataObject.quantity = 1 
			dataObject.slot = slotIdx 
      var quantity = 0;    
      var cost = parseInt(dataObject.cost)
      // GET DB.profile.gold, UPDATE .gold
      profile.gold = yield db.profile.where({id:profileId}).toArray(function(i){
         var gld = ( isNaN( parseInt(i[0].gold) ) )?0:parseInt(i[0].gold)           
         console.log('gld:'+gld)
         return gld
      })
      var profileGold = parseInt(profile.gold)            
       if( profileGold < cost ){		   
          var message = 'you don\'t have enough gold !'
		  modal('modal', message,'UI-animation-down',4000 )
		  // NOTIFY OF PURCHASE FAIL WITH A SOUND
		  sounds[4].play()
          return 
       }
	   
	   // NOTIFY OF PURCHASE WITH A SOUND
	   sounds[7].play()
	   
       // PAYMENT -- begin  
        // UPDATE DB > profile > gold
        profileGold -= parseInt(cost);// gold -= cost
        // UPDATE #inventory .profileGold .gold
        document.querySelector('#inventory .header .profileGold .gold').textContent = profileGold       
        document.querySelector('#stageDetails .score-gold .gold').textContent = profileGold 
        profile.gold = profileGold
    
        // UPDATE DB.profile.gold
        yield db.profile.update(profileId,{gold:profileGold})
        
    // PAYMENT -- end   
    
    // UPDATE THE ATTRIBUTE IN DB.weapons
    // 1: ONLY ONE PROFILE & ONE CHARACTER SO FAR   
    
   //
   // 		GET item BY name
    //    	IF item exists
   //       	GET ITS COUNT ATTRIBUTE
   //         	INCREASE IT BY ONE
   //           ADD count to dataObject
   //           UPDATE item in DB.weapons
   //        ELSE
   //       		ADD item
   //       ENDIF           
   //
   
    var itemInInventory = yield db.weapons.where('name').equals(item.name).first()
    
    if( typeof itemInInventory !=='undefined' ){
    		quantity = parseInt(itemInInventory.quantity) 
    		quantity ++
        yield db.weapons
		.where('name')
		.equals(item.name)
		.modify({quantity:quantity})
		.finally(function(){updateWeaponsUI()})
    }
    else{
     
      	// ADD item TO DB.weapons
        yield db.weapons.add(dataObject)
      	quantity = 1
    }
   
    // NOTIFY OF PURCHASE WITH AN ANIMATION
    li.classList.add('glow')
    
    setTimeout(function(){
		if( li.classList.contains('glow')){
				li.classList.remove('glow')
		}	
	},500)
    
    document.querySelector('#inventory #inventoryItems #'+itemName)
	.setAttribute('data-quantity',quantity)
	
	/*
	selectedWeaponsPopulate()
	
	generateWeaponsSelectUI()
	*/
	/*
		var slotIdx = event.target.getAttribute('idx')
		var itemName = event.target.getAttribute('itemName')
		
		var paramsObject = {
			idx: slotIdx,
			itemName: itemName
		}
		itemSlotSelect( paramsObject )
		return
	*/
	
	//updateWeaponsUI()
	
    
    }) // END spawn()
	
	
	
	
} // function() 

/*
function itemSlotSelect()

	DOES:
  		ALLOCATE / UNALLOCATE AN ITEM TO A SLOT
      ADD/UPDATE ATTRIBUTE slot TO DB.weapons.[weapon]
      UPDATE selectedWeapons[]
   
   USE:      
        var paramsObject = {
              idx: slotIdx,
              itemName: itemName
            }
        itemSlotSelect(paramsObject)

*/
window.itemSlotSelect = function( paramsObject ){
   var profileId = 1,
       characterId = 1
   
   var dbConstraint = {
    name : paramsObject.itemName,
    profileId: profileId,
    characterId: characterId 
  }
   
  var slots = document.querySelectorAll('#inventory #inventoryItems li#'+paramsObject.itemName+' .slot')
 
  var slot = slots[ parseInt(paramsObject.idx) ]
  if(slot.classList.contains('selected')){
    // IF IS SELECTED THEN DESELECT IT
    
      slot.classList.remove('selected')
    db.weapons.where(dbConstraint).modify({slot:''})
	.finally( () => {selectedWeaponsPopulate('show') })
    sounds[4].play() // tik
    
  }else{
    /*
    	IF IS NOT SELECTED THEN 
      	IF PARENT LI DOES NOT HAVE ANOTHER SELECTED SLOT
        	SELECT IT
        ELSE
        	RETURN
        ENDIF
       ENDIF
    */    
     var selectedSlots = Array.prototype.filter.call(slots, function(slt,idx){  
       if(slt.classList.contains('selected')){
         return slt
       }
	  })
     
     // IF THERE IS NO OITHER SLOT SELECTED FIOR THE SAME ITEM
     if( selectedSlots.length < 1 ){
        
       let Idx0 = slot.getAttribute('idx')// get idx to compare with slots from other items       
       
        var otherItemsSlots = document.querySelectorAll('#inventory #inventoryItems li:not('+paramsObject.itemName+') .slot')
        var otherSelectedSlots = Array.prototype.filter.call( otherItemsSlots, function(slt,idx){ 
          var Idx1 = slt.getAttribute('idx')// get idx to compare with slots fronm other items
           if( slt.classList.contains('selected') && Idx1 == Idx0){
             return slt
           }
      	})
        if( otherSelectedSlots.length < 1 ){
          db.weapons.where(dbConstraint).modify({slot:parseInt(Idx0)})
          .then(function(){
			slot.classList.add('selected')
            sounds[4].play() // tik
			selectedWeaponsPopulate('show')
			})        	
        }//if( otherSelectedSlots.length < 1 ){
        else{
          console.log('another item occupies this slot')
        }
     }// if( selectedSlots.length < 1 ){
     else{
       console.log('an item can only take one slot')
     }
  }// if(slot.classList.contains('selected')){ } else {}
  
   //updateWeaponsUI()
   selectedWeaponsPopulate('show')
}



/*
		function selectedWeaponsPopulate()
    		DOES:
        			POPULATE selectedWeapons[]
        PARAMS
        			USES DB.weapons
*/ 
window.selectedWeaponsPopulate = function(){
		  
  //console.clear()
  
  let showHide = ''
  if( arguments.length > 0 ){
	  showHide = arguments[0]
  }	  
  
  	var profileId = 1,
       characterId = 1
   
   var dbConstraint = {     
      profileId: profileId,
      characterId: characterId 
    }
   
   spawn( function* (){   
     var weapons = yield db.weapons.where( dbConstraint ).toArray()
       
     selectedWeapons = []
     var selectedWeapons0 = [] 
     
     Array.prototype.some.call(weapons,function(weapon,idx){
       	if( parseInt(weapon.slot) >= 0 ){
          selectedWeapons0.push(weapon)
        }       
     })
     
     /*
     		IF SOME WEAPONS ARE ALLOCATED TO SLOTS
        	POPULATE selectedWeapons[]
     */
     if( selectedWeapons0.length > 0){
       for( let n = 0; n < 3; n++ ){
           selectedWeapons[n] = ''
         Array.prototype.filter.call(selectedWeapons0,function(weapon,idx){
            if( parseInt(weapon.slot) == n ){
              weapon.count = parseInt(weapon.quantity)
              selectedWeapons[n] = weapon
            }       
         })         
       }       
     }
	
	/*
		DISPLAY (OR NOT)
		THE INGAME INVENTORY SELECTOR
		TO LET THE PLAYER SEE ITS INVENTORY 
		WHEN NOT INGAME
	*/
	generateWeaponsSelectUI()
	.then(function(){			  
	  if( showHide != '' ){		  
			switch(showHide){
				case 'show':				
					document.querySelector('#weaponsSelector').classList.add('inmenu')
				break;
				case 'hide':
					document.querySelector('#weaponsSelector').classList.remove('inmenu')
				break;
			}		 
	  }	  
	})
	 
	 	 
   })// end spawn()
}


/*
	updateWeaponsUI() = 
	
	selectedWeaponsPopulate()
	+
	generateWeaponsSelectUI()
	+
	document.querySelector('#weaponsSelector').classList.add('toFront')
	
*/
window.updateWeaponsUI = function(){
    selectedWeaponsPopulate('show')
	//generateWeaponsSelectUI()
	//document.querySelector('#weaponsSelector').classList.add('toFront')
}




/*

		INVENTORY FUNCTIONS  -- end

*/


/*		
    function DBupdateWeaponsList ()
    	DOES:
      		UPDATE LIST OF WEAPON IN DB
      USED INGAME WHEN .quit OR endStage()
*/
window.DBupdateWeaponsList = function(){
  var list = document.querySelector('#weaponsSelector #weaponsList')
  /* 
    IF #weaponsList
      FOR EACH anachor IN list
        UPDATE DB.weapons
  */
  
  if( list != null){
    var params = []
  
      list.childNodes.forEach((i)=>{

        // GET ANCHOR
        var a = i.children[0]
		
			if( typeof a !=='undefined' ){
		
				var entityName = a.getAttribute('entityName')		
				var count = a.getAttribute('count')
				 
				if(isNaN(count)){
					count = 0
				}
				
				var paramsObject = {
				  entityName: entityName, 
				  quantity: parseInt(count)        
				}
				  params.push(paramsObject)
			  
			 }// end if a !=== 'undefined' 
		  })
		  
		  if( params.length > 0 ){		  
			  spawn(function*(){
				for( let n = 0; n < params.length; n++ ){          
				  var paramsObject = params[n]
				  yield db.weapons.where('entityName').equals(paramsObject.entityName).modify({quantity:paramsObject.quantity})
				}// end for 
			  })
			  .then(()=>{console.log('UPDATED')})
		  }
  }
  else{
		// NOTHING TO UPDATE
  }
}

/*
	givePaddleWeapon()
	PARAMS:
		- GLOBAL charactersActionsSprites
		- spriteName: xxxx.sprt - sprite name
	
*/  
window.paddleEquipWeapon = function (spriteName){
	
	/*
		RECORD WEAPON USE FRO OBJECTIVES BONUS
	*/
	let timesUsedWeapons = stage.timesUsedWeapons
		timesUsedWeapons++
	stage.timesUsedWeapons = timesUsedWeapons
	
	// WILL BE ADDED IF IT IS AN UPGRADE
	let currentSprite = paddle.currentSprite,
		sprt = '',
		weapon = ''
		
  switch( spriteName ){	
  
  // BOW & ARROWS GIVES BOWS AND ARROWS TO ANGEL
	  case 'bow-arrow-powerup.ent':								
		    sprt = charactersActionsSprites[profile.character.charId].shooting
			setPaddleSprite(sprt)
			paddle.weapon = 'bow'
			paddle.strength = profile.character.strength								
			paddle.resistance = profile.character.resistance						
	  break;
	  
	  // BOW & ARROWS GIVES BOWS AND ARROWS TO ANGEL
	  case 'boxing-gloves-powerup.ent':
			sprt = charactersActionsSprites[profile.character.charId].boxing
			setPaddleSprite(sprt)
			paddle.weapon = 'gloves'
			weapon = search(spriteName,entities)															
			paddle.strength = parseInt(weapon.strength) + parseInt(profile.character.strength)
			paddle.resistance = profile.character.resistance								
	  break;
	  
	  // GIVE SWORD AND SHIELD TO ANGEL
	  case 'sword-shield-powerup.ent':	
			sprt = charactersActionsSprites[profile.character.charId].swordShield
			setPaddleSprite(sprt)
			paddle.weapon = 'swordAndShield'								
			weapon = search(spriteName,entities)															
			paddle.strength = parseInt(weapon.strength) + parseInt(profile.character.strength)
			paddle.resistance = parseInt(weapon.resistance) + parseInt(profile.character.resistance)
	  break;
	  
	  // ANGEL PORTAL THAT SPAWNS ANGELS FOR A DEFINITE AMOUNT OF TIME
	  case 'angel-portal-powerup.ent':								
			sprt = charactersActionsSprites[profile.character.charId].pushing
			setPaddleSprite(sprt)
			paddle.weapon = 'portal'
			paddle.strength = profile.character.strength								
			paddle.resistance = profile.character.resistance
			spawnEntityFromJson('angel-portal.ent')							
	  break;

  }// end switch
  
  /*
	IF IT IS AN UPGRADE OF THE SAME ACTIVE WEAPON
		- make it more powerful
		- last longer
		- give more resistance to the paddle
  */
	if( currentSprite == sprt){
		paddle.weaponEquippedDuration = parseInt(paddle.weaponEquippedDuration) + parseInt(paddle.WED)		
		paddle.strength = parseInt(paddle.PR) + parseInt(weapon.strength)
		paddle.resistance = parseInt(paddle.STR) + parseInt(weapon.resistance)
		console.log(weapon)
		console.log(paddle.weaponEquippedDuration+' \r\n'+paddle.strength+' \r\n'+paddle.resistance+' \r\n')
		paddle.WED = paddle.weaponEquippedDuration
	    paddle.PR =  paddle.resistance
	    paddle.STR = paddle.strength
		
	}else{
		paddle.WED = 0
		paddle.PR =  0
		paddle.STR = 0
	}
  
}



/*
	function newGame()	
		NO PARAMS
			RESET EVERYTHING INDEXED DB IS CLEARED
			REDIRECT USER TO CHARACTER SELECTION SCREEN	
*/
/*
window.newGame = function(){
	//db.delete().then(() => {		
		var el = document.querySelector('#stageSelection #stagesList')
if(typeof el !='undefined'){
    el.remove()
}

db.close()
db.open()

//

spawn(function*(){


      //FIRST LAUNCH: INIT PROFILE

     ///
     //       CURRENT CAMPAIGN NOT FOUND
     //       CREATE PROFILE
     //     SET ITS ATTRIBUTE campaignId to default campaign 
     //     i.e.: 'myFirstCampaign.cmp.json'            
     //	
	 
	 initStoragePersistence()	

      // SET A DEFAULT CAMPAIGN
       campaign = 'myFirstCampaign.cmp.json'	
       //campaign = 'shortCmp.cmp.json'	

      // CREATE PROFILE
      var idProfile = yield db.profile.add({			
        creationDate: Date.now(),
        gold: 100000000000
      })
      console.log ("PROFILE CREATED !");		
	  
	  // REMOVE ALL CAMPAIGNS FROM DEXIE DB
	  yield db.campaigns.clear()
	  
      yield db.campaigns.add({			
        name: campaign			
      })		
      .then(function( idCampaign ){

          db.profile.update(idProfile, {campaignId: idCampaign})
            .then(function (updated) {
            if (updated) {
                console.log ("PROFILE WAS UPDATED !");					

            }
          })
        return idCampaign 
      })
    .then(function( idCampaign ){
	
	//////////alert('idCampaign: '+idCampaign)

    //
    //    LOAD THE stages-menu-select-XXXXXXXX.cmp.json
    //        - populate DB: stagesList
    //        DB: stagesList is used to generate stages selectors UI

    

      fetch('stages-menu-select-'+campaign)
      .then(response => {
        if (!response.ok) {
          throw new Error('No stagesList .json file found!');
        }
        return response.json();
      })
      .then( response => { 				 
         ///
         //   Populate DB: stagesList with default values
         //

         response.stages.some(function(stage,idx){
             stage.campaignId = idCampaign
             stage.gold = 0
             stage.score = 0
             stage.bestCombo = 0
             stage.unlocked = false					 
         })

         spawn(function* (){					 
            yield db.stagesList.bulkPut( response.stages )	
            .then(function(lastKey){						

            })
         })				 	

      })// then
		
	//	spawn(function* (){					 
	//		yield db.stagesList
	//		.where('campaignId')
	//		.equals(1)//idCampaign -- when several campaigns will be used, id increment must be reset to 0 
	//		.modify({        
	//			gold: 0,
	//			score: 0,
	//			bestCombo: 0,
	//			unlocked: false	
	//		})
	//	})		
		
		createStageList4()
		generateCharacterSelectUI()

		selectPage('characterSelection');
		document.location.href = '#charLi0'// fix for scroll in character selection screen 
    }) // then

})


	//})
}*/

/*
	LOCK OR UNLOCK STAGES
	BASED ON db.stagesList .unlocked property
	
	.unlocked property is updated to true when a stage is completed

*/
window.stageLockUnlock = function(){	
    spawn(function* (){
        let i = 0
        yield db.stagesList
        .toArray()
        .then(function(o){
            o.some(function(ob){
             console.log( i+' '+ob.unlocked)
                if( i > 0 ){
                    let elem = document.querySelector('#stageSelection #stagesList ul li a.stage_select[href="'+ob.name+'"]')
                    if ( ob.unlocked === false){                
                        elem.classList.add('unselectable')
                    }
                    else if(elem.classList.contains('unselectable')){
                        elem.classList.remove('unselectable')
                    }
                }
            i++
            })// some
        })// then
    })// spawn
}

/*
	function changeCharacter()
		NO PARAMS
			CHANGE CHARACTER
*/
window.changeCharacter = function(){
	// CHANGE CHARACTER
	generateCharacterSelectUI()
	selectPage('characterSelection')
	document.location.href = '#charLi0'// fix for scroll
	
	
	
	
	// playSound('heavenly_music-loop') // WORKS
}


/*
	HIDE OR DISPLAY & INIT 
	INGAME OBJECTIVBES FIELDS
	TO BE USED AT STAGE START

initObjectivesDisplay()
window.initObjectivesDisplay = function(){
// HIDE ALL #bricks,#targets,#timer,#combos
document.querySelector('#bricks').style.display = 'none'
document.querySelector('#combos').style.display = 'none'
document.querySelector('#targets').style.display = 'none'
document.querySelector('#timer').style.display = 'none'

    objectives.some(function(item, idx){
        //consol.style.display = 'block'e.log(idx+' '+item)
        switch (item.name){
            case "destroyBW":
                document.querySelector('#bricks')
                .style.display = 'inline-block'            
                document.querySelector('#bricks')
                .innerHtml = bricksTotal 
            break;       
            case "minCombos":
                document.querySelector('#combos')
                .style.display = 'inline-block'
                document.querySelector('#combos')
                .innerHtml = item.value      
            break;
            case "targets":
                document.querySelector('#targets')
                .style.display = 'inline-block'
                document.querySelector('#targets')
                .innerHtml = item.value      
            break;
            case "timer":
                document.querySelector('#timer')
                .style.display = 'inline-block'            
                document.querySelector('#timer')
                .innerHtml = item.value 
            break;    
        }
    })
}
*/
/** Check if storage is persisted already.
  @returns {Promise<boolean>} Promise resolved with true if current origin is
  using persistent storage, false if not, and undefined if the API is not
  present.
*/
async function isStoragePersisted() {
  return await navigator.storage && navigator.storage.persisted ?
    navigator.storage.persisted() :
    undefined;
}

/** Tries to convert to persisted storage.
  @returns {Promise<boolean>} Promise resolved with true if successfully
  persisted the storage, false if not, and undefined if the API is not present.
*/
async function persist() {
  return await navigator.storage && navigator.storage.persist ?
    navigator.storage.persist() :
    undefined;
}

/** Queries available disk quota.
  @see https://developer.mozilla.org/en-US/docs/Web/API/StorageEstimate
  @returns {Promise<{quota: number, usage: number}>} Promise resolved with
  {quota: number, usage: number} or undefined.
*/
async function showEstimatedQuota() {
  return await navigator.storage && navigator.storage.estimate ?
    navigator.storage.estimate() :
    undefined;
}

/** Tries to persist storage without ever prompting user.
  @returns {Promise<string>}
    "never" In case persisting is not ever possible. Caller don't bother
      asking user for permission.
    "prompt" In case persisting would be possible if prompting user first.
    "persisted" In case this call successfully silently persisted the storage,
      or if it was already persisted.
*/
async function tryPersistWithoutPromtingUser() {
  if (!navigator.storage || !navigator.storage.persisted) {
    return "never";
  }
  let persisted = await navigator.storage.persisted();
  if (persisted) {
    return "persisted";
  }
  if (!navigator.permissions || !navigator.permissions.query) {
    return "prompt"; // It MAY be successful to prompt. Don't know.
  }
  const permission = await navigator.permissions.query({
    name: "persistent-storage"
  });
  if (permission.state === "granted") {
    persisted = await navigator.storage.persist();
    if (persisted) {
      return "persisted";
    } else {
      throw new Error("Failed to persist");
    }
  }
  if (permission.state === "prompt") {
    return "prompt";
  }
  return "never";
}


window.hideNavigationBtnsWhenInit = function(){
    let lArr = [],
        hide = false
    lArr.push(document.querySelector('#characterSelectionFooter ul li a[href="#stageSelection"]'))
    lArr.push(document.querySelector('#characterSelectionFooter ul li a[href="#homeScreen"]'))
    lArr.push(document.querySelector('#characterSelectionFooter ul li a[href="#"]'))

    spawn(function*(){

    // GET PROFILE WHERE campaignId > 0
    var profile = yield db.characterAttributes.where('profileId').above(0).first()

        lArr.some(function(o,i){
           if( typeof profile === 'undefined'){		
                o.classList.add('hidden')
           }else{
                o.classList.remove('hidden')
           }
        })
    })
}

/*
	WRITE BRIEFING LETTER BY LETTER -- begin
*/
window.addALetter = function(){
    return new Promise(function(resolve, reject) {
        if (N < BriefingContainerStr.length ){        
            let Str = BriefingContainer.innerHTML
            let char = BriefingContainerStr.substr(N, 1)
                char = (char == '*')?'<br/>':char
                Str += char
                sounds[4].play()
                BriefingContainer.innerHTML = Str
                N++ 
            resolve()
        }
        else{
            resolve()
        }
     })// return new promise
}    

window.startWritingBriefing = function(){          
    if (N < BriefingContainerStr.length ){
        addALetter()
        .then(function(){
            setTimeout(function(){
                startWritingBriefing()                
            },30) 
        })
     }
}

window.initiateWritingBriefing = function(){   
    window.BriefingContainer = document.querySelector('#modal .message')
    window.BriefingContainer.innerHTML = ''
    window.N = 0
   //window.BriefingContainerStr = stage.briefing.replace('<br/>','*')
    window.BriefingContainerStr = stage.briefing.replace(new RegExp('<br/>', 'g'), '*');
    startWritingBriefing()
	
	if( arguments.length == 1 && arguments[0] !== null){
		/*
			CLOSE THE BRIEFING MODAL WHEN THE MODAL IS LOADED AUTOMATICALLY
		*/
		setTimeout(function(){
			if(document.querySelectorAll('.ui-stage-close-btn-47x47.btnCloseBriefing.UI-animation-down').length > 0){
				document.querySelector('.ui-stage-close-btn-47x47.btnCloseBriefing.UI-animation-down').click()	
			}
		},parseInt(30*BriefingContainerStr.length)+arguments[0])
	}
}
/*
	WRITE BRIEFING LETTER BY LETTER -- end
*/


async function initStoragePersistence() {
  const persist = await tryPersistWithoutPromtingUser();
  switch (persist) {
    case "never":
      console.log("Not possible to persist storage");
      break;
    case "persisted":
      console.log("Successfully persisted storage silently");
      break;
    case "prompt":
      console.log("Not persisted, but we may prompt user when we want to.");
      break;
  }
}

</script>
	

</body>

</html>
